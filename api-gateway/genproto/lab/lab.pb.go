// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: lab/lab.proto

package lab

import (
	context "context"
	encoding_binary "encoding/binary"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	empty "github.com/golang/protobuf/ptypes/empty"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type SubCategoryFindReq struct {
	Limit                int64    `protobuf:"varint,1,opt,name=limit,proto3" json:"limit"`
	Page                 int64    `protobuf:"varint,2,opt,name=page,proto3" json:"page"`
	CategoryId           string   `protobuf:"bytes,3,opt,name=category_id,json=categoryId,proto3" json:"category_id"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SubCategoryFindReq) Reset()         { *m = SubCategoryFindReq{} }
func (m *SubCategoryFindReq) String() string { return proto.CompactTextString(m) }
func (*SubCategoryFindReq) ProtoMessage()    {}
func (*SubCategoryFindReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_328b0473e092dc8d, []int{0}
}
func (m *SubCategoryFindReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SubCategoryFindReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SubCategoryFindReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SubCategoryFindReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SubCategoryFindReq.Merge(m, src)
}
func (m *SubCategoryFindReq) XXX_Size() int {
	return m.Size()
}
func (m *SubCategoryFindReq) XXX_DiscardUnknown() {
	xxx_messageInfo_SubCategoryFindReq.DiscardUnknown(m)
}

var xxx_messageInfo_SubCategoryFindReq proto.InternalMessageInfo

func (m *SubCategoryFindReq) GetLimit() int64 {
	if m != nil {
		return m.Limit
	}
	return 0
}

func (m *SubCategoryFindReq) GetPage() int64 {
	if m != nil {
		return m.Page
	}
	return 0
}

func (m *SubCategoryFindReq) GetCategoryId() string {
	if m != nil {
		return m.CategoryId
	}
	return ""
}

type AnalysisGetReq struct {
	Field                string   `protobuf:"bytes,1,opt,name=field,proto3" json:"field"`
	Value                string   `protobuf:"bytes,2,opt,name=value,proto3" json:"value"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AnalysisGetReq) Reset()         { *m = AnalysisGetReq{} }
func (m *AnalysisGetReq) String() string { return proto.CompactTextString(m) }
func (*AnalysisGetReq) ProtoMessage()    {}
func (*AnalysisGetReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_328b0473e092dc8d, []int{1}
}
func (m *AnalysisGetReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AnalysisGetReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AnalysisGetReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AnalysisGetReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AnalysisGetReq.Merge(m, src)
}
func (m *AnalysisGetReq) XXX_Size() int {
	return m.Size()
}
func (m *AnalysisGetReq) XXX_DiscardUnknown() {
	xxx_messageInfo_AnalysisGetReq.DiscardUnknown(m)
}

var xxx_messageInfo_AnalysisGetReq proto.InternalMessageInfo

func (m *AnalysisGetReq) GetField() string {
	if m != nil {
		return m.Field
	}
	return ""
}

func (m *AnalysisGetReq) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

type AnalysisReq struct {
	Id                   string   `protobuf:"bytes,1,opt,name=id,proto3" json:"id"`
	ClientId             int64    `protobuf:"varint,2,opt,name=client_id,json=clientId,proto3" json:"client_id"`
	AparatId             string   `protobuf:"bytes,3,opt,name=aparat_id,json=aparatId,proto3" json:"aparat_id"`
	AnalysisUrl          string   `protobuf:"bytes,4,opt,name=analysis_url,json=analysisUrl,proto3" json:"analysis_url"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AnalysisReq) Reset()         { *m = AnalysisReq{} }
func (m *AnalysisReq) String() string { return proto.CompactTextString(m) }
func (*AnalysisReq) ProtoMessage()    {}
func (*AnalysisReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_328b0473e092dc8d, []int{2}
}
func (m *AnalysisReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AnalysisReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AnalysisReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AnalysisReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AnalysisReq.Merge(m, src)
}
func (m *AnalysisReq) XXX_Size() int {
	return m.Size()
}
func (m *AnalysisReq) XXX_DiscardUnknown() {
	xxx_messageInfo_AnalysisReq.DiscardUnknown(m)
}

var xxx_messageInfo_AnalysisReq proto.InternalMessageInfo

func (m *AnalysisReq) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *AnalysisReq) GetClientId() int64 {
	if m != nil {
		return m.ClientId
	}
	return 0
}

func (m *AnalysisReq) GetAparatId() string {
	if m != nil {
		return m.AparatId
	}
	return ""
}

func (m *AnalysisReq) GetAnalysisUrl() string {
	if m != nil {
		return m.AnalysisUrl
	}
	return ""
}

type AnalysisResp struct {
	Id                   string   `protobuf:"bytes,1,opt,name=id,proto3" json:"id"`
	ClientId             int64    `protobuf:"varint,2,opt,name=client_id,json=clientId,proto3" json:"client_id"`
	AparatId             string   `protobuf:"bytes,3,opt,name=aparat_id,json=aparatId,proto3" json:"aparat_id"`
	AnalysisUrl          string   `protobuf:"bytes,4,opt,name=analysis_url,json=analysisUrl,proto3" json:"analysis_url"`
	CreatedAt            string   `protobuf:"bytes,5,opt,name=created_at,json=createdAt,proto3" json:"created_at"`
	UpdatedAt            string   `protobuf:"bytes,6,opt,name=updated_at,json=updatedAt,proto3" json:"updated_at"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AnalysisResp) Reset()         { *m = AnalysisResp{} }
func (m *AnalysisResp) String() string { return proto.CompactTextString(m) }
func (*AnalysisResp) ProtoMessage()    {}
func (*AnalysisResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_328b0473e092dc8d, []int{3}
}
func (m *AnalysisResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AnalysisResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AnalysisResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AnalysisResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AnalysisResp.Merge(m, src)
}
func (m *AnalysisResp) XXX_Size() int {
	return m.Size()
}
func (m *AnalysisResp) XXX_DiscardUnknown() {
	xxx_messageInfo_AnalysisResp.DiscardUnknown(m)
}

var xxx_messageInfo_AnalysisResp proto.InternalMessageInfo

func (m *AnalysisResp) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *AnalysisResp) GetClientId() int64 {
	if m != nil {
		return m.ClientId
	}
	return 0
}

func (m *AnalysisResp) GetAparatId() string {
	if m != nil {
		return m.AparatId
	}
	return ""
}

func (m *AnalysisResp) GetAnalysisUrl() string {
	if m != nil {
		return m.AnalysisUrl
	}
	return ""
}

func (m *AnalysisResp) GetCreatedAt() string {
	if m != nil {
		return m.CreatedAt
	}
	return ""
}

func (m *AnalysisResp) GetUpdatedAt() string {
	if m != nil {
		return m.UpdatedAt
	}
	return ""
}

type SubCategoriesRes struct {
	Info                 []*SubCategoryRes `protobuf:"bytes,1,rep,name=info,proto3" json:"info"`
	Count                int64             `protobuf:"varint,2,opt,name=count,proto3" json:"count"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *SubCategoriesRes) Reset()         { *m = SubCategoriesRes{} }
func (m *SubCategoriesRes) String() string { return proto.CompactTextString(m) }
func (*SubCategoriesRes) ProtoMessage()    {}
func (*SubCategoriesRes) Descriptor() ([]byte, []int) {
	return fileDescriptor_328b0473e092dc8d, []int{4}
}
func (m *SubCategoriesRes) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SubCategoriesRes) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SubCategoriesRes.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SubCategoriesRes) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SubCategoriesRes.Merge(m, src)
}
func (m *SubCategoriesRes) XXX_Size() int {
	return m.Size()
}
func (m *SubCategoriesRes) XXX_DiscardUnknown() {
	xxx_messageInfo_SubCategoriesRes.DiscardUnknown(m)
}

var xxx_messageInfo_SubCategoriesRes proto.InternalMessageInfo

func (m *SubCategoriesRes) GetInfo() []*SubCategoryRes {
	if m != nil {
		return m.Info
	}
	return nil
}

func (m *SubCategoriesRes) GetCount() int64 {
	if m != nil {
		return m.Count
	}
	return 0
}

type SubCategory struct {
	Id                   string   `protobuf:"bytes,1,opt,name=id,proto3" json:"id"`
	Name                 string   `protobuf:"bytes,2,opt,name=name,proto3" json:"name"`
	CategoryId           string   `protobuf:"bytes,3,opt,name=category_id,json=categoryId,proto3" json:"category_id"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SubCategory) Reset()         { *m = SubCategory{} }
func (m *SubCategory) String() string { return proto.CompactTextString(m) }
func (*SubCategory) ProtoMessage()    {}
func (*SubCategory) Descriptor() ([]byte, []int) {
	return fileDescriptor_328b0473e092dc8d, []int{5}
}
func (m *SubCategory) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SubCategory) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SubCategory.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SubCategory) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SubCategory.Merge(m, src)
}
func (m *SubCategory) XXX_Size() int {
	return m.Size()
}
func (m *SubCategory) XXX_DiscardUnknown() {
	xxx_messageInfo_SubCategory.DiscardUnknown(m)
}

var xxx_messageInfo_SubCategory proto.InternalMessageInfo

func (m *SubCategory) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *SubCategory) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *SubCategory) GetCategoryId() string {
	if m != nil {
		return m.CategoryId
	}
	return ""
}

type SubCategoryRes struct {
	Id                   string   `protobuf:"bytes,1,opt,name=id,proto3" json:"id"`
	Name                 string   `protobuf:"bytes,2,opt,name=name,proto3" json:"name"`
	CategoryId           string   `protobuf:"bytes,3,opt,name=category_id,json=categoryId,proto3" json:"category_id"`
	CreatedAt            string   `protobuf:"bytes,4,opt,name=created_at,json=createdAt,proto3" json:"created_at"`
	UpdatedAt            string   `protobuf:"bytes,5,opt,name=updated_at,json=updatedAt,proto3" json:"updated_at"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SubCategoryRes) Reset()         { *m = SubCategoryRes{} }
func (m *SubCategoryRes) String() string { return proto.CompactTextString(m) }
func (*SubCategoryRes) ProtoMessage()    {}
func (*SubCategoryRes) Descriptor() ([]byte, []int) {
	return fileDescriptor_328b0473e092dc8d, []int{6}
}
func (m *SubCategoryRes) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SubCategoryRes) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SubCategoryRes.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SubCategoryRes) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SubCategoryRes.Merge(m, src)
}
func (m *SubCategoryRes) XXX_Size() int {
	return m.Size()
}
func (m *SubCategoryRes) XXX_DiscardUnknown() {
	xxx_messageInfo_SubCategoryRes.DiscardUnknown(m)
}

var xxx_messageInfo_SubCategoryRes proto.InternalMessageInfo

func (m *SubCategoryRes) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *SubCategoryRes) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *SubCategoryRes) GetCategoryId() string {
	if m != nil {
		return m.CategoryId
	}
	return ""
}

func (m *SubCategoryRes) GetCreatedAt() string {
	if m != nil {
		return m.CreatedAt
	}
	return ""
}

func (m *SubCategoryRes) GetUpdatedAt() string {
	if m != nil {
		return m.UpdatedAt
	}
	return ""
}

type Category struct {
	Id                   string   `protobuf:"bytes,1,opt,name=id,proto3" json:"id"`
	Name                 string   `protobuf:"bytes,2,opt,name=name,proto3" json:"name"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Category) Reset()         { *m = Category{} }
func (m *Category) String() string { return proto.CompactTextString(m) }
func (*Category) ProtoMessage()    {}
func (*Category) Descriptor() ([]byte, []int) {
	return fileDescriptor_328b0473e092dc8d, []int{7}
}
func (m *Category) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Category) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Category.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Category) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Category.Merge(m, src)
}
func (m *Category) XXX_Size() int {
	return m.Size()
}
func (m *Category) XXX_DiscardUnknown() {
	xxx_messageInfo_Category.DiscardUnknown(m)
}

var xxx_messageInfo_Category proto.InternalMessageInfo

func (m *Category) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Category) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

type CategoryRes struct {
	Id                   string   `protobuf:"bytes,1,opt,name=id,proto3" json:"id"`
	Name                 string   `protobuf:"bytes,2,opt,name=name,proto3" json:"name"`
	CreatedAt            string   `protobuf:"bytes,3,opt,name=created_at,json=createdAt,proto3" json:"created_at"`
	UpdatedAt            string   `protobuf:"bytes,4,opt,name=updated_at,json=updatedAt,proto3" json:"updated_at"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CategoryRes) Reset()         { *m = CategoryRes{} }
func (m *CategoryRes) String() string { return proto.CompactTextString(m) }
func (*CategoryRes) ProtoMessage()    {}
func (*CategoryRes) Descriptor() ([]byte, []int) {
	return fileDescriptor_328b0473e092dc8d, []int{8}
}
func (m *CategoryRes) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CategoryRes) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CategoryRes.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CategoryRes) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CategoryRes.Merge(m, src)
}
func (m *CategoryRes) XXX_Size() int {
	return m.Size()
}
func (m *CategoryRes) XXX_DiscardUnknown() {
	xxx_messageInfo_CategoryRes.DiscardUnknown(m)
}

var xxx_messageInfo_CategoryRes proto.InternalMessageInfo

func (m *CategoryRes) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *CategoryRes) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *CategoryRes) GetCreatedAt() string {
	if m != nil {
		return m.CreatedAt
	}
	return ""
}

func (m *CategoryRes) GetUpdatedAt() string {
	if m != nil {
		return m.UpdatedAt
	}
	return ""
}

type CategoryId struct {
	Id                   string   `protobuf:"bytes,1,opt,name=id,proto3" json:"id"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CategoryId) Reset()         { *m = CategoryId{} }
func (m *CategoryId) String() string { return proto.CompactTextString(m) }
func (*CategoryId) ProtoMessage()    {}
func (*CategoryId) Descriptor() ([]byte, []int) {
	return fileDescriptor_328b0473e092dc8d, []int{9}
}
func (m *CategoryId) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CategoryId) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CategoryId.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CategoryId) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CategoryId.Merge(m, src)
}
func (m *CategoryId) XXX_Size() int {
	return m.Size()
}
func (m *CategoryId) XXX_DiscardUnknown() {
	xxx_messageInfo_CategoryId.DiscardUnknown(m)
}

var xxx_messageInfo_CategoryId proto.InternalMessageInfo

func (m *CategoryId) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

type CategoryGetReq struct {
	Field                string   `protobuf:"bytes,1,opt,name=field,proto3" json:"field"`
	Value                string   `protobuf:"bytes,2,opt,name=value,proto3" json:"value"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CategoryGetReq) Reset()         { *m = CategoryGetReq{} }
func (m *CategoryGetReq) String() string { return proto.CompactTextString(m) }
func (*CategoryGetReq) ProtoMessage()    {}
func (*CategoryGetReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_328b0473e092dc8d, []int{10}
}
func (m *CategoryGetReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CategoryGetReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CategoryGetReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CategoryGetReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CategoryGetReq.Merge(m, src)
}
func (m *CategoryGetReq) XXX_Size() int {
	return m.Size()
}
func (m *CategoryGetReq) XXX_DiscardUnknown() {
	xxx_messageInfo_CategoryGetReq.DiscardUnknown(m)
}

var xxx_messageInfo_CategoryGetReq proto.InternalMessageInfo

func (m *CategoryGetReq) GetField() string {
	if m != nil {
		return m.Field
	}
	return ""
}

func (m *CategoryGetReq) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

type CategoryFindReq struct {
	Limit                int64    `protobuf:"varint,1,opt,name=limit,proto3" json:"limit"`
	Page                 int64    `protobuf:"varint,2,opt,name=page,proto3" json:"page"`
	Search               string   `protobuf:"bytes,3,opt,name=search,proto3" json:"search"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CategoryFindReq) Reset()         { *m = CategoryFindReq{} }
func (m *CategoryFindReq) String() string { return proto.CompactTextString(m) }
func (*CategoryFindReq) ProtoMessage()    {}
func (*CategoryFindReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_328b0473e092dc8d, []int{11}
}
func (m *CategoryFindReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CategoryFindReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CategoryFindReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CategoryFindReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CategoryFindReq.Merge(m, src)
}
func (m *CategoryFindReq) XXX_Size() int {
	return m.Size()
}
func (m *CategoryFindReq) XXX_DiscardUnknown() {
	xxx_messageInfo_CategoryFindReq.DiscardUnknown(m)
}

var xxx_messageInfo_CategoryFindReq proto.InternalMessageInfo

func (m *CategoryFindReq) GetLimit() int64 {
	if m != nil {
		return m.Limit
	}
	return 0
}

func (m *CategoryFindReq) GetPage() int64 {
	if m != nil {
		return m.Page
	}
	return 0
}

func (m *CategoryFindReq) GetSearch() string {
	if m != nil {
		return m.Search
	}
	return ""
}

type CategoriesRes struct {
	Info                 []*CategoryRes `protobuf:"bytes,1,rep,name=info,proto3" json:"info"`
	Count                int64          `protobuf:"varint,2,opt,name=count,proto3" json:"count"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *CategoriesRes) Reset()         { *m = CategoriesRes{} }
func (m *CategoriesRes) String() string { return proto.CompactTextString(m) }
func (*CategoriesRes) ProtoMessage()    {}
func (*CategoriesRes) Descriptor() ([]byte, []int) {
	return fileDescriptor_328b0473e092dc8d, []int{12}
}
func (m *CategoriesRes) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CategoriesRes) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CategoriesRes.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CategoriesRes) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CategoriesRes.Merge(m, src)
}
func (m *CategoriesRes) XXX_Size() int {
	return m.Size()
}
func (m *CategoriesRes) XXX_DiscardUnknown() {
	xxx_messageInfo_CategoriesRes.DiscardUnknown(m)
}

var xxx_messageInfo_CategoriesRes proto.InternalMessageInfo

func (m *CategoriesRes) GetInfo() []*CategoryRes {
	if m != nil {
		return m.Info
	}
	return nil
}

func (m *CategoriesRes) GetCount() int64 {
	if m != nil {
		return m.Count
	}
	return 0
}

type AparatCreateReq struct {
	Id                   string   `protobuf:"bytes,1,opt,name=id,proto3" json:"id"`
	Name                 string   `protobuf:"bytes,2,opt,name=name,proto3" json:"name"`
	Price                float64  `protobuf:"fixed64,3,opt,name=price,proto3" json:"price"`
	Type                 string   `protobuf:"bytes,4,opt,name=type,proto3" json:"type"`
	SubCategoryId        string   `protobuf:"bytes,5,opt,name=sub_category_id,json=subCategoryId,proto3" json:"sub_category_id"`
	DoctorId             string   `protobuf:"bytes,6,opt,name=doctor_id,json=doctorId,proto3" json:"doctor_id"`
	RoomNumber           string   `protobuf:"bytes,7,opt,name=room_number,json=roomNumber,proto3" json:"room_number"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AparatCreateReq) Reset()         { *m = AparatCreateReq{} }
func (m *AparatCreateReq) String() string { return proto.CompactTextString(m) }
func (*AparatCreateReq) ProtoMessage()    {}
func (*AparatCreateReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_328b0473e092dc8d, []int{13}
}
func (m *AparatCreateReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AparatCreateReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AparatCreateReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AparatCreateReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AparatCreateReq.Merge(m, src)
}
func (m *AparatCreateReq) XXX_Size() int {
	return m.Size()
}
func (m *AparatCreateReq) XXX_DiscardUnknown() {
	xxx_messageInfo_AparatCreateReq.DiscardUnknown(m)
}

var xxx_messageInfo_AparatCreateReq proto.InternalMessageInfo

func (m *AparatCreateReq) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *AparatCreateReq) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *AparatCreateReq) GetPrice() float64 {
	if m != nil {
		return m.Price
	}
	return 0
}

func (m *AparatCreateReq) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *AparatCreateReq) GetSubCategoryId() string {
	if m != nil {
		return m.SubCategoryId
	}
	return ""
}

func (m *AparatCreateReq) GetDoctorId() string {
	if m != nil {
		return m.DoctorId
	}
	return ""
}

func (m *AparatCreateReq) GetRoomNumber() string {
	if m != nil {
		return m.RoomNumber
	}
	return ""
}

type AparatCreateRes struct {
	Id                   string   `protobuf:"bytes,1,opt,name=id,proto3" json:"id"`
	Name                 string   `protobuf:"bytes,2,opt,name=name,proto3" json:"name"`
	Price                float64  `protobuf:"fixed64,3,opt,name=price,proto3" json:"price"`
	Type                 string   `protobuf:"bytes,4,opt,name=type,proto3" json:"type"`
	SubCategoryId        string   `protobuf:"bytes,5,opt,name=sub_category_id,json=subCategoryId,proto3" json:"sub_category_id"`
	DoctorId             string   `protobuf:"bytes,6,opt,name=doctor_id,json=doctorId,proto3" json:"doctor_id"`
	RoomNumber           string   `protobuf:"bytes,7,opt,name=room_number,json=roomNumber,proto3" json:"room_number"`
	CreatedAt            string   `protobuf:"bytes,8,opt,name=created_at,json=createdAt,proto3" json:"created_at"`
	UpdatedAt            string   `protobuf:"bytes,9,opt,name=updated_at,json=updatedAt,proto3" json:"updated_at"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AparatCreateRes) Reset()         { *m = AparatCreateRes{} }
func (m *AparatCreateRes) String() string { return proto.CompactTextString(m) }
func (*AparatCreateRes) ProtoMessage()    {}
func (*AparatCreateRes) Descriptor() ([]byte, []int) {
	return fileDescriptor_328b0473e092dc8d, []int{14}
}
func (m *AparatCreateRes) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AparatCreateRes) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AparatCreateRes.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AparatCreateRes) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AparatCreateRes.Merge(m, src)
}
func (m *AparatCreateRes) XXX_Size() int {
	return m.Size()
}
func (m *AparatCreateRes) XXX_DiscardUnknown() {
	xxx_messageInfo_AparatCreateRes.DiscardUnknown(m)
}

var xxx_messageInfo_AparatCreateRes proto.InternalMessageInfo

func (m *AparatCreateRes) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *AparatCreateRes) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *AparatCreateRes) GetPrice() float64 {
	if m != nil {
		return m.Price
	}
	return 0
}

func (m *AparatCreateRes) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *AparatCreateRes) GetSubCategoryId() string {
	if m != nil {
		return m.SubCategoryId
	}
	return ""
}

func (m *AparatCreateRes) GetDoctorId() string {
	if m != nil {
		return m.DoctorId
	}
	return ""
}

func (m *AparatCreateRes) GetRoomNumber() string {
	if m != nil {
		return m.RoomNumber
	}
	return ""
}

func (m *AparatCreateRes) GetCreatedAt() string {
	if m != nil {
		return m.CreatedAt
	}
	return ""
}

func (m *AparatCreateRes) GetUpdatedAt() string {
	if m != nil {
		return m.UpdatedAt
	}
	return ""
}

type AparatGetReq struct {
	Field                string   `protobuf:"bytes,1,opt,name=field,proto3" json:"field"`
	Value                string   `protobuf:"bytes,2,opt,name=value,proto3" json:"value"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AparatGetReq) Reset()         { *m = AparatGetReq{} }
func (m *AparatGetReq) String() string { return proto.CompactTextString(m) }
func (*AparatGetReq) ProtoMessage()    {}
func (*AparatGetReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_328b0473e092dc8d, []int{15}
}
func (m *AparatGetReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AparatGetReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AparatGetReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AparatGetReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AparatGetReq.Merge(m, src)
}
func (m *AparatGetReq) XXX_Size() int {
	return m.Size()
}
func (m *AparatGetReq) XXX_DiscardUnknown() {
	xxx_messageInfo_AparatGetReq.DiscardUnknown(m)
}

var xxx_messageInfo_AparatGetReq proto.InternalMessageInfo

func (m *AparatGetReq) GetField() string {
	if m != nil {
		return m.Field
	}
	return ""
}

func (m *AparatGetReq) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

type AparatsFindReq struct {
	Limit                int64    `protobuf:"varint,1,opt,name=limit,proto3" json:"limit"`
	Page                 int64    `protobuf:"varint,2,opt,name=page,proto3" json:"page"`
	Search               string   `protobuf:"bytes,3,opt,name=search,proto3" json:"search"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AparatsFindReq) Reset()         { *m = AparatsFindReq{} }
func (m *AparatsFindReq) String() string { return proto.CompactTextString(m) }
func (*AparatsFindReq) ProtoMessage()    {}
func (*AparatsFindReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_328b0473e092dc8d, []int{16}
}
func (m *AparatsFindReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AparatsFindReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AparatsFindReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AparatsFindReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AparatsFindReq.Merge(m, src)
}
func (m *AparatsFindReq) XXX_Size() int {
	return m.Size()
}
func (m *AparatsFindReq) XXX_DiscardUnknown() {
	xxx_messageInfo_AparatsFindReq.DiscardUnknown(m)
}

var xxx_messageInfo_AparatsFindReq proto.InternalMessageInfo

func (m *AparatsFindReq) GetLimit() int64 {
	if m != nil {
		return m.Limit
	}
	return 0
}

func (m *AparatsFindReq) GetPage() int64 {
	if m != nil {
		return m.Page
	}
	return 0
}

func (m *AparatsFindReq) GetSearch() string {
	if m != nil {
		return m.Search
	}
	return ""
}

type AparatsRes struct {
	Aparats              []*AparatCreateRes `protobuf:"bytes,1,rep,name=aparats,proto3" json:"aparats"`
	Count                int64              `protobuf:"varint,2,opt,name=count,proto3" json:"count"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *AparatsRes) Reset()         { *m = AparatsRes{} }
func (m *AparatsRes) String() string { return proto.CompactTextString(m) }
func (*AparatsRes) ProtoMessage()    {}
func (*AparatsRes) Descriptor() ([]byte, []int) {
	return fileDescriptor_328b0473e092dc8d, []int{17}
}
func (m *AparatsRes) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AparatsRes) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AparatsRes.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AparatsRes) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AparatsRes.Merge(m, src)
}
func (m *AparatsRes) XXX_Size() int {
	return m.Size()
}
func (m *AparatsRes) XXX_DiscardUnknown() {
	xxx_messageInfo_AparatsRes.DiscardUnknown(m)
}

var xxx_messageInfo_AparatsRes proto.InternalMessageInfo

func (m *AparatsRes) GetAparats() []*AparatCreateRes {
	if m != nil {
		return m.Aparats
	}
	return nil
}

func (m *AparatsRes) GetCount() int64 {
	if m != nil {
		return m.Count
	}
	return 0
}

type AparatUpdateReq struct {
	Id                   string   `protobuf:"bytes,1,opt,name=id,proto3" json:"id"`
	Name                 string   `protobuf:"bytes,2,opt,name=name,proto3" json:"name"`
	Price                float64  `protobuf:"fixed64,3,opt,name=price,proto3" json:"price"`
	Type                 string   `protobuf:"bytes,4,opt,name=type,proto3" json:"type"`
	DoctorId             string   `protobuf:"bytes,5,opt,name=doctor_id,json=doctorId,proto3" json:"doctor_id"`
	RoomNumber           string   `protobuf:"bytes,6,opt,name=room_number,json=roomNumber,proto3" json:"room_number"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AparatUpdateReq) Reset()         { *m = AparatUpdateReq{} }
func (m *AparatUpdateReq) String() string { return proto.CompactTextString(m) }
func (*AparatUpdateReq) ProtoMessage()    {}
func (*AparatUpdateReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_328b0473e092dc8d, []int{18}
}
func (m *AparatUpdateReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AparatUpdateReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AparatUpdateReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AparatUpdateReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AparatUpdateReq.Merge(m, src)
}
func (m *AparatUpdateReq) XXX_Size() int {
	return m.Size()
}
func (m *AparatUpdateReq) XXX_DiscardUnknown() {
	xxx_messageInfo_AparatUpdateReq.DiscardUnknown(m)
}

var xxx_messageInfo_AparatUpdateReq proto.InternalMessageInfo

func (m *AparatUpdateReq) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *AparatUpdateReq) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *AparatUpdateReq) GetPrice() float64 {
	if m != nil {
		return m.Price
	}
	return 0
}

func (m *AparatUpdateReq) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *AparatUpdateReq) GetDoctorId() string {
	if m != nil {
		return m.DoctorId
	}
	return ""
}

func (m *AparatUpdateReq) GetRoomNumber() string {
	if m != nil {
		return m.RoomNumber
	}
	return ""
}

type AparatId struct {
	Id                   string   `protobuf:"bytes,1,opt,name=id,proto3" json:"id"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AparatId) Reset()         { *m = AparatId{} }
func (m *AparatId) String() string { return proto.CompactTextString(m) }
func (*AparatId) ProtoMessage()    {}
func (*AparatId) Descriptor() ([]byte, []int) {
	return fileDescriptor_328b0473e092dc8d, []int{19}
}
func (m *AparatId) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AparatId) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AparatId.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AparatId) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AparatId.Merge(m, src)
}
func (m *AparatId) XXX_Size() int {
	return m.Size()
}
func (m *AparatId) XXX_DiscardUnknown() {
	xxx_messageInfo_AparatId.DiscardUnknown(m)
}

var xxx_messageInfo_AparatId proto.InternalMessageInfo

func (m *AparatId) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

type LabId struct {
	Id                   string   `protobuf:"bytes,1,opt,name=id,proto3" json:"id"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LabId) Reset()         { *m = LabId{} }
func (m *LabId) String() string { return proto.CompactTextString(m) }
func (*LabId) ProtoMessage()    {}
func (*LabId) Descriptor() ([]byte, []int) {
	return fileDescriptor_328b0473e092dc8d, []int{20}
}
func (m *LabId) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LabId) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LabId.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LabId) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LabId.Merge(m, src)
}
func (m *LabId) XXX_Size() int {
	return m.Size()
}
func (m *LabId) XXX_DiscardUnknown() {
	xxx_messageInfo_LabId.DiscardUnknown(m)
}

var xxx_messageInfo_LabId proto.InternalMessageInfo

func (m *LabId) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

type LabUpdateReq struct {
	Id                   string   `protobuf:"bytes,1,opt,name=id,proto3" json:"id"`
	Name                 string   `protobuf:"bytes,2,opt,name=name,proto3" json:"name"`
	Price                float64  `protobuf:"fixed64,3,opt,name=price,proto3" json:"price"`
	Type                 string   `protobuf:"bytes,4,opt,name=type,proto3" json:"type"`
	DoctorId             string   `protobuf:"bytes,5,opt,name=doctor_id,json=doctorId,proto3" json:"doctor_id"`
	RoomNumber           string   `protobuf:"bytes,6,opt,name=room_number,json=roomNumber,proto3" json:"room_number"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LabUpdateReq) Reset()         { *m = LabUpdateReq{} }
func (m *LabUpdateReq) String() string { return proto.CompactTextString(m) }
func (*LabUpdateReq) ProtoMessage()    {}
func (*LabUpdateReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_328b0473e092dc8d, []int{21}
}
func (m *LabUpdateReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LabUpdateReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LabUpdateReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LabUpdateReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LabUpdateReq.Merge(m, src)
}
func (m *LabUpdateReq) XXX_Size() int {
	return m.Size()
}
func (m *LabUpdateReq) XXX_DiscardUnknown() {
	xxx_messageInfo_LabUpdateReq.DiscardUnknown(m)
}

var xxx_messageInfo_LabUpdateReq proto.InternalMessageInfo

func (m *LabUpdateReq) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *LabUpdateReq) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *LabUpdateReq) GetPrice() float64 {
	if m != nil {
		return m.Price
	}
	return 0
}

func (m *LabUpdateReq) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *LabUpdateReq) GetDoctorId() string {
	if m != nil {
		return m.DoctorId
	}
	return ""
}

func (m *LabUpdateReq) GetRoomNumber() string {
	if m != nil {
		return m.RoomNumber
	}
	return ""
}

type LabsRes struct {
	Labs                 []*LabCreateRes `protobuf:"bytes,1,rep,name=labs,proto3" json:"labs"`
	Count                int64           `protobuf:"varint,2,opt,name=count,proto3" json:"count"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *LabsRes) Reset()         { *m = LabsRes{} }
func (m *LabsRes) String() string { return proto.CompactTextString(m) }
func (*LabsRes) ProtoMessage()    {}
func (*LabsRes) Descriptor() ([]byte, []int) {
	return fileDescriptor_328b0473e092dc8d, []int{22}
}
func (m *LabsRes) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LabsRes) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LabsRes.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LabsRes) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LabsRes.Merge(m, src)
}
func (m *LabsRes) XXX_Size() int {
	return m.Size()
}
func (m *LabsRes) XXX_DiscardUnknown() {
	xxx_messageInfo_LabsRes.DiscardUnknown(m)
}

var xxx_messageInfo_LabsRes proto.InternalMessageInfo

func (m *LabsRes) GetLabs() []*LabCreateRes {
	if m != nil {
		return m.Labs
	}
	return nil
}

func (m *LabsRes) GetCount() int64 {
	if m != nil {
		return m.Count
	}
	return 0
}

type LabsFindReq struct {
	Limit                int64    `protobuf:"varint,1,opt,name=limit,proto3" json:"limit"`
	Page                 int64    `protobuf:"varint,2,opt,name=page,proto3" json:"page"`
	Search               string   `protobuf:"bytes,3,opt,name=search,proto3" json:"search"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LabsFindReq) Reset()         { *m = LabsFindReq{} }
func (m *LabsFindReq) String() string { return proto.CompactTextString(m) }
func (*LabsFindReq) ProtoMessage()    {}
func (*LabsFindReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_328b0473e092dc8d, []int{23}
}
func (m *LabsFindReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LabsFindReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LabsFindReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LabsFindReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LabsFindReq.Merge(m, src)
}
func (m *LabsFindReq) XXX_Size() int {
	return m.Size()
}
func (m *LabsFindReq) XXX_DiscardUnknown() {
	xxx_messageInfo_LabsFindReq.DiscardUnknown(m)
}

var xxx_messageInfo_LabsFindReq proto.InternalMessageInfo

func (m *LabsFindReq) GetLimit() int64 {
	if m != nil {
		return m.Limit
	}
	return 0
}

func (m *LabsFindReq) GetPage() int64 {
	if m != nil {
		return m.Page
	}
	return 0
}

func (m *LabsFindReq) GetSearch() string {
	if m != nil {
		return m.Search
	}
	return ""
}

type LabGetReq struct {
	Field                string   `protobuf:"bytes,1,opt,name=field,proto3" json:"field"`
	Value                string   `protobuf:"bytes,2,opt,name=value,proto3" json:"value"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LabGetReq) Reset()         { *m = LabGetReq{} }
func (m *LabGetReq) String() string { return proto.CompactTextString(m) }
func (*LabGetReq) ProtoMessage()    {}
func (*LabGetReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_328b0473e092dc8d, []int{24}
}
func (m *LabGetReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LabGetReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LabGetReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LabGetReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LabGetReq.Merge(m, src)
}
func (m *LabGetReq) XXX_Size() int {
	return m.Size()
}
func (m *LabGetReq) XXX_DiscardUnknown() {
	xxx_messageInfo_LabGetReq.DiscardUnknown(m)
}

var xxx_messageInfo_LabGetReq proto.InternalMessageInfo

func (m *LabGetReq) GetField() string {
	if m != nil {
		return m.Field
	}
	return ""
}

func (m *LabGetReq) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

type LabCreateReq struct {
	Id                   string   `protobuf:"bytes,1,opt,name=id,proto3" json:"id"`
	Name                 string   `protobuf:"bytes,2,opt,name=name,proto3" json:"name"`
	Price                float64  `protobuf:"fixed64,3,opt,name=price,proto3" json:"price"`
	Type                 string   `protobuf:"bytes,4,opt,name=type,proto3" json:"type"`
	SubCategoryId        string   `protobuf:"bytes,5,opt,name=sub_category_id,json=subCategoryId,proto3" json:"sub_category_id"`
	DoctorId             string   `protobuf:"bytes,6,opt,name=doctor_id,json=doctorId,proto3" json:"doctor_id"`
	RoomNumber           string   `protobuf:"bytes,7,opt,name=room_number,json=roomNumber,proto3" json:"room_number"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LabCreateReq) Reset()         { *m = LabCreateReq{} }
func (m *LabCreateReq) String() string { return proto.CompactTextString(m) }
func (*LabCreateReq) ProtoMessage()    {}
func (*LabCreateReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_328b0473e092dc8d, []int{25}
}
func (m *LabCreateReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LabCreateReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LabCreateReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LabCreateReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LabCreateReq.Merge(m, src)
}
func (m *LabCreateReq) XXX_Size() int {
	return m.Size()
}
func (m *LabCreateReq) XXX_DiscardUnknown() {
	xxx_messageInfo_LabCreateReq.DiscardUnknown(m)
}

var xxx_messageInfo_LabCreateReq proto.InternalMessageInfo

func (m *LabCreateReq) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *LabCreateReq) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *LabCreateReq) GetPrice() float64 {
	if m != nil {
		return m.Price
	}
	return 0
}

func (m *LabCreateReq) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *LabCreateReq) GetSubCategoryId() string {
	if m != nil {
		return m.SubCategoryId
	}
	return ""
}

func (m *LabCreateReq) GetDoctorId() string {
	if m != nil {
		return m.DoctorId
	}
	return ""
}

func (m *LabCreateReq) GetRoomNumber() string {
	if m != nil {
		return m.RoomNumber
	}
	return ""
}

type LabCreateRes struct {
	Id                   string   `protobuf:"bytes,1,opt,name=id,proto3" json:"id"`
	Name                 string   `protobuf:"bytes,2,opt,name=name,proto3" json:"name"`
	Price                float64  `protobuf:"fixed64,3,opt,name=price,proto3" json:"price"`
	Type                 string   `protobuf:"bytes,4,opt,name=type,proto3" json:"type"`
	SubCategoryId        string   `protobuf:"bytes,5,opt,name=sub_category_id,json=subCategoryId,proto3" json:"sub_category_id"`
	DoctorId             string   `protobuf:"bytes,6,opt,name=doctor_id,json=doctorId,proto3" json:"doctor_id"`
	RoomNumber           string   `protobuf:"bytes,7,opt,name=room_number,json=roomNumber,proto3" json:"room_number"`
	CreatedAt            string   `protobuf:"bytes,8,opt,name=created_at,json=createdAt,proto3" json:"created_at"`
	UpdatedAt            string   `protobuf:"bytes,9,opt,name=updated_at,json=updatedAt,proto3" json:"updated_at"`
	DeletedAt            string   `protobuf:"bytes,10,opt,name=deleted_at,json=deletedAt,proto3" json:"deleted_at"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LabCreateRes) Reset()         { *m = LabCreateRes{} }
func (m *LabCreateRes) String() string { return proto.CompactTextString(m) }
func (*LabCreateRes) ProtoMessage()    {}
func (*LabCreateRes) Descriptor() ([]byte, []int) {
	return fileDescriptor_328b0473e092dc8d, []int{26}
}
func (m *LabCreateRes) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LabCreateRes) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LabCreateRes.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LabCreateRes) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LabCreateRes.Merge(m, src)
}
func (m *LabCreateRes) XXX_Size() int {
	return m.Size()
}
func (m *LabCreateRes) XXX_DiscardUnknown() {
	xxx_messageInfo_LabCreateRes.DiscardUnknown(m)
}

var xxx_messageInfo_LabCreateRes proto.InternalMessageInfo

func (m *LabCreateRes) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *LabCreateRes) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *LabCreateRes) GetPrice() float64 {
	if m != nil {
		return m.Price
	}
	return 0
}

func (m *LabCreateRes) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *LabCreateRes) GetSubCategoryId() string {
	if m != nil {
		return m.SubCategoryId
	}
	return ""
}

func (m *LabCreateRes) GetDoctorId() string {
	if m != nil {
		return m.DoctorId
	}
	return ""
}

func (m *LabCreateRes) GetRoomNumber() string {
	if m != nil {
		return m.RoomNumber
	}
	return ""
}

func (m *LabCreateRes) GetCreatedAt() string {
	if m != nil {
		return m.CreatedAt
	}
	return ""
}

func (m *LabCreateRes) GetUpdatedAt() string {
	if m != nil {
		return m.UpdatedAt
	}
	return ""
}

func (m *LabCreateRes) GetDeletedAt() string {
	if m != nil {
		return m.DeletedAt
	}
	return ""
}

func init() {
	proto.RegisterType((*SubCategoryFindReq)(nil), "lab.SubCategoryFindReq")
	proto.RegisterType((*AnalysisGetReq)(nil), "lab.AnalysisGetReq")
	proto.RegisterType((*AnalysisReq)(nil), "lab.AnalysisReq")
	proto.RegisterType((*AnalysisResp)(nil), "lab.AnalysisResp")
	proto.RegisterType((*SubCategoriesRes)(nil), "lab.SubCategoriesRes")
	proto.RegisterType((*SubCategory)(nil), "lab.SubCategory")
	proto.RegisterType((*SubCategoryRes)(nil), "lab.SubCategoryRes")
	proto.RegisterType((*Category)(nil), "lab.Category")
	proto.RegisterType((*CategoryRes)(nil), "lab.CategoryRes")
	proto.RegisterType((*CategoryId)(nil), "lab.CategoryId")
	proto.RegisterType((*CategoryGetReq)(nil), "lab.CategoryGetReq")
	proto.RegisterType((*CategoryFindReq)(nil), "lab.CategoryFindReq")
	proto.RegisterType((*CategoriesRes)(nil), "lab.CategoriesRes")
	proto.RegisterType((*AparatCreateReq)(nil), "lab.AparatCreateReq")
	proto.RegisterType((*AparatCreateRes)(nil), "lab.AparatCreateRes")
	proto.RegisterType((*AparatGetReq)(nil), "lab.AparatGetReq")
	proto.RegisterType((*AparatsFindReq)(nil), "lab.AparatsFindReq")
	proto.RegisterType((*AparatsRes)(nil), "lab.AparatsRes")
	proto.RegisterType((*AparatUpdateReq)(nil), "lab.AparatUpdateReq")
	proto.RegisterType((*AparatId)(nil), "lab.AparatId")
	proto.RegisterType((*LabId)(nil), "lab.LabId")
	proto.RegisterType((*LabUpdateReq)(nil), "lab.LabUpdateReq")
	proto.RegisterType((*LabsRes)(nil), "lab.LabsRes")
	proto.RegisterType((*LabsFindReq)(nil), "lab.LabsFindReq")
	proto.RegisterType((*LabGetReq)(nil), "lab.LabGetReq")
	proto.RegisterType((*LabCreateReq)(nil), "lab.LabCreateReq")
	proto.RegisterType((*LabCreateRes)(nil), "lab.LabCreateRes")
}

func init() { proto.RegisterFile("lab/lab.proto", fileDescriptor_328b0473e092dc8d) }

var fileDescriptor_328b0473e092dc8d = []byte{
	// 1119 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xe4, 0x58, 0x5b, 0x6f, 0xe3, 0xc4,
	0x17, 0x8f, 0x73, 0x6b, 0x72, 0x72, 0x9f, 0x66, 0xb7, 0x51, 0xf6, 0xff, 0x2f, 0xc5, 0xe2, 0xd2,
	0x07, 0x48, 0xc5, 0xae, 0x58, 0xd8, 0xaa, 0x65, 0x49, 0xbb, 0x14, 0x45, 0x44, 0x20, 0x5c, 0xed,
	0x73, 0x34, 0x8e, 0xa7, 0xc5, 0x92, 0x13, 0xa7, 0xb6, 0xb3, 0x52, 0x79, 0xe5, 0x23, 0xf0, 0x82,
	0x90, 0x10, 0x1f, 0x81, 0x67, 0x5e, 0x91, 0x90, 0x78, 0xe4, 0x23, 0xa0, 0xf2, 0x45, 0xd0, 0xdc,
	0x12, 0x8f, 0xed, 0x84, 0x3a, 0x5b, 0x21, 0x56, 0xbc, 0x79, 0xce, 0x6d, 0xce, 0xf9, 0x9d, 0xdf,
	0x9c, 0xb1, 0x0d, 0x35, 0x07, 0x9b, 0x07, 0x0e, 0x36, 0x7b, 0x33, 0xcf, 0x0d, 0x5c, 0x94, 0x73,
	0xb0, 0xd9, 0x7d, 0x70, 0xe9, 0xba, 0x97, 0x0e, 0x39, 0x60, 0x22, 0x73, 0x7e, 0x71, 0x40, 0x26,
	0xb3, 0xe0, 0x9a, 0x5b, 0xe8, 0x23, 0x40, 0xe7, 0x73, 0xf3, 0x14, 0x07, 0xe4, 0xd2, 0xf5, 0xae,
	0xcf, 0xec, 0xa9, 0x65, 0x90, 0x2b, 0xd4, 0x86, 0x82, 0x63, 0x4f, 0xec, 0xa0, 0xa3, 0xed, 0x69,
	0xfb, 0x39, 0x83, 0x2f, 0x10, 0x82, 0xfc, 0x0c, 0x5f, 0x92, 0x4e, 0x96, 0x09, 0xd9, 0x33, 0x7a,
	0x0d, 0x2a, 0x63, 0xe1, 0x3c, 0xb2, 0xad, 0x4e, 0x6e, 0x4f, 0xdb, 0x2f, 0x1b, 0x20, 0x45, 0x03,
	0x4b, 0x3f, 0x82, 0x7a, 0x7f, 0x8a, 0x9d, 0x6b, 0xdf, 0xf6, 0x3f, 0x25, 0x81, 0x08, 0x7e, 0x61,
	0x13, 0xc7, 0x62, 0xc1, 0xcb, 0x06, 0x5f, 0x50, 0xe9, 0x0b, 0xec, 0xcc, 0x79, 0xf4, 0xb2, 0xc1,
	0x17, 0xfa, 0xd7, 0x50, 0x91, 0xde, 0xd4, 0xb5, 0x0e, 0x59, 0x5b, 0xfa, 0x65, 0x6d, 0x0b, 0x3d,
	0x80, 0xf2, 0xd8, 0xb1, 0xc9, 0x34, 0xa0, 0x7b, 0xf3, 0xb4, 0x4a, 0x5c, 0x30, 0x60, 0x4a, 0x3c,
	0xc3, 0x1e, 0x0e, 0x96, 0x89, 0x95, 0xb8, 0x60, 0x60, 0xa1, 0xd7, 0xa1, 0x8a, 0x45, 0xe0, 0xd1,
	0xdc, 0x73, 0x3a, 0x79, 0xa6, 0xaf, 0x48, 0xd9, 0x73, 0xcf, 0xd1, 0x7f, 0xd6, 0xa0, 0xba, 0xdc,
	0xdc, 0x9f, 0xfd, 0xa3, 0xbb, 0xa3, 0xff, 0x03, 0x8c, 0x3d, 0x82, 0x03, 0x62, 0x8d, 0x70, 0xd0,
	0x29, 0x30, 0x83, 0xb2, 0x90, 0xf4, 0x03, 0xaa, 0x9e, 0xcf, 0x2c, 0xa9, 0x2e, 0x72, 0xb5, 0x90,
	0xf4, 0x03, 0xfd, 0x4b, 0x68, 0x2e, 0xdb, 0x6a, 0x13, 0x9a, 0x3f, 0x7a, 0x1b, 0xf2, 0xf6, 0xf4,
	0xc2, 0xed, 0x68, 0x7b, 0xb9, 0xfd, 0xca, 0xc3, 0xed, 0x1e, 0xa5, 0x49, 0xa8, 0xf7, 0x06, 0xf1,
	0x0d, 0x66, 0x40, 0x5b, 0x31, 0x76, 0xe7, 0xd3, 0x40, 0xd4, 0xc4, 0x17, 0xba, 0x01, 0x95, 0x90,
	0x75, 0x0c, 0x0c, 0x04, 0xf9, 0x29, 0x9e, 0xc8, 0xf6, 0xb1, 0xe7, 0xbf, 0x27, 0xc7, 0xb7, 0x1a,
	0xd4, 0xd5, 0x14, 0xee, 0x24, 0x6e, 0x04, 0xbc, 0xfc, 0x7a, 0xf0, 0x0a, 0x51, 0xf0, 0x7a, 0x50,
	0x4a, 0x53, 0xa6, 0xee, 0x42, 0x25, 0x6d, 0x05, 0x6a, 0x82, 0xb9, 0xf5, 0x09, 0xe6, 0xa3, 0x09,
	0xfe, 0x0f, 0xe0, 0x74, 0x59, 0x6c, 0x64, 0x3f, 0x7a, 0xe2, 0xa4, 0x76, 0x83, 0x13, 0x77, 0x0e,
	0x8d, 0xcd, 0xa7, 0xc1, 0x7d, 0x28, 0xfa, 0x04, 0x7b, 0xe3, 0xaf, 0x44, 0x49, 0x62, 0xa5, 0x7f,
	0x06, 0x35, 0x95, 0x8b, 0x6f, 0x28, 0x5c, 0x6c, 0x32, 0x2e, 0xde, 0x96, 0x88, 0xbf, 0x6a, 0xd0,
	0xe8, 0xb3, 0x93, 0x74, 0xca, 0x00, 0x4b, 0x1a, 0x0c, 0x49, 0x98, 0xb7, 0xa1, 0x30, 0xf3, 0xec,
	0x31, 0x61, 0xb9, 0x69, 0x06, 0x5f, 0x50, 0xcb, 0xe0, 0x7a, 0x46, 0x04, 0xc8, 0xec, 0x19, 0xbd,
	0x05, 0x0d, 0x7f, 0x6e, 0x8e, 0xc2, 0x1c, 0xe3, 0x24, 0xa9, 0xf9, 0x4b, 0xb2, 0xf2, 0x33, 0x6e,
	0xb9, 0xe3, 0xc0, 0xf5, 0xa8, 0x05, 0x3f, 0x83, 0x25, 0x2e, 0x18, 0x58, 0x94, 0xa4, 0x9e, 0xeb,
	0x4e, 0x46, 0xd3, 0xf9, 0xc4, 0x24, 0x5e, 0x67, 0x8b, 0x93, 0x94, 0x8a, 0x3e, 0x67, 0x12, 0xfd,
	0x9b, 0x6c, 0xb4, 0x0e, 0xff, 0x55, 0xac, 0x23, 0xc2, 0xe5, 0xd2, 0x7a, 0x2e, 0x97, 0xa3, 0x5c,
	0x3e, 0x84, 0x2a, 0x07, 0x61, 0x03, 0xae, 0x1a, 0x50, 0xe7, 0xbe, 0xfe, 0xdd, 0x51, 0xd5, 0x00,
	0x10, 0x31, 0x69, 0x3f, 0x7a, 0xb0, 0xc5, 0x87, 0xb6, 0x2f, 0xa8, 0xda, 0x66, 0x54, 0x8d, 0xb4,
	0xcd, 0x90, 0x46, 0x2b, 0x18, 0xfb, 0xc3, 0x82, 0xb1, 0xcf, 0x59, 0xdd, 0x77, 0xcf, 0x58, 0xa5,
	0x83, 0x85, 0xf5, 0x1d, 0x2c, 0xc6, 0x98, 0xd8, 0x85, 0x52, 0x5f, 0x5e, 0x4d, 0xd1, 0x69, 0xb2,
	0x03, 0x85, 0x21, 0x36, 0x13, 0x14, 0xdf, 0x6b, 0x50, 0x1d, 0x62, 0xf3, 0xdf, 0x59, 0xd1, 0x19,
	0x6c, 0x0d, 0xb1, 0xc9, 0x5a, 0xf8, 0x26, 0xe4, 0x1d, 0x6c, 0xca, 0xfe, 0xb5, 0x58, 0xff, 0x86,
	0xd8, 0x5c, 0x36, 0x8f, 0xa9, 0x57, 0x74, 0xee, 0x0b, 0xa8, 0xd0, 0x38, 0x77, 0x47, 0xaf, 0x0f,
	0xa0, 0x3c, 0xc4, 0xe6, 0x06, 0x5c, 0xff, 0x85, 0xc3, 0xfd, 0x6a, 0x8f, 0xbc, 0x1f, 0xb3, 0x4a,
	0x11, 0xff, 0xc1, 0x79, 0x47, 0xd5, 0x16, 0x71, 0x88, 0x50, 0x03, 0x57, 0x0b, 0x49, 0x3f, 0x78,
	0xf8, 0x53, 0x0b, 0x60, 0x88, 0xcd, 0x73, 0xe2, 0xbd, 0xa0, 0x55, 0x3e, 0x62, 0x74, 0xe1, 0x78,
	0xa1, 0x18, 0x77, 0xaf, 0xba, 0x71, 0x3a, 0xeb, 0x19, 0xf4, 0x2e, 0x14, 0x39, 0xc7, 0x50, 0x5d,
	0xaa, 0x39, 0xe1, 0x92, 0xcd, 0xdf, 0x81, 0x92, 0xe4, 0x38, 0x6a, 0x4a, 0x03, 0x49, 0xf9, 0x6e,
	0x75, 0x21, 0xe1, 0xd6, 0x3c, 0x23, 0x7e, 0xea, 0x97, 0x19, 0x2d, 0xa6, 0x40, 0xf2, 0x16, 0xef,
	0x31, 0xa7, 0x67, 0xac, 0x4a, 0x04, 0xd2, 0x62, 0x60, 0x75, 0xef, 0xf7, 0xf8, 0xc7, 0x49, 0x4f,
	0x7e, 0x9c, 0xf4, 0x3e, 0xa1, 0x1f, 0x27, 0x7a, 0x06, 0x1d, 0xc9, 0x7b, 0x41, 0x14, 0x9f, 0x34,
	0x78, 0xaf, 0xba, 0x89, 0xe3, 0x58, 0xcf, 0xa0, 0xc7, 0x50, 0x5e, 0xdc, 0x2a, 0x22, 0xcb, 0xf0,
	0x2d, 0xb3, 0xd2, 0xef, 0x7d, 0xa8, 0x84, 0x6e, 0x14, 0xb4, 0x1d, 0x32, 0x5b, 0x20, 0xd2, 0x08,
	0x0b, 0xb9, 0xdb, 0x31, 0xd4, 0xc4, 0x5a, 0x00, 0x13, 0x8e, 0xbf, 0xc4, 0x66, 0xd5, 0xae, 0x1f,
	0x2e, 0xdc, 0x05, 0x44, 0xb5, 0x90, 0xe1, 0x5a, 0x94, 0x1e, 0x43, 0x8b, 0x42, 0x2d, 0xa8, 0x2d,
	0xa0, 0xaa, 0x29, 0xaf, 0x53, 0xdd, 0xd8, 0xdb, 0x95, 0x9e, 0x41, 0x4f, 0xa0, 0x1e, 0xf2, 0xa3,
	0x20, 0x6d, 0x2b, 0x56, 0x02, 0xa6, 0x24, 0xd7, 0x63, 0x68, 0x84, 0x5c, 0x19, 0x4c, 0x6d, 0xc5,
	0x4c, 0xe2, 0x84, 0xc2, 0x52, 0xfe, 0xde, 0x17, 0xcb, 0x58, 0xc0, 0x75, 0x8b, 0x8c, 0x3f, 0x52,
	0xfc, 0x04, 0x4e, 0x0d, 0xc5, 0x70, 0x2d, 0x52, 0x4f, 0xa0, 0x2d, 0x80, 0x4f, 0x0d, 0xd6, 0x11,
	0xb4, 0x54, 0xd7, 0x54, 0x78, 0x7d, 0x0c, 0x48, 0xf5, 0x4e, 0x0d, 0x59, 0x2c, 0xf5, 0xdb, 0xa3,
	0xd6, 0x8f, 0xba, 0xa6, 0x07, 0xee, 0x29, 0xb4, 0xe9, 0x40, 0x9a, 0x47, 0x59, 0xd6, 0x8c, 0x7e,
	0x40, 0x76, 0x93, 0x3e, 0x29, 0x59, 0x80, 0x96, 0x1a, 0x60, 0x25, 0x7c, 0x2b, 0x02, 0x9c, 0x01,
	0x52, 0x03, 0x30, 0x04, 0x77, 0xa2, 0xc6, 0x12, 0xc4, 0x7b, 0x11, 0xc5, 0x02, 0xc7, 0x58, 0x25,
	0x02, 0xc7, 0x5b, 0x57, 0xd2, 0x8f, 0x06, 0x48, 0x8f, 0xe6, 0x09, 0xec, 0xf0, 0x86, 0xbc, 0x04,
	0xa0, 0x27, 0xb2, 0xa9, 0x2f, 0x81, 0xe9, 0x00, 0xee, 0xc5, 0x62, 0x6c, 0x08, 0x6b, 0x52, 0x49,
	0x69, 0x91, 0x7d, 0x96, 0x10, 0x23, 0x3d, 0xb8, 0xc7, 0x12, 0x18, 0xf9, 0xdb, 0x46, 0x41, 0x36,
	0xf4, 0x23, 0x49, 0xdc, 0x52, 0xe1, 0xbf, 0x3b, 0xcc, 0xbd, 0xa5, 0xba, 0x2f, 0x41, 0x55, 0x7f,
	0x61, 0x25, 0xbb, 0x3f, 0x8d, 0xee, 0x9e, 0x76, 0x98, 0x1f, 0xb2, 0x83, 0xb2, 0x59, 0xee, 0x87,
	0x6c, 0xa0, 0x6f, 0x96, 0xf8, 0x91, 0xb2, 0x6f, 0xca, 0xac, 0x4f, 0x9a, 0xbf, 0xdd, 0xec, 0x6a,
	0xbf, 0xdf, 0xec, 0x6a, 0x7f, 0xdc, 0xec, 0x6a, 0xdf, 0xfd, 0xb9, 0x9b, 0x31, 0x8b, 0xcc, 0xe6,
	0xd1, 0x5f, 0x01, 0x00, 0x00, 0xff, 0xff, 0x22, 0x54, 0xc4, 0xc9, 0x8d, 0x14, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// LabServiceClient is the client API for LabService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type LabServiceClient interface {
	// Lab
	LabCreate(ctx context.Context, in *LabCreateReq, opts ...grpc.CallOption) (*LabCreateRes, error)
	LabGet(ctx context.Context, in *LabGetReq, opts ...grpc.CallOption) (*LabCreateRes, error)
	LabsFind(ctx context.Context, in *LabsFindReq, opts ...grpc.CallOption) (*LabsRes, error)
	LabUpdate(ctx context.Context, in *LabUpdateReq, opts ...grpc.CallOption) (*LabCreateRes, error)
	LabDelete(ctx context.Context, in *LabId, opts ...grpc.CallOption) (*empty.Empty, error)
	// Aparat
	AparatCreate(ctx context.Context, in *AparatCreateReq, opts ...grpc.CallOption) (*AparatCreateRes, error)
	AparatGet(ctx context.Context, in *AparatGetReq, opts ...grpc.CallOption) (*AparatCreateRes, error)
	AparatsFind(ctx context.Context, in *AparatsFindReq, opts ...grpc.CallOption) (*AparatsRes, error)
	AparatsUpdate(ctx context.Context, in *AparatUpdateReq, opts ...grpc.CallOption) (*AparatCreateRes, error)
	AparatsDelete(ctx context.Context, in *AparatId, opts ...grpc.CallOption) (*empty.Empty, error)
	// Lab categoty
	LabCategoryCreate(ctx context.Context, in *Category, opts ...grpc.CallOption) (*CategoryRes, error)
	LabCategoryGet(ctx context.Context, in *CategoryGetReq, opts ...grpc.CallOption) (*CategoryRes, error)
	LabCategoryFind(ctx context.Context, in *CategoryFindReq, opts ...grpc.CallOption) (*CategoriesRes, error)
	LabCategoryUpdate(ctx context.Context, in *Category, opts ...grpc.CallOption) (*CategoryRes, error)
	LabCategoryDelete(ctx context.Context, in *CategoryId, opts ...grpc.CallOption) (*empty.Empty, error)
	// Aparat category
	AparatCategoryCreate(ctx context.Context, in *Category, opts ...grpc.CallOption) (*CategoryRes, error)
	AparatCategoryGet(ctx context.Context, in *CategoryGetReq, opts ...grpc.CallOption) (*CategoryRes, error)
	AparatCategoryFind(ctx context.Context, in *CategoryFindReq, opts ...grpc.CallOption) (*CategoriesRes, error)
	AparatCategoryUpdate(ctx context.Context, in *Category, opts ...grpc.CallOption) (*CategoryRes, error)
	AparatCategoryDelete(ctx context.Context, in *CategoryId, opts ...grpc.CallOption) (*empty.Empty, error)
	// Lab sub category
	LabSubCategoryCreate(ctx context.Context, in *SubCategory, opts ...grpc.CallOption) (*SubCategoryRes, error)
	LabSubCategoryGet(ctx context.Context, in *CategoryGetReq, opts ...grpc.CallOption) (*SubCategoryRes, error)
	LabSubCategoryFind(ctx context.Context, in *SubCategoryFindReq, opts ...grpc.CallOption) (*SubCategoriesRes, error)
	LabSubCategoryUpdate(ctx context.Context, in *SubCategory, opts ...grpc.CallOption) (*SubCategoryRes, error)
	LabSubCategoryDelete(ctx context.Context, in *CategoryId, opts ...grpc.CallOption) (*empty.Empty, error)
	// Aparat sub category
	AparatSubCategoryCreate(ctx context.Context, in *SubCategory, opts ...grpc.CallOption) (*SubCategoryRes, error)
	AparatSubCategoryGet(ctx context.Context, in *CategoryGetReq, opts ...grpc.CallOption) (*SubCategoryRes, error)
	AparatSubCategoryFind(ctx context.Context, in *SubCategoryFindReq, opts ...grpc.CallOption) (*SubCategoriesRes, error)
	AparatSubCategoryUpdate(ctx context.Context, in *SubCategory, opts ...grpc.CallOption) (*SubCategoryRes, error)
	AparatSubCategoryDelete(ctx context.Context, in *CategoryId, opts ...grpc.CallOption) (*empty.Empty, error)
	// Aparat analysis
	AparatAnalysisCreate(ctx context.Context, in *AnalysisReq, opts ...grpc.CallOption) (*AnalysisResp, error)
	AparatAnalysisGet(ctx context.Context, in *AnalysisGetReq, opts ...grpc.CallOption) (*AnalysisResp, error)
	AparatAnalysisDelete(ctx context.Context, in *AparatId, opts ...grpc.CallOption) (*empty.Empty, error)
	// Lab analysis
	LabAnalysisCreate(ctx context.Context, in *AnalysisReq, opts ...grpc.CallOption) (*AnalysisResp, error)
	LabAnalysisGet(ctx context.Context, in *AnalysisGetReq, opts ...grpc.CallOption) (*AnalysisResp, error)
	LabAnalysisDelete(ctx context.Context, in *AparatId, opts ...grpc.CallOption) (*empty.Empty, error)
}

type labServiceClient struct {
	cc *grpc.ClientConn
}

func NewLabServiceClient(cc *grpc.ClientConn) LabServiceClient {
	return &labServiceClient{cc}
}

func (c *labServiceClient) LabCreate(ctx context.Context, in *LabCreateReq, opts ...grpc.CallOption) (*LabCreateRes, error) {
	out := new(LabCreateRes)
	err := c.cc.Invoke(ctx, "/lab.LabService/LabCreate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *labServiceClient) LabGet(ctx context.Context, in *LabGetReq, opts ...grpc.CallOption) (*LabCreateRes, error) {
	out := new(LabCreateRes)
	err := c.cc.Invoke(ctx, "/lab.LabService/LabGet", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *labServiceClient) LabsFind(ctx context.Context, in *LabsFindReq, opts ...grpc.CallOption) (*LabsRes, error) {
	out := new(LabsRes)
	err := c.cc.Invoke(ctx, "/lab.LabService/LabsFind", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *labServiceClient) LabUpdate(ctx context.Context, in *LabUpdateReq, opts ...grpc.CallOption) (*LabCreateRes, error) {
	out := new(LabCreateRes)
	err := c.cc.Invoke(ctx, "/lab.LabService/LabUpdate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *labServiceClient) LabDelete(ctx context.Context, in *LabId, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/lab.LabService/LabDelete", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *labServiceClient) AparatCreate(ctx context.Context, in *AparatCreateReq, opts ...grpc.CallOption) (*AparatCreateRes, error) {
	out := new(AparatCreateRes)
	err := c.cc.Invoke(ctx, "/lab.LabService/AparatCreate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *labServiceClient) AparatGet(ctx context.Context, in *AparatGetReq, opts ...grpc.CallOption) (*AparatCreateRes, error) {
	out := new(AparatCreateRes)
	err := c.cc.Invoke(ctx, "/lab.LabService/AparatGet", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *labServiceClient) AparatsFind(ctx context.Context, in *AparatsFindReq, opts ...grpc.CallOption) (*AparatsRes, error) {
	out := new(AparatsRes)
	err := c.cc.Invoke(ctx, "/lab.LabService/AparatsFind", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *labServiceClient) AparatsUpdate(ctx context.Context, in *AparatUpdateReq, opts ...grpc.CallOption) (*AparatCreateRes, error) {
	out := new(AparatCreateRes)
	err := c.cc.Invoke(ctx, "/lab.LabService/AparatsUpdate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *labServiceClient) AparatsDelete(ctx context.Context, in *AparatId, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/lab.LabService/AparatsDelete", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *labServiceClient) LabCategoryCreate(ctx context.Context, in *Category, opts ...grpc.CallOption) (*CategoryRes, error) {
	out := new(CategoryRes)
	err := c.cc.Invoke(ctx, "/lab.LabService/LabCategoryCreate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *labServiceClient) LabCategoryGet(ctx context.Context, in *CategoryGetReq, opts ...grpc.CallOption) (*CategoryRes, error) {
	out := new(CategoryRes)
	err := c.cc.Invoke(ctx, "/lab.LabService/LabCategoryGet", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *labServiceClient) LabCategoryFind(ctx context.Context, in *CategoryFindReq, opts ...grpc.CallOption) (*CategoriesRes, error) {
	out := new(CategoriesRes)
	err := c.cc.Invoke(ctx, "/lab.LabService/LabCategoryFind", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *labServiceClient) LabCategoryUpdate(ctx context.Context, in *Category, opts ...grpc.CallOption) (*CategoryRes, error) {
	out := new(CategoryRes)
	err := c.cc.Invoke(ctx, "/lab.LabService/LabCategoryUpdate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *labServiceClient) LabCategoryDelete(ctx context.Context, in *CategoryId, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/lab.LabService/LabCategoryDelete", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *labServiceClient) AparatCategoryCreate(ctx context.Context, in *Category, opts ...grpc.CallOption) (*CategoryRes, error) {
	out := new(CategoryRes)
	err := c.cc.Invoke(ctx, "/lab.LabService/AparatCategoryCreate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *labServiceClient) AparatCategoryGet(ctx context.Context, in *CategoryGetReq, opts ...grpc.CallOption) (*CategoryRes, error) {
	out := new(CategoryRes)
	err := c.cc.Invoke(ctx, "/lab.LabService/AparatCategoryGet", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *labServiceClient) AparatCategoryFind(ctx context.Context, in *CategoryFindReq, opts ...grpc.CallOption) (*CategoriesRes, error) {
	out := new(CategoriesRes)
	err := c.cc.Invoke(ctx, "/lab.LabService/AparatCategoryFind", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *labServiceClient) AparatCategoryUpdate(ctx context.Context, in *Category, opts ...grpc.CallOption) (*CategoryRes, error) {
	out := new(CategoryRes)
	err := c.cc.Invoke(ctx, "/lab.LabService/AparatCategoryUpdate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *labServiceClient) AparatCategoryDelete(ctx context.Context, in *CategoryId, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/lab.LabService/AparatCategoryDelete", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *labServiceClient) LabSubCategoryCreate(ctx context.Context, in *SubCategory, opts ...grpc.CallOption) (*SubCategoryRes, error) {
	out := new(SubCategoryRes)
	err := c.cc.Invoke(ctx, "/lab.LabService/LabSubCategoryCreate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *labServiceClient) LabSubCategoryGet(ctx context.Context, in *CategoryGetReq, opts ...grpc.CallOption) (*SubCategoryRes, error) {
	out := new(SubCategoryRes)
	err := c.cc.Invoke(ctx, "/lab.LabService/LabSubCategoryGet", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *labServiceClient) LabSubCategoryFind(ctx context.Context, in *SubCategoryFindReq, opts ...grpc.CallOption) (*SubCategoriesRes, error) {
	out := new(SubCategoriesRes)
	err := c.cc.Invoke(ctx, "/lab.LabService/LabSubCategoryFind", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *labServiceClient) LabSubCategoryUpdate(ctx context.Context, in *SubCategory, opts ...grpc.CallOption) (*SubCategoryRes, error) {
	out := new(SubCategoryRes)
	err := c.cc.Invoke(ctx, "/lab.LabService/LabSubCategoryUpdate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *labServiceClient) LabSubCategoryDelete(ctx context.Context, in *CategoryId, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/lab.LabService/LabSubCategoryDelete", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *labServiceClient) AparatSubCategoryCreate(ctx context.Context, in *SubCategory, opts ...grpc.CallOption) (*SubCategoryRes, error) {
	out := new(SubCategoryRes)
	err := c.cc.Invoke(ctx, "/lab.LabService/AparatSubCategoryCreate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *labServiceClient) AparatSubCategoryGet(ctx context.Context, in *CategoryGetReq, opts ...grpc.CallOption) (*SubCategoryRes, error) {
	out := new(SubCategoryRes)
	err := c.cc.Invoke(ctx, "/lab.LabService/AparatSubCategoryGet", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *labServiceClient) AparatSubCategoryFind(ctx context.Context, in *SubCategoryFindReq, opts ...grpc.CallOption) (*SubCategoriesRes, error) {
	out := new(SubCategoriesRes)
	err := c.cc.Invoke(ctx, "/lab.LabService/AparatSubCategoryFind", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *labServiceClient) AparatSubCategoryUpdate(ctx context.Context, in *SubCategory, opts ...grpc.CallOption) (*SubCategoryRes, error) {
	out := new(SubCategoryRes)
	err := c.cc.Invoke(ctx, "/lab.LabService/AparatSubCategoryUpdate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *labServiceClient) AparatSubCategoryDelete(ctx context.Context, in *CategoryId, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/lab.LabService/AparatSubCategoryDelete", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *labServiceClient) AparatAnalysisCreate(ctx context.Context, in *AnalysisReq, opts ...grpc.CallOption) (*AnalysisResp, error) {
	out := new(AnalysisResp)
	err := c.cc.Invoke(ctx, "/lab.LabService/AparatAnalysisCreate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *labServiceClient) AparatAnalysisGet(ctx context.Context, in *AnalysisGetReq, opts ...grpc.CallOption) (*AnalysisResp, error) {
	out := new(AnalysisResp)
	err := c.cc.Invoke(ctx, "/lab.LabService/AparatAnalysisGet", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *labServiceClient) AparatAnalysisDelete(ctx context.Context, in *AparatId, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/lab.LabService/AparatAnalysisDelete", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *labServiceClient) LabAnalysisCreate(ctx context.Context, in *AnalysisReq, opts ...grpc.CallOption) (*AnalysisResp, error) {
	out := new(AnalysisResp)
	err := c.cc.Invoke(ctx, "/lab.LabService/LabAnalysisCreate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *labServiceClient) LabAnalysisGet(ctx context.Context, in *AnalysisGetReq, opts ...grpc.CallOption) (*AnalysisResp, error) {
	out := new(AnalysisResp)
	err := c.cc.Invoke(ctx, "/lab.LabService/LabAnalysisGet", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *labServiceClient) LabAnalysisDelete(ctx context.Context, in *AparatId, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/lab.LabService/LabAnalysisDelete", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// LabServiceServer is the server API for LabService service.
type LabServiceServer interface {
	// Lab
	LabCreate(context.Context, *LabCreateReq) (*LabCreateRes, error)
	LabGet(context.Context, *LabGetReq) (*LabCreateRes, error)
	LabsFind(context.Context, *LabsFindReq) (*LabsRes, error)
	LabUpdate(context.Context, *LabUpdateReq) (*LabCreateRes, error)
	LabDelete(context.Context, *LabId) (*empty.Empty, error)
	// Aparat
	AparatCreate(context.Context, *AparatCreateReq) (*AparatCreateRes, error)
	AparatGet(context.Context, *AparatGetReq) (*AparatCreateRes, error)
	AparatsFind(context.Context, *AparatsFindReq) (*AparatsRes, error)
	AparatsUpdate(context.Context, *AparatUpdateReq) (*AparatCreateRes, error)
	AparatsDelete(context.Context, *AparatId) (*empty.Empty, error)
	// Lab categoty
	LabCategoryCreate(context.Context, *Category) (*CategoryRes, error)
	LabCategoryGet(context.Context, *CategoryGetReq) (*CategoryRes, error)
	LabCategoryFind(context.Context, *CategoryFindReq) (*CategoriesRes, error)
	LabCategoryUpdate(context.Context, *Category) (*CategoryRes, error)
	LabCategoryDelete(context.Context, *CategoryId) (*empty.Empty, error)
	// Aparat category
	AparatCategoryCreate(context.Context, *Category) (*CategoryRes, error)
	AparatCategoryGet(context.Context, *CategoryGetReq) (*CategoryRes, error)
	AparatCategoryFind(context.Context, *CategoryFindReq) (*CategoriesRes, error)
	AparatCategoryUpdate(context.Context, *Category) (*CategoryRes, error)
	AparatCategoryDelete(context.Context, *CategoryId) (*empty.Empty, error)
	// Lab sub category
	LabSubCategoryCreate(context.Context, *SubCategory) (*SubCategoryRes, error)
	LabSubCategoryGet(context.Context, *CategoryGetReq) (*SubCategoryRes, error)
	LabSubCategoryFind(context.Context, *SubCategoryFindReq) (*SubCategoriesRes, error)
	LabSubCategoryUpdate(context.Context, *SubCategory) (*SubCategoryRes, error)
	LabSubCategoryDelete(context.Context, *CategoryId) (*empty.Empty, error)
	// Aparat sub category
	AparatSubCategoryCreate(context.Context, *SubCategory) (*SubCategoryRes, error)
	AparatSubCategoryGet(context.Context, *CategoryGetReq) (*SubCategoryRes, error)
	AparatSubCategoryFind(context.Context, *SubCategoryFindReq) (*SubCategoriesRes, error)
	AparatSubCategoryUpdate(context.Context, *SubCategory) (*SubCategoryRes, error)
	AparatSubCategoryDelete(context.Context, *CategoryId) (*empty.Empty, error)
	// Aparat analysis
	AparatAnalysisCreate(context.Context, *AnalysisReq) (*AnalysisResp, error)
	AparatAnalysisGet(context.Context, *AnalysisGetReq) (*AnalysisResp, error)
	AparatAnalysisDelete(context.Context, *AparatId) (*empty.Empty, error)
	// Lab analysis
	LabAnalysisCreate(context.Context, *AnalysisReq) (*AnalysisResp, error)
	LabAnalysisGet(context.Context, *AnalysisGetReq) (*AnalysisResp, error)
	LabAnalysisDelete(context.Context, *AparatId) (*empty.Empty, error)
}

// UnimplementedLabServiceServer can be embedded to have forward compatible implementations.
type UnimplementedLabServiceServer struct {
}

func (*UnimplementedLabServiceServer) LabCreate(ctx context.Context, req *LabCreateReq) (*LabCreateRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LabCreate not implemented")
}
func (*UnimplementedLabServiceServer) LabGet(ctx context.Context, req *LabGetReq) (*LabCreateRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LabGet not implemented")
}
func (*UnimplementedLabServiceServer) LabsFind(ctx context.Context, req *LabsFindReq) (*LabsRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LabsFind not implemented")
}
func (*UnimplementedLabServiceServer) LabUpdate(ctx context.Context, req *LabUpdateReq) (*LabCreateRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LabUpdate not implemented")
}
func (*UnimplementedLabServiceServer) LabDelete(ctx context.Context, req *LabId) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LabDelete not implemented")
}
func (*UnimplementedLabServiceServer) AparatCreate(ctx context.Context, req *AparatCreateReq) (*AparatCreateRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AparatCreate not implemented")
}
func (*UnimplementedLabServiceServer) AparatGet(ctx context.Context, req *AparatGetReq) (*AparatCreateRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AparatGet not implemented")
}
func (*UnimplementedLabServiceServer) AparatsFind(ctx context.Context, req *AparatsFindReq) (*AparatsRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AparatsFind not implemented")
}
func (*UnimplementedLabServiceServer) AparatsUpdate(ctx context.Context, req *AparatUpdateReq) (*AparatCreateRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AparatsUpdate not implemented")
}
func (*UnimplementedLabServiceServer) AparatsDelete(ctx context.Context, req *AparatId) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AparatsDelete not implemented")
}
func (*UnimplementedLabServiceServer) LabCategoryCreate(ctx context.Context, req *Category) (*CategoryRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LabCategoryCreate not implemented")
}
func (*UnimplementedLabServiceServer) LabCategoryGet(ctx context.Context, req *CategoryGetReq) (*CategoryRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LabCategoryGet not implemented")
}
func (*UnimplementedLabServiceServer) LabCategoryFind(ctx context.Context, req *CategoryFindReq) (*CategoriesRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LabCategoryFind not implemented")
}
func (*UnimplementedLabServiceServer) LabCategoryUpdate(ctx context.Context, req *Category) (*CategoryRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LabCategoryUpdate not implemented")
}
func (*UnimplementedLabServiceServer) LabCategoryDelete(ctx context.Context, req *CategoryId) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LabCategoryDelete not implemented")
}
func (*UnimplementedLabServiceServer) AparatCategoryCreate(ctx context.Context, req *Category) (*CategoryRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AparatCategoryCreate not implemented")
}
func (*UnimplementedLabServiceServer) AparatCategoryGet(ctx context.Context, req *CategoryGetReq) (*CategoryRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AparatCategoryGet not implemented")
}
func (*UnimplementedLabServiceServer) AparatCategoryFind(ctx context.Context, req *CategoryFindReq) (*CategoriesRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AparatCategoryFind not implemented")
}
func (*UnimplementedLabServiceServer) AparatCategoryUpdate(ctx context.Context, req *Category) (*CategoryRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AparatCategoryUpdate not implemented")
}
func (*UnimplementedLabServiceServer) AparatCategoryDelete(ctx context.Context, req *CategoryId) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AparatCategoryDelete not implemented")
}
func (*UnimplementedLabServiceServer) LabSubCategoryCreate(ctx context.Context, req *SubCategory) (*SubCategoryRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LabSubCategoryCreate not implemented")
}
func (*UnimplementedLabServiceServer) LabSubCategoryGet(ctx context.Context, req *CategoryGetReq) (*SubCategoryRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LabSubCategoryGet not implemented")
}
func (*UnimplementedLabServiceServer) LabSubCategoryFind(ctx context.Context, req *SubCategoryFindReq) (*SubCategoriesRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LabSubCategoryFind not implemented")
}
func (*UnimplementedLabServiceServer) LabSubCategoryUpdate(ctx context.Context, req *SubCategory) (*SubCategoryRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LabSubCategoryUpdate not implemented")
}
func (*UnimplementedLabServiceServer) LabSubCategoryDelete(ctx context.Context, req *CategoryId) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LabSubCategoryDelete not implemented")
}
func (*UnimplementedLabServiceServer) AparatSubCategoryCreate(ctx context.Context, req *SubCategory) (*SubCategoryRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AparatSubCategoryCreate not implemented")
}
func (*UnimplementedLabServiceServer) AparatSubCategoryGet(ctx context.Context, req *CategoryGetReq) (*SubCategoryRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AparatSubCategoryGet not implemented")
}
func (*UnimplementedLabServiceServer) AparatSubCategoryFind(ctx context.Context, req *SubCategoryFindReq) (*SubCategoriesRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AparatSubCategoryFind not implemented")
}
func (*UnimplementedLabServiceServer) AparatSubCategoryUpdate(ctx context.Context, req *SubCategory) (*SubCategoryRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AparatSubCategoryUpdate not implemented")
}
func (*UnimplementedLabServiceServer) AparatSubCategoryDelete(ctx context.Context, req *CategoryId) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AparatSubCategoryDelete not implemented")
}
func (*UnimplementedLabServiceServer) AparatAnalysisCreate(ctx context.Context, req *AnalysisReq) (*AnalysisResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AparatAnalysisCreate not implemented")
}
func (*UnimplementedLabServiceServer) AparatAnalysisGet(ctx context.Context, req *AnalysisGetReq) (*AnalysisResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AparatAnalysisGet not implemented")
}
func (*UnimplementedLabServiceServer) AparatAnalysisDelete(ctx context.Context, req *AparatId) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AparatAnalysisDelete not implemented")
}
func (*UnimplementedLabServiceServer) LabAnalysisCreate(ctx context.Context, req *AnalysisReq) (*AnalysisResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LabAnalysisCreate not implemented")
}
func (*UnimplementedLabServiceServer) LabAnalysisGet(ctx context.Context, req *AnalysisGetReq) (*AnalysisResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LabAnalysisGet not implemented")
}
func (*UnimplementedLabServiceServer) LabAnalysisDelete(ctx context.Context, req *AparatId) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LabAnalysisDelete not implemented")
}

func RegisterLabServiceServer(s *grpc.Server, srv LabServiceServer) {
	s.RegisterService(&_LabService_serviceDesc, srv)
}

func _LabService_LabCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LabCreateReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LabServiceServer).LabCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/lab.LabService/LabCreate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LabServiceServer).LabCreate(ctx, req.(*LabCreateReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _LabService_LabGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LabGetReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LabServiceServer).LabGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/lab.LabService/LabGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LabServiceServer).LabGet(ctx, req.(*LabGetReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _LabService_LabsFind_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LabsFindReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LabServiceServer).LabsFind(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/lab.LabService/LabsFind",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LabServiceServer).LabsFind(ctx, req.(*LabsFindReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _LabService_LabUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LabUpdateReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LabServiceServer).LabUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/lab.LabService/LabUpdate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LabServiceServer).LabUpdate(ctx, req.(*LabUpdateReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _LabService_LabDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LabId)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LabServiceServer).LabDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/lab.LabService/LabDelete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LabServiceServer).LabDelete(ctx, req.(*LabId))
	}
	return interceptor(ctx, in, info, handler)
}

func _LabService_AparatCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AparatCreateReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LabServiceServer).AparatCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/lab.LabService/AparatCreate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LabServiceServer).AparatCreate(ctx, req.(*AparatCreateReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _LabService_AparatGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AparatGetReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LabServiceServer).AparatGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/lab.LabService/AparatGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LabServiceServer).AparatGet(ctx, req.(*AparatGetReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _LabService_AparatsFind_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AparatsFindReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LabServiceServer).AparatsFind(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/lab.LabService/AparatsFind",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LabServiceServer).AparatsFind(ctx, req.(*AparatsFindReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _LabService_AparatsUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AparatUpdateReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LabServiceServer).AparatsUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/lab.LabService/AparatsUpdate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LabServiceServer).AparatsUpdate(ctx, req.(*AparatUpdateReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _LabService_AparatsDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AparatId)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LabServiceServer).AparatsDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/lab.LabService/AparatsDelete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LabServiceServer).AparatsDelete(ctx, req.(*AparatId))
	}
	return interceptor(ctx, in, info, handler)
}

func _LabService_LabCategoryCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Category)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LabServiceServer).LabCategoryCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/lab.LabService/LabCategoryCreate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LabServiceServer).LabCategoryCreate(ctx, req.(*Category))
	}
	return interceptor(ctx, in, info, handler)
}

func _LabService_LabCategoryGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CategoryGetReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LabServiceServer).LabCategoryGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/lab.LabService/LabCategoryGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LabServiceServer).LabCategoryGet(ctx, req.(*CategoryGetReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _LabService_LabCategoryFind_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CategoryFindReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LabServiceServer).LabCategoryFind(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/lab.LabService/LabCategoryFind",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LabServiceServer).LabCategoryFind(ctx, req.(*CategoryFindReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _LabService_LabCategoryUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Category)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LabServiceServer).LabCategoryUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/lab.LabService/LabCategoryUpdate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LabServiceServer).LabCategoryUpdate(ctx, req.(*Category))
	}
	return interceptor(ctx, in, info, handler)
}

func _LabService_LabCategoryDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CategoryId)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LabServiceServer).LabCategoryDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/lab.LabService/LabCategoryDelete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LabServiceServer).LabCategoryDelete(ctx, req.(*CategoryId))
	}
	return interceptor(ctx, in, info, handler)
}

func _LabService_AparatCategoryCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Category)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LabServiceServer).AparatCategoryCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/lab.LabService/AparatCategoryCreate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LabServiceServer).AparatCategoryCreate(ctx, req.(*Category))
	}
	return interceptor(ctx, in, info, handler)
}

func _LabService_AparatCategoryGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CategoryGetReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LabServiceServer).AparatCategoryGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/lab.LabService/AparatCategoryGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LabServiceServer).AparatCategoryGet(ctx, req.(*CategoryGetReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _LabService_AparatCategoryFind_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CategoryFindReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LabServiceServer).AparatCategoryFind(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/lab.LabService/AparatCategoryFind",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LabServiceServer).AparatCategoryFind(ctx, req.(*CategoryFindReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _LabService_AparatCategoryUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Category)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LabServiceServer).AparatCategoryUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/lab.LabService/AparatCategoryUpdate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LabServiceServer).AparatCategoryUpdate(ctx, req.(*Category))
	}
	return interceptor(ctx, in, info, handler)
}

func _LabService_AparatCategoryDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CategoryId)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LabServiceServer).AparatCategoryDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/lab.LabService/AparatCategoryDelete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LabServiceServer).AparatCategoryDelete(ctx, req.(*CategoryId))
	}
	return interceptor(ctx, in, info, handler)
}

func _LabService_LabSubCategoryCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SubCategory)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LabServiceServer).LabSubCategoryCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/lab.LabService/LabSubCategoryCreate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LabServiceServer).LabSubCategoryCreate(ctx, req.(*SubCategory))
	}
	return interceptor(ctx, in, info, handler)
}

func _LabService_LabSubCategoryGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CategoryGetReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LabServiceServer).LabSubCategoryGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/lab.LabService/LabSubCategoryGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LabServiceServer).LabSubCategoryGet(ctx, req.(*CategoryGetReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _LabService_LabSubCategoryFind_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SubCategoryFindReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LabServiceServer).LabSubCategoryFind(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/lab.LabService/LabSubCategoryFind",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LabServiceServer).LabSubCategoryFind(ctx, req.(*SubCategoryFindReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _LabService_LabSubCategoryUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SubCategory)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LabServiceServer).LabSubCategoryUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/lab.LabService/LabSubCategoryUpdate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LabServiceServer).LabSubCategoryUpdate(ctx, req.(*SubCategory))
	}
	return interceptor(ctx, in, info, handler)
}

func _LabService_LabSubCategoryDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CategoryId)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LabServiceServer).LabSubCategoryDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/lab.LabService/LabSubCategoryDelete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LabServiceServer).LabSubCategoryDelete(ctx, req.(*CategoryId))
	}
	return interceptor(ctx, in, info, handler)
}

func _LabService_AparatSubCategoryCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SubCategory)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LabServiceServer).AparatSubCategoryCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/lab.LabService/AparatSubCategoryCreate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LabServiceServer).AparatSubCategoryCreate(ctx, req.(*SubCategory))
	}
	return interceptor(ctx, in, info, handler)
}

func _LabService_AparatSubCategoryGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CategoryGetReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LabServiceServer).AparatSubCategoryGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/lab.LabService/AparatSubCategoryGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LabServiceServer).AparatSubCategoryGet(ctx, req.(*CategoryGetReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _LabService_AparatSubCategoryFind_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SubCategoryFindReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LabServiceServer).AparatSubCategoryFind(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/lab.LabService/AparatSubCategoryFind",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LabServiceServer).AparatSubCategoryFind(ctx, req.(*SubCategoryFindReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _LabService_AparatSubCategoryUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SubCategory)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LabServiceServer).AparatSubCategoryUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/lab.LabService/AparatSubCategoryUpdate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LabServiceServer).AparatSubCategoryUpdate(ctx, req.(*SubCategory))
	}
	return interceptor(ctx, in, info, handler)
}

func _LabService_AparatSubCategoryDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CategoryId)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LabServiceServer).AparatSubCategoryDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/lab.LabService/AparatSubCategoryDelete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LabServiceServer).AparatSubCategoryDelete(ctx, req.(*CategoryId))
	}
	return interceptor(ctx, in, info, handler)
}

func _LabService_AparatAnalysisCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AnalysisReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LabServiceServer).AparatAnalysisCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/lab.LabService/AparatAnalysisCreate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LabServiceServer).AparatAnalysisCreate(ctx, req.(*AnalysisReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _LabService_AparatAnalysisGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AnalysisGetReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LabServiceServer).AparatAnalysisGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/lab.LabService/AparatAnalysisGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LabServiceServer).AparatAnalysisGet(ctx, req.(*AnalysisGetReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _LabService_AparatAnalysisDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AparatId)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LabServiceServer).AparatAnalysisDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/lab.LabService/AparatAnalysisDelete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LabServiceServer).AparatAnalysisDelete(ctx, req.(*AparatId))
	}
	return interceptor(ctx, in, info, handler)
}

func _LabService_LabAnalysisCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AnalysisReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LabServiceServer).LabAnalysisCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/lab.LabService/LabAnalysisCreate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LabServiceServer).LabAnalysisCreate(ctx, req.(*AnalysisReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _LabService_LabAnalysisGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AnalysisGetReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LabServiceServer).LabAnalysisGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/lab.LabService/LabAnalysisGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LabServiceServer).LabAnalysisGet(ctx, req.(*AnalysisGetReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _LabService_LabAnalysisDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AparatId)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LabServiceServer).LabAnalysisDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/lab.LabService/LabAnalysisDelete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LabServiceServer).LabAnalysisDelete(ctx, req.(*AparatId))
	}
	return interceptor(ctx, in, info, handler)
}

var _LabService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "lab.LabService",
	HandlerType: (*LabServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "LabCreate",
			Handler:    _LabService_LabCreate_Handler,
		},
		{
			MethodName: "LabGet",
			Handler:    _LabService_LabGet_Handler,
		},
		{
			MethodName: "LabsFind",
			Handler:    _LabService_LabsFind_Handler,
		},
		{
			MethodName: "LabUpdate",
			Handler:    _LabService_LabUpdate_Handler,
		},
		{
			MethodName: "LabDelete",
			Handler:    _LabService_LabDelete_Handler,
		},
		{
			MethodName: "AparatCreate",
			Handler:    _LabService_AparatCreate_Handler,
		},
		{
			MethodName: "AparatGet",
			Handler:    _LabService_AparatGet_Handler,
		},
		{
			MethodName: "AparatsFind",
			Handler:    _LabService_AparatsFind_Handler,
		},
		{
			MethodName: "AparatsUpdate",
			Handler:    _LabService_AparatsUpdate_Handler,
		},
		{
			MethodName: "AparatsDelete",
			Handler:    _LabService_AparatsDelete_Handler,
		},
		{
			MethodName: "LabCategoryCreate",
			Handler:    _LabService_LabCategoryCreate_Handler,
		},
		{
			MethodName: "LabCategoryGet",
			Handler:    _LabService_LabCategoryGet_Handler,
		},
		{
			MethodName: "LabCategoryFind",
			Handler:    _LabService_LabCategoryFind_Handler,
		},
		{
			MethodName: "LabCategoryUpdate",
			Handler:    _LabService_LabCategoryUpdate_Handler,
		},
		{
			MethodName: "LabCategoryDelete",
			Handler:    _LabService_LabCategoryDelete_Handler,
		},
		{
			MethodName: "AparatCategoryCreate",
			Handler:    _LabService_AparatCategoryCreate_Handler,
		},
		{
			MethodName: "AparatCategoryGet",
			Handler:    _LabService_AparatCategoryGet_Handler,
		},
		{
			MethodName: "AparatCategoryFind",
			Handler:    _LabService_AparatCategoryFind_Handler,
		},
		{
			MethodName: "AparatCategoryUpdate",
			Handler:    _LabService_AparatCategoryUpdate_Handler,
		},
		{
			MethodName: "AparatCategoryDelete",
			Handler:    _LabService_AparatCategoryDelete_Handler,
		},
		{
			MethodName: "LabSubCategoryCreate",
			Handler:    _LabService_LabSubCategoryCreate_Handler,
		},
		{
			MethodName: "LabSubCategoryGet",
			Handler:    _LabService_LabSubCategoryGet_Handler,
		},
		{
			MethodName: "LabSubCategoryFind",
			Handler:    _LabService_LabSubCategoryFind_Handler,
		},
		{
			MethodName: "LabSubCategoryUpdate",
			Handler:    _LabService_LabSubCategoryUpdate_Handler,
		},
		{
			MethodName: "LabSubCategoryDelete",
			Handler:    _LabService_LabSubCategoryDelete_Handler,
		},
		{
			MethodName: "AparatSubCategoryCreate",
			Handler:    _LabService_AparatSubCategoryCreate_Handler,
		},
		{
			MethodName: "AparatSubCategoryGet",
			Handler:    _LabService_AparatSubCategoryGet_Handler,
		},
		{
			MethodName: "AparatSubCategoryFind",
			Handler:    _LabService_AparatSubCategoryFind_Handler,
		},
		{
			MethodName: "AparatSubCategoryUpdate",
			Handler:    _LabService_AparatSubCategoryUpdate_Handler,
		},
		{
			MethodName: "AparatSubCategoryDelete",
			Handler:    _LabService_AparatSubCategoryDelete_Handler,
		},
		{
			MethodName: "AparatAnalysisCreate",
			Handler:    _LabService_AparatAnalysisCreate_Handler,
		},
		{
			MethodName: "AparatAnalysisGet",
			Handler:    _LabService_AparatAnalysisGet_Handler,
		},
		{
			MethodName: "AparatAnalysisDelete",
			Handler:    _LabService_AparatAnalysisDelete_Handler,
		},
		{
			MethodName: "LabAnalysisCreate",
			Handler:    _LabService_LabAnalysisCreate_Handler,
		},
		{
			MethodName: "LabAnalysisGet",
			Handler:    _LabService_LabAnalysisGet_Handler,
		},
		{
			MethodName: "LabAnalysisDelete",
			Handler:    _LabService_LabAnalysisDelete_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "lab/lab.proto",
}

func (m *SubCategoryFindReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SubCategoryFindReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SubCategoryFindReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.CategoryId) > 0 {
		i -= len(m.CategoryId)
		copy(dAtA[i:], m.CategoryId)
		i = encodeVarintLab(dAtA, i, uint64(len(m.CategoryId)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Page != 0 {
		i = encodeVarintLab(dAtA, i, uint64(m.Page))
		i--
		dAtA[i] = 0x10
	}
	if m.Limit != 0 {
		i = encodeVarintLab(dAtA, i, uint64(m.Limit))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AnalysisGetReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AnalysisGetReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AnalysisGetReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Value) > 0 {
		i -= len(m.Value)
		copy(dAtA[i:], m.Value)
		i = encodeVarintLab(dAtA, i, uint64(len(m.Value)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Field) > 0 {
		i -= len(m.Field)
		copy(dAtA[i:], m.Field)
		i = encodeVarintLab(dAtA, i, uint64(len(m.Field)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AnalysisReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AnalysisReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AnalysisReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.AnalysisUrl) > 0 {
		i -= len(m.AnalysisUrl)
		copy(dAtA[i:], m.AnalysisUrl)
		i = encodeVarintLab(dAtA, i, uint64(len(m.AnalysisUrl)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.AparatId) > 0 {
		i -= len(m.AparatId)
		copy(dAtA[i:], m.AparatId)
		i = encodeVarintLab(dAtA, i, uint64(len(m.AparatId)))
		i--
		dAtA[i] = 0x1a
	}
	if m.ClientId != 0 {
		i = encodeVarintLab(dAtA, i, uint64(m.ClientId))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintLab(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AnalysisResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AnalysisResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AnalysisResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.UpdatedAt) > 0 {
		i -= len(m.UpdatedAt)
		copy(dAtA[i:], m.UpdatedAt)
		i = encodeVarintLab(dAtA, i, uint64(len(m.UpdatedAt)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.CreatedAt) > 0 {
		i -= len(m.CreatedAt)
		copy(dAtA[i:], m.CreatedAt)
		i = encodeVarintLab(dAtA, i, uint64(len(m.CreatedAt)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.AnalysisUrl) > 0 {
		i -= len(m.AnalysisUrl)
		copy(dAtA[i:], m.AnalysisUrl)
		i = encodeVarintLab(dAtA, i, uint64(len(m.AnalysisUrl)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.AparatId) > 0 {
		i -= len(m.AparatId)
		copy(dAtA[i:], m.AparatId)
		i = encodeVarintLab(dAtA, i, uint64(len(m.AparatId)))
		i--
		dAtA[i] = 0x1a
	}
	if m.ClientId != 0 {
		i = encodeVarintLab(dAtA, i, uint64(m.ClientId))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintLab(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SubCategoriesRes) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SubCategoriesRes) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SubCategoriesRes) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Count != 0 {
		i = encodeVarintLab(dAtA, i, uint64(m.Count))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Info) > 0 {
		for iNdEx := len(m.Info) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Info[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintLab(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *SubCategory) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SubCategory) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SubCategory) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.CategoryId) > 0 {
		i -= len(m.CategoryId)
		copy(dAtA[i:], m.CategoryId)
		i = encodeVarintLab(dAtA, i, uint64(len(m.CategoryId)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintLab(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintLab(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SubCategoryRes) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SubCategoryRes) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SubCategoryRes) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.UpdatedAt) > 0 {
		i -= len(m.UpdatedAt)
		copy(dAtA[i:], m.UpdatedAt)
		i = encodeVarintLab(dAtA, i, uint64(len(m.UpdatedAt)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.CreatedAt) > 0 {
		i -= len(m.CreatedAt)
		copy(dAtA[i:], m.CreatedAt)
		i = encodeVarintLab(dAtA, i, uint64(len(m.CreatedAt)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.CategoryId) > 0 {
		i -= len(m.CategoryId)
		copy(dAtA[i:], m.CategoryId)
		i = encodeVarintLab(dAtA, i, uint64(len(m.CategoryId)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintLab(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintLab(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Category) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Category) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Category) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintLab(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintLab(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CategoryRes) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CategoryRes) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CategoryRes) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.UpdatedAt) > 0 {
		i -= len(m.UpdatedAt)
		copy(dAtA[i:], m.UpdatedAt)
		i = encodeVarintLab(dAtA, i, uint64(len(m.UpdatedAt)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.CreatedAt) > 0 {
		i -= len(m.CreatedAt)
		copy(dAtA[i:], m.CreatedAt)
		i = encodeVarintLab(dAtA, i, uint64(len(m.CreatedAt)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintLab(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintLab(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CategoryId) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CategoryId) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CategoryId) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintLab(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CategoryGetReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CategoryGetReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CategoryGetReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Value) > 0 {
		i -= len(m.Value)
		copy(dAtA[i:], m.Value)
		i = encodeVarintLab(dAtA, i, uint64(len(m.Value)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Field) > 0 {
		i -= len(m.Field)
		copy(dAtA[i:], m.Field)
		i = encodeVarintLab(dAtA, i, uint64(len(m.Field)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CategoryFindReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CategoryFindReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CategoryFindReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Search) > 0 {
		i -= len(m.Search)
		copy(dAtA[i:], m.Search)
		i = encodeVarintLab(dAtA, i, uint64(len(m.Search)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Page != 0 {
		i = encodeVarintLab(dAtA, i, uint64(m.Page))
		i--
		dAtA[i] = 0x10
	}
	if m.Limit != 0 {
		i = encodeVarintLab(dAtA, i, uint64(m.Limit))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CategoriesRes) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CategoriesRes) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CategoriesRes) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Count != 0 {
		i = encodeVarintLab(dAtA, i, uint64(m.Count))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Info) > 0 {
		for iNdEx := len(m.Info) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Info[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintLab(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *AparatCreateReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AparatCreateReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AparatCreateReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.RoomNumber) > 0 {
		i -= len(m.RoomNumber)
		copy(dAtA[i:], m.RoomNumber)
		i = encodeVarintLab(dAtA, i, uint64(len(m.RoomNumber)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.DoctorId) > 0 {
		i -= len(m.DoctorId)
		copy(dAtA[i:], m.DoctorId)
		i = encodeVarintLab(dAtA, i, uint64(len(m.DoctorId)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.SubCategoryId) > 0 {
		i -= len(m.SubCategoryId)
		copy(dAtA[i:], m.SubCategoryId)
		i = encodeVarintLab(dAtA, i, uint64(len(m.SubCategoryId)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Type) > 0 {
		i -= len(m.Type)
		copy(dAtA[i:], m.Type)
		i = encodeVarintLab(dAtA, i, uint64(len(m.Type)))
		i--
		dAtA[i] = 0x22
	}
	if m.Price != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Price))))
		i--
		dAtA[i] = 0x19
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintLab(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintLab(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AparatCreateRes) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AparatCreateRes) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AparatCreateRes) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.UpdatedAt) > 0 {
		i -= len(m.UpdatedAt)
		copy(dAtA[i:], m.UpdatedAt)
		i = encodeVarintLab(dAtA, i, uint64(len(m.UpdatedAt)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.CreatedAt) > 0 {
		i -= len(m.CreatedAt)
		copy(dAtA[i:], m.CreatedAt)
		i = encodeVarintLab(dAtA, i, uint64(len(m.CreatedAt)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.RoomNumber) > 0 {
		i -= len(m.RoomNumber)
		copy(dAtA[i:], m.RoomNumber)
		i = encodeVarintLab(dAtA, i, uint64(len(m.RoomNumber)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.DoctorId) > 0 {
		i -= len(m.DoctorId)
		copy(dAtA[i:], m.DoctorId)
		i = encodeVarintLab(dAtA, i, uint64(len(m.DoctorId)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.SubCategoryId) > 0 {
		i -= len(m.SubCategoryId)
		copy(dAtA[i:], m.SubCategoryId)
		i = encodeVarintLab(dAtA, i, uint64(len(m.SubCategoryId)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Type) > 0 {
		i -= len(m.Type)
		copy(dAtA[i:], m.Type)
		i = encodeVarintLab(dAtA, i, uint64(len(m.Type)))
		i--
		dAtA[i] = 0x22
	}
	if m.Price != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Price))))
		i--
		dAtA[i] = 0x19
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintLab(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintLab(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AparatGetReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AparatGetReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AparatGetReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Value) > 0 {
		i -= len(m.Value)
		copy(dAtA[i:], m.Value)
		i = encodeVarintLab(dAtA, i, uint64(len(m.Value)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Field) > 0 {
		i -= len(m.Field)
		copy(dAtA[i:], m.Field)
		i = encodeVarintLab(dAtA, i, uint64(len(m.Field)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AparatsFindReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AparatsFindReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AparatsFindReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Search) > 0 {
		i -= len(m.Search)
		copy(dAtA[i:], m.Search)
		i = encodeVarintLab(dAtA, i, uint64(len(m.Search)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Page != 0 {
		i = encodeVarintLab(dAtA, i, uint64(m.Page))
		i--
		dAtA[i] = 0x10
	}
	if m.Limit != 0 {
		i = encodeVarintLab(dAtA, i, uint64(m.Limit))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AparatsRes) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AparatsRes) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AparatsRes) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Count != 0 {
		i = encodeVarintLab(dAtA, i, uint64(m.Count))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Aparats) > 0 {
		for iNdEx := len(m.Aparats) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Aparats[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintLab(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *AparatUpdateReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AparatUpdateReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AparatUpdateReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.RoomNumber) > 0 {
		i -= len(m.RoomNumber)
		copy(dAtA[i:], m.RoomNumber)
		i = encodeVarintLab(dAtA, i, uint64(len(m.RoomNumber)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.DoctorId) > 0 {
		i -= len(m.DoctorId)
		copy(dAtA[i:], m.DoctorId)
		i = encodeVarintLab(dAtA, i, uint64(len(m.DoctorId)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Type) > 0 {
		i -= len(m.Type)
		copy(dAtA[i:], m.Type)
		i = encodeVarintLab(dAtA, i, uint64(len(m.Type)))
		i--
		dAtA[i] = 0x22
	}
	if m.Price != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Price))))
		i--
		dAtA[i] = 0x19
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintLab(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintLab(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AparatId) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AparatId) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AparatId) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintLab(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *LabId) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LabId) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LabId) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintLab(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *LabUpdateReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LabUpdateReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LabUpdateReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.RoomNumber) > 0 {
		i -= len(m.RoomNumber)
		copy(dAtA[i:], m.RoomNumber)
		i = encodeVarintLab(dAtA, i, uint64(len(m.RoomNumber)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.DoctorId) > 0 {
		i -= len(m.DoctorId)
		copy(dAtA[i:], m.DoctorId)
		i = encodeVarintLab(dAtA, i, uint64(len(m.DoctorId)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Type) > 0 {
		i -= len(m.Type)
		copy(dAtA[i:], m.Type)
		i = encodeVarintLab(dAtA, i, uint64(len(m.Type)))
		i--
		dAtA[i] = 0x22
	}
	if m.Price != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Price))))
		i--
		dAtA[i] = 0x19
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintLab(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintLab(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *LabsRes) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LabsRes) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LabsRes) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Count != 0 {
		i = encodeVarintLab(dAtA, i, uint64(m.Count))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Labs) > 0 {
		for iNdEx := len(m.Labs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Labs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintLab(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *LabsFindReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LabsFindReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LabsFindReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Search) > 0 {
		i -= len(m.Search)
		copy(dAtA[i:], m.Search)
		i = encodeVarintLab(dAtA, i, uint64(len(m.Search)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Page != 0 {
		i = encodeVarintLab(dAtA, i, uint64(m.Page))
		i--
		dAtA[i] = 0x10
	}
	if m.Limit != 0 {
		i = encodeVarintLab(dAtA, i, uint64(m.Limit))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LabGetReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LabGetReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LabGetReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Value) > 0 {
		i -= len(m.Value)
		copy(dAtA[i:], m.Value)
		i = encodeVarintLab(dAtA, i, uint64(len(m.Value)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Field) > 0 {
		i -= len(m.Field)
		copy(dAtA[i:], m.Field)
		i = encodeVarintLab(dAtA, i, uint64(len(m.Field)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *LabCreateReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LabCreateReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LabCreateReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.RoomNumber) > 0 {
		i -= len(m.RoomNumber)
		copy(dAtA[i:], m.RoomNumber)
		i = encodeVarintLab(dAtA, i, uint64(len(m.RoomNumber)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.DoctorId) > 0 {
		i -= len(m.DoctorId)
		copy(dAtA[i:], m.DoctorId)
		i = encodeVarintLab(dAtA, i, uint64(len(m.DoctorId)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.SubCategoryId) > 0 {
		i -= len(m.SubCategoryId)
		copy(dAtA[i:], m.SubCategoryId)
		i = encodeVarintLab(dAtA, i, uint64(len(m.SubCategoryId)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Type) > 0 {
		i -= len(m.Type)
		copy(dAtA[i:], m.Type)
		i = encodeVarintLab(dAtA, i, uint64(len(m.Type)))
		i--
		dAtA[i] = 0x22
	}
	if m.Price != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Price))))
		i--
		dAtA[i] = 0x19
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintLab(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintLab(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *LabCreateRes) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LabCreateRes) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LabCreateRes) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.DeletedAt) > 0 {
		i -= len(m.DeletedAt)
		copy(dAtA[i:], m.DeletedAt)
		i = encodeVarintLab(dAtA, i, uint64(len(m.DeletedAt)))
		i--
		dAtA[i] = 0x52
	}
	if len(m.UpdatedAt) > 0 {
		i -= len(m.UpdatedAt)
		copy(dAtA[i:], m.UpdatedAt)
		i = encodeVarintLab(dAtA, i, uint64(len(m.UpdatedAt)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.CreatedAt) > 0 {
		i -= len(m.CreatedAt)
		copy(dAtA[i:], m.CreatedAt)
		i = encodeVarintLab(dAtA, i, uint64(len(m.CreatedAt)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.RoomNumber) > 0 {
		i -= len(m.RoomNumber)
		copy(dAtA[i:], m.RoomNumber)
		i = encodeVarintLab(dAtA, i, uint64(len(m.RoomNumber)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.DoctorId) > 0 {
		i -= len(m.DoctorId)
		copy(dAtA[i:], m.DoctorId)
		i = encodeVarintLab(dAtA, i, uint64(len(m.DoctorId)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.SubCategoryId) > 0 {
		i -= len(m.SubCategoryId)
		copy(dAtA[i:], m.SubCategoryId)
		i = encodeVarintLab(dAtA, i, uint64(len(m.SubCategoryId)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Type) > 0 {
		i -= len(m.Type)
		copy(dAtA[i:], m.Type)
		i = encodeVarintLab(dAtA, i, uint64(len(m.Type)))
		i--
		dAtA[i] = 0x22
	}
	if m.Price != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Price))))
		i--
		dAtA[i] = 0x19
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintLab(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintLab(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintLab(dAtA []byte, offset int, v uint64) int {
	offset -= sovLab(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *SubCategoryFindReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Limit != 0 {
		n += 1 + sovLab(uint64(m.Limit))
	}
	if m.Page != 0 {
		n += 1 + sovLab(uint64(m.Page))
	}
	l = len(m.CategoryId)
	if l > 0 {
		n += 1 + l + sovLab(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AnalysisGetReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Field)
	if l > 0 {
		n += 1 + l + sovLab(uint64(l))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovLab(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AnalysisReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovLab(uint64(l))
	}
	if m.ClientId != 0 {
		n += 1 + sovLab(uint64(m.ClientId))
	}
	l = len(m.AparatId)
	if l > 0 {
		n += 1 + l + sovLab(uint64(l))
	}
	l = len(m.AnalysisUrl)
	if l > 0 {
		n += 1 + l + sovLab(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AnalysisResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovLab(uint64(l))
	}
	if m.ClientId != 0 {
		n += 1 + sovLab(uint64(m.ClientId))
	}
	l = len(m.AparatId)
	if l > 0 {
		n += 1 + l + sovLab(uint64(l))
	}
	l = len(m.AnalysisUrl)
	if l > 0 {
		n += 1 + l + sovLab(uint64(l))
	}
	l = len(m.CreatedAt)
	if l > 0 {
		n += 1 + l + sovLab(uint64(l))
	}
	l = len(m.UpdatedAt)
	if l > 0 {
		n += 1 + l + sovLab(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SubCategoriesRes) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Info) > 0 {
		for _, e := range m.Info {
			l = e.Size()
			n += 1 + l + sovLab(uint64(l))
		}
	}
	if m.Count != 0 {
		n += 1 + sovLab(uint64(m.Count))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SubCategory) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovLab(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovLab(uint64(l))
	}
	l = len(m.CategoryId)
	if l > 0 {
		n += 1 + l + sovLab(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SubCategoryRes) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovLab(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovLab(uint64(l))
	}
	l = len(m.CategoryId)
	if l > 0 {
		n += 1 + l + sovLab(uint64(l))
	}
	l = len(m.CreatedAt)
	if l > 0 {
		n += 1 + l + sovLab(uint64(l))
	}
	l = len(m.UpdatedAt)
	if l > 0 {
		n += 1 + l + sovLab(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Category) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovLab(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovLab(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CategoryRes) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovLab(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovLab(uint64(l))
	}
	l = len(m.CreatedAt)
	if l > 0 {
		n += 1 + l + sovLab(uint64(l))
	}
	l = len(m.UpdatedAt)
	if l > 0 {
		n += 1 + l + sovLab(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CategoryId) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovLab(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CategoryGetReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Field)
	if l > 0 {
		n += 1 + l + sovLab(uint64(l))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovLab(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CategoryFindReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Limit != 0 {
		n += 1 + sovLab(uint64(m.Limit))
	}
	if m.Page != 0 {
		n += 1 + sovLab(uint64(m.Page))
	}
	l = len(m.Search)
	if l > 0 {
		n += 1 + l + sovLab(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CategoriesRes) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Info) > 0 {
		for _, e := range m.Info {
			l = e.Size()
			n += 1 + l + sovLab(uint64(l))
		}
	}
	if m.Count != 0 {
		n += 1 + sovLab(uint64(m.Count))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AparatCreateReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovLab(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovLab(uint64(l))
	}
	if m.Price != 0 {
		n += 9
	}
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovLab(uint64(l))
	}
	l = len(m.SubCategoryId)
	if l > 0 {
		n += 1 + l + sovLab(uint64(l))
	}
	l = len(m.DoctorId)
	if l > 0 {
		n += 1 + l + sovLab(uint64(l))
	}
	l = len(m.RoomNumber)
	if l > 0 {
		n += 1 + l + sovLab(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AparatCreateRes) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovLab(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovLab(uint64(l))
	}
	if m.Price != 0 {
		n += 9
	}
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovLab(uint64(l))
	}
	l = len(m.SubCategoryId)
	if l > 0 {
		n += 1 + l + sovLab(uint64(l))
	}
	l = len(m.DoctorId)
	if l > 0 {
		n += 1 + l + sovLab(uint64(l))
	}
	l = len(m.RoomNumber)
	if l > 0 {
		n += 1 + l + sovLab(uint64(l))
	}
	l = len(m.CreatedAt)
	if l > 0 {
		n += 1 + l + sovLab(uint64(l))
	}
	l = len(m.UpdatedAt)
	if l > 0 {
		n += 1 + l + sovLab(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AparatGetReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Field)
	if l > 0 {
		n += 1 + l + sovLab(uint64(l))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovLab(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AparatsFindReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Limit != 0 {
		n += 1 + sovLab(uint64(m.Limit))
	}
	if m.Page != 0 {
		n += 1 + sovLab(uint64(m.Page))
	}
	l = len(m.Search)
	if l > 0 {
		n += 1 + l + sovLab(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AparatsRes) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Aparats) > 0 {
		for _, e := range m.Aparats {
			l = e.Size()
			n += 1 + l + sovLab(uint64(l))
		}
	}
	if m.Count != 0 {
		n += 1 + sovLab(uint64(m.Count))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AparatUpdateReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovLab(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovLab(uint64(l))
	}
	if m.Price != 0 {
		n += 9
	}
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovLab(uint64(l))
	}
	l = len(m.DoctorId)
	if l > 0 {
		n += 1 + l + sovLab(uint64(l))
	}
	l = len(m.RoomNumber)
	if l > 0 {
		n += 1 + l + sovLab(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AparatId) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovLab(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LabId) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovLab(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LabUpdateReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovLab(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovLab(uint64(l))
	}
	if m.Price != 0 {
		n += 9
	}
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovLab(uint64(l))
	}
	l = len(m.DoctorId)
	if l > 0 {
		n += 1 + l + sovLab(uint64(l))
	}
	l = len(m.RoomNumber)
	if l > 0 {
		n += 1 + l + sovLab(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LabsRes) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Labs) > 0 {
		for _, e := range m.Labs {
			l = e.Size()
			n += 1 + l + sovLab(uint64(l))
		}
	}
	if m.Count != 0 {
		n += 1 + sovLab(uint64(m.Count))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LabsFindReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Limit != 0 {
		n += 1 + sovLab(uint64(m.Limit))
	}
	if m.Page != 0 {
		n += 1 + sovLab(uint64(m.Page))
	}
	l = len(m.Search)
	if l > 0 {
		n += 1 + l + sovLab(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LabGetReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Field)
	if l > 0 {
		n += 1 + l + sovLab(uint64(l))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovLab(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LabCreateReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovLab(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovLab(uint64(l))
	}
	if m.Price != 0 {
		n += 9
	}
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovLab(uint64(l))
	}
	l = len(m.SubCategoryId)
	if l > 0 {
		n += 1 + l + sovLab(uint64(l))
	}
	l = len(m.DoctorId)
	if l > 0 {
		n += 1 + l + sovLab(uint64(l))
	}
	l = len(m.RoomNumber)
	if l > 0 {
		n += 1 + l + sovLab(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LabCreateRes) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovLab(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovLab(uint64(l))
	}
	if m.Price != 0 {
		n += 9
	}
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovLab(uint64(l))
	}
	l = len(m.SubCategoryId)
	if l > 0 {
		n += 1 + l + sovLab(uint64(l))
	}
	l = len(m.DoctorId)
	if l > 0 {
		n += 1 + l + sovLab(uint64(l))
	}
	l = len(m.RoomNumber)
	if l > 0 {
		n += 1 + l + sovLab(uint64(l))
	}
	l = len(m.CreatedAt)
	if l > 0 {
		n += 1 + l + sovLab(uint64(l))
	}
	l = len(m.UpdatedAt)
	if l > 0 {
		n += 1 + l + sovLab(uint64(l))
	}
	l = len(m.DeletedAt)
	if l > 0 {
		n += 1 + l + sovLab(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovLab(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozLab(x uint64) (n int) {
	return sovLab(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *SubCategoryFindReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLab
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SubCategoryFindReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SubCategoryFindReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			m.Limit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLab
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Limit |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Page", wireType)
			}
			m.Page = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLab
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Page |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CategoryId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLab
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLab
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLab
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CategoryId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLab(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthLab
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AnalysisGetReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLab
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AnalysisGetReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AnalysisGetReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Field", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLab
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLab
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLab
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Field = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLab
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLab
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLab
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLab(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthLab
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AnalysisReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLab
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AnalysisReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AnalysisReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLab
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLab
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLab
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientId", wireType)
			}
			m.ClientId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLab
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClientId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AparatId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLab
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLab
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLab
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AparatId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AnalysisUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLab
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLab
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLab
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AnalysisUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLab(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthLab
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AnalysisResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLab
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AnalysisResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AnalysisResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLab
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLab
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLab
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientId", wireType)
			}
			m.ClientId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLab
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClientId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AparatId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLab
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLab
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLab
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AparatId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AnalysisUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLab
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLab
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLab
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AnalysisUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedAt", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLab
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLab
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLab
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CreatedAt = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdatedAt", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLab
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLab
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLab
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UpdatedAt = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLab(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthLab
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SubCategoriesRes) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLab
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SubCategoriesRes: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SubCategoriesRes: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Info", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLab
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLab
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLab
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Info = append(m.Info, &SubCategoryRes{})
			if err := m.Info[len(m.Info)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLab
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Count |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipLab(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthLab
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SubCategory) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLab
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SubCategory: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SubCategory: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLab
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLab
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLab
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLab
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLab
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLab
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CategoryId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLab
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLab
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLab
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CategoryId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLab(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthLab
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SubCategoryRes) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLab
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SubCategoryRes: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SubCategoryRes: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLab
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLab
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLab
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLab
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLab
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLab
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CategoryId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLab
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLab
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLab
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CategoryId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedAt", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLab
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLab
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLab
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CreatedAt = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdatedAt", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLab
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLab
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLab
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UpdatedAt = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLab(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthLab
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Category) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLab
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Category: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Category: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLab
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLab
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLab
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLab
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLab
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLab
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLab(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthLab
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CategoryRes) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLab
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CategoryRes: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CategoryRes: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLab
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLab
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLab
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLab
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLab
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLab
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedAt", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLab
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLab
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLab
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CreatedAt = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdatedAt", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLab
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLab
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLab
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UpdatedAt = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLab(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthLab
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CategoryId) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLab
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CategoryId: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CategoryId: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLab
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLab
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLab
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLab(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthLab
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CategoryGetReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLab
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CategoryGetReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CategoryGetReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Field", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLab
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLab
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLab
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Field = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLab
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLab
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLab
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLab(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthLab
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CategoryFindReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLab
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CategoryFindReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CategoryFindReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			m.Limit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLab
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Limit |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Page", wireType)
			}
			m.Page = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLab
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Page |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Search", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLab
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLab
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLab
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Search = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLab(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthLab
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CategoriesRes) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLab
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CategoriesRes: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CategoriesRes: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Info", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLab
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLab
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLab
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Info = append(m.Info, &CategoryRes{})
			if err := m.Info[len(m.Info)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLab
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Count |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipLab(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthLab
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AparatCreateReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLab
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AparatCreateReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AparatCreateReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLab
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLab
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLab
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLab
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLab
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLab
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Price", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Price = float64(math.Float64frombits(v))
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLab
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLab
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLab
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubCategoryId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLab
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLab
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLab
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SubCategoryId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DoctorId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLab
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLab
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLab
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DoctorId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoomNumber", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLab
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLab
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLab
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RoomNumber = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLab(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthLab
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AparatCreateRes) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLab
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AparatCreateRes: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AparatCreateRes: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLab
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLab
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLab
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLab
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLab
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLab
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Price", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Price = float64(math.Float64frombits(v))
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLab
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLab
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLab
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubCategoryId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLab
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLab
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLab
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SubCategoryId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DoctorId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLab
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLab
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLab
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DoctorId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoomNumber", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLab
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLab
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLab
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RoomNumber = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedAt", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLab
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLab
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLab
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CreatedAt = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdatedAt", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLab
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLab
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLab
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UpdatedAt = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLab(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthLab
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AparatGetReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLab
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AparatGetReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AparatGetReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Field", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLab
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLab
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLab
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Field = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLab
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLab
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLab
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLab(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthLab
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AparatsFindReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLab
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AparatsFindReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AparatsFindReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			m.Limit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLab
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Limit |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Page", wireType)
			}
			m.Page = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLab
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Page |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Search", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLab
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLab
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLab
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Search = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLab(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthLab
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AparatsRes) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLab
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AparatsRes: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AparatsRes: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Aparats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLab
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLab
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLab
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Aparats = append(m.Aparats, &AparatCreateRes{})
			if err := m.Aparats[len(m.Aparats)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLab
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Count |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipLab(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthLab
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AparatUpdateReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLab
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AparatUpdateReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AparatUpdateReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLab
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLab
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLab
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLab
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLab
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLab
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Price", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Price = float64(math.Float64frombits(v))
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLab
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLab
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLab
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DoctorId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLab
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLab
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLab
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DoctorId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoomNumber", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLab
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLab
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLab
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RoomNumber = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLab(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthLab
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AparatId) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLab
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AparatId: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AparatId: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLab
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLab
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLab
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLab(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthLab
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LabId) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLab
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LabId: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LabId: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLab
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLab
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLab
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLab(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthLab
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LabUpdateReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLab
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LabUpdateReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LabUpdateReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLab
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLab
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLab
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLab
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLab
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLab
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Price", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Price = float64(math.Float64frombits(v))
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLab
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLab
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLab
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DoctorId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLab
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLab
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLab
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DoctorId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoomNumber", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLab
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLab
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLab
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RoomNumber = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLab(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthLab
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LabsRes) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLab
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LabsRes: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LabsRes: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Labs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLab
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLab
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLab
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Labs = append(m.Labs, &LabCreateRes{})
			if err := m.Labs[len(m.Labs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLab
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Count |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipLab(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthLab
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LabsFindReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLab
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LabsFindReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LabsFindReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			m.Limit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLab
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Limit |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Page", wireType)
			}
			m.Page = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLab
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Page |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Search", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLab
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLab
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLab
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Search = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLab(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthLab
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LabGetReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLab
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LabGetReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LabGetReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Field", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLab
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLab
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLab
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Field = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLab
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLab
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLab
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLab(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthLab
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LabCreateReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLab
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LabCreateReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LabCreateReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLab
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLab
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLab
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLab
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLab
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLab
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Price", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Price = float64(math.Float64frombits(v))
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLab
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLab
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLab
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubCategoryId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLab
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLab
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLab
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SubCategoryId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DoctorId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLab
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLab
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLab
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DoctorId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoomNumber", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLab
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLab
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLab
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RoomNumber = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLab(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthLab
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LabCreateRes) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLab
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LabCreateRes: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LabCreateRes: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLab
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLab
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLab
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLab
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLab
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLab
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Price", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Price = float64(math.Float64frombits(v))
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLab
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLab
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLab
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubCategoryId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLab
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLab
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLab
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SubCategoryId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DoctorId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLab
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLab
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLab
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DoctorId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoomNumber", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLab
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLab
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLab
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RoomNumber = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedAt", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLab
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLab
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLab
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CreatedAt = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdatedAt", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLab
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLab
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLab
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UpdatedAt = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeletedAt", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLab
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLab
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLab
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeletedAt = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLab(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthLab
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipLab(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowLab
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowLab
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowLab
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthLab
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupLab
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthLab
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthLab        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowLab          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupLab = fmt.Errorf("proto: unexpected end of group")
)
