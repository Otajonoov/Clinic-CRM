// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: patient/patient.proto

package patient

import (
	context "context"
	encoding_binary "encoding/binary"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	empty "github.com/golang/protobuf/ptypes/empty"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type PaymentHistoryFilter struct {
	ClientId             int64    `protobuf:"varint,1,opt,name=client_id,json=clientId,proto3" json:"client_id"`
	Limit                int64    `protobuf:"varint,2,opt,name=limit,proto3" json:"limit"`
	Page                 int64    `protobuf:"varint,3,opt,name=page,proto3" json:"page"`
	FromDate             string   `protobuf:"bytes,4,opt,name=from_date,json=fromDate,proto3" json:"from_date"`
	ToDate               string   `protobuf:"bytes,5,opt,name=to_date,json=toDate,proto3" json:"to_date"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PaymentHistoryFilter) Reset()         { *m = PaymentHistoryFilter{} }
func (m *PaymentHistoryFilter) String() string { return proto.CompactTextString(m) }
func (*PaymentHistoryFilter) ProtoMessage()    {}
func (*PaymentHistoryFilter) Descriptor() ([]byte, []int) {
	return fileDescriptor_ae32a8d1a528f6da, []int{0}
}
func (m *PaymentHistoryFilter) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PaymentHistoryFilter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PaymentHistoryFilter.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PaymentHistoryFilter) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PaymentHistoryFilter.Merge(m, src)
}
func (m *PaymentHistoryFilter) XXX_Size() int {
	return m.Size()
}
func (m *PaymentHistoryFilter) XXX_DiscardUnknown() {
	xxx_messageInfo_PaymentHistoryFilter.DiscardUnknown(m)
}

var xxx_messageInfo_PaymentHistoryFilter proto.InternalMessageInfo

func (m *PaymentHistoryFilter) GetClientId() int64 {
	if m != nil {
		return m.ClientId
	}
	return 0
}

func (m *PaymentHistoryFilter) GetLimit() int64 {
	if m != nil {
		return m.Limit
	}
	return 0
}

func (m *PaymentHistoryFilter) GetPage() int64 {
	if m != nil {
		return m.Page
	}
	return 0
}

func (m *PaymentHistoryFilter) GetFromDate() string {
	if m != nil {
		return m.FromDate
	}
	return ""
}

func (m *PaymentHistoryFilter) GetToDate() string {
	if m != nil {
		return m.ToDate
	}
	return ""
}

type PaymentHistoriesResp struct {
	PaymentHistory       []*PaymentHistoryResp `protobuf:"bytes,1,rep,name=payment_history,json=paymentHistory,proto3" json:"payment_history"`
	Count                int64                 `protobuf:"varint,2,opt,name=count,proto3" json:"count"`
	XXX_NoUnkeyedLiteral struct{}              `json:"-"`
	XXX_unrecognized     []byte                `json:"-"`
	XXX_sizecache        int32                 `json:"-"`
}

func (m *PaymentHistoriesResp) Reset()         { *m = PaymentHistoriesResp{} }
func (m *PaymentHistoriesResp) String() string { return proto.CompactTextString(m) }
func (*PaymentHistoriesResp) ProtoMessage()    {}
func (*PaymentHistoriesResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_ae32a8d1a528f6da, []int{1}
}
func (m *PaymentHistoriesResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PaymentHistoriesResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PaymentHistoriesResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PaymentHistoriesResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PaymentHistoriesResp.Merge(m, src)
}
func (m *PaymentHistoriesResp) XXX_Size() int {
	return m.Size()
}
func (m *PaymentHistoriesResp) XXX_DiscardUnknown() {
	xxx_messageInfo_PaymentHistoriesResp.DiscardUnknown(m)
}

var xxx_messageInfo_PaymentHistoriesResp proto.InternalMessageInfo

func (m *PaymentHistoriesResp) GetPaymentHistory() []*PaymentHistoryResp {
	if m != nil {
		return m.PaymentHistory
	}
	return nil
}

func (m *PaymentHistoriesResp) GetCount() int64 {
	if m != nil {
		return m.Count
	}
	return 0
}

type PaymentHistoryId struct {
	Id                   string   `protobuf:"bytes,1,opt,name=id,proto3" json:"id"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PaymentHistoryId) Reset()         { *m = PaymentHistoryId{} }
func (m *PaymentHistoryId) String() string { return proto.CompactTextString(m) }
func (*PaymentHistoryId) ProtoMessage()    {}
func (*PaymentHistoryId) Descriptor() ([]byte, []int) {
	return fileDescriptor_ae32a8d1a528f6da, []int{2}
}
func (m *PaymentHistoryId) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PaymentHistoryId) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PaymentHistoryId.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PaymentHistoryId) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PaymentHistoryId.Merge(m, src)
}
func (m *PaymentHistoryId) XXX_Size() int {
	return m.Size()
}
func (m *PaymentHistoryId) XXX_DiscardUnknown() {
	xxx_messageInfo_PaymentHistoryId.DiscardUnknown(m)
}

var xxx_messageInfo_PaymentHistoryId proto.InternalMessageInfo

func (m *PaymentHistoryId) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

type CreatePaymentHistoryReq struct {
	Id                   string   `protobuf:"bytes,1,opt,name=id,proto3" json:"id"`
	ClientId             int64    `protobuf:"varint,2,opt,name=client_id,json=clientId,proto3" json:"client_id"`
	Summa                int64    `protobuf:"varint,3,opt,name=summa,proto3" json:"summa"`
	PaymentType          string   `protobuf:"bytes,4,opt,name=payment_type,json=paymentType,proto3" json:"payment_type"`
	CashboxId            string   `protobuf:"bytes,5,opt,name=cashbox_id,json=cashboxId,proto3" json:"cashbox_id"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CreatePaymentHistoryReq) Reset()         { *m = CreatePaymentHistoryReq{} }
func (m *CreatePaymentHistoryReq) String() string { return proto.CompactTextString(m) }
func (*CreatePaymentHistoryReq) ProtoMessage()    {}
func (*CreatePaymentHistoryReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_ae32a8d1a528f6da, []int{3}
}
func (m *CreatePaymentHistoryReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreatePaymentHistoryReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CreatePaymentHistoryReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CreatePaymentHistoryReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreatePaymentHistoryReq.Merge(m, src)
}
func (m *CreatePaymentHistoryReq) XXX_Size() int {
	return m.Size()
}
func (m *CreatePaymentHistoryReq) XXX_DiscardUnknown() {
	xxx_messageInfo_CreatePaymentHistoryReq.DiscardUnknown(m)
}

var xxx_messageInfo_CreatePaymentHistoryReq proto.InternalMessageInfo

func (m *CreatePaymentHistoryReq) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *CreatePaymentHistoryReq) GetClientId() int64 {
	if m != nil {
		return m.ClientId
	}
	return 0
}

func (m *CreatePaymentHistoryReq) GetSumma() int64 {
	if m != nil {
		return m.Summa
	}
	return 0
}

func (m *CreatePaymentHistoryReq) GetPaymentType() string {
	if m != nil {
		return m.PaymentType
	}
	return ""
}

func (m *CreatePaymentHistoryReq) GetCashboxId() string {
	if m != nil {
		return m.CashboxId
	}
	return ""
}

type PaymentHistoryResp struct {
	Id                   string   `protobuf:"bytes,1,opt,name=id,proto3" json:"id"`
	ClientId             int64    `protobuf:"varint,2,opt,name=client_id,json=clientId,proto3" json:"client_id"`
	Summa                int64    `protobuf:"varint,3,opt,name=summa,proto3" json:"summa"`
	PaymentType          string   `protobuf:"bytes,4,opt,name=payment_type,json=paymentType,proto3" json:"payment_type"`
	CashboxId            string   `protobuf:"bytes,5,opt,name=cashbox_id,json=cashboxId,proto3" json:"cashbox_id"`
	CreatedAt            string   `protobuf:"bytes,6,opt,name=created_at,json=createdAt,proto3" json:"created_at"`
	UpdatedAt            string   `protobuf:"bytes,7,opt,name=updated_at,json=updatedAt,proto3" json:"updated_at"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PaymentHistoryResp) Reset()         { *m = PaymentHistoryResp{} }
func (m *PaymentHistoryResp) String() string { return proto.CompactTextString(m) }
func (*PaymentHistoryResp) ProtoMessage()    {}
func (*PaymentHistoryResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_ae32a8d1a528f6da, []int{4}
}
func (m *PaymentHistoryResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PaymentHistoryResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PaymentHistoryResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PaymentHistoryResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PaymentHistoryResp.Merge(m, src)
}
func (m *PaymentHistoryResp) XXX_Size() int {
	return m.Size()
}
func (m *PaymentHistoryResp) XXX_DiscardUnknown() {
	xxx_messageInfo_PaymentHistoryResp.DiscardUnknown(m)
}

var xxx_messageInfo_PaymentHistoryResp proto.InternalMessageInfo

func (m *PaymentHistoryResp) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *PaymentHistoryResp) GetClientId() int64 {
	if m != nil {
		return m.ClientId
	}
	return 0
}

func (m *PaymentHistoryResp) GetSumma() int64 {
	if m != nil {
		return m.Summa
	}
	return 0
}

func (m *PaymentHistoryResp) GetPaymentType() string {
	if m != nil {
		return m.PaymentType
	}
	return ""
}

func (m *PaymentHistoryResp) GetCashboxId() string {
	if m != nil {
		return m.CashboxId
	}
	return ""
}

func (m *PaymentHistoryResp) GetCreatedAt() string {
	if m != nil {
		return m.CreatedAt
	}
	return ""
}

func (m *PaymentHistoryResp) GetUpdatedAt() string {
	if m != nil {
		return m.UpdatedAt
	}
	return ""
}

type GetCashboxReq struct {
	CashboxId            string   `protobuf:"bytes,1,opt,name=cashbox_id,json=cashboxId,proto3" json:"cashbox_id"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetCashboxReq) Reset()         { *m = GetCashboxReq{} }
func (m *GetCashboxReq) String() string { return proto.CompactTextString(m) }
func (*GetCashboxReq) ProtoMessage()    {}
func (*GetCashboxReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_ae32a8d1a528f6da, []int{5}
}
func (m *GetCashboxReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetCashboxReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetCashboxReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetCashboxReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetCashboxReq.Merge(m, src)
}
func (m *GetCashboxReq) XXX_Size() int {
	return m.Size()
}
func (m *GetCashboxReq) XXX_DiscardUnknown() {
	xxx_messageInfo_GetCashboxReq.DiscardUnknown(m)
}

var xxx_messageInfo_GetCashboxReq proto.InternalMessageInfo

func (m *GetCashboxReq) GetCashboxId() string {
	if m != nil {
		return m.CashboxId
	}
	return ""
}

type UpdateCashboxReq struct {
	Id                   string   `protobuf:"bytes,1,opt,name=id,proto3" json:"id"`
	IsPayed              bool     `protobuf:"varint,2,opt,name=is_payed,json=isPayed,proto3" json:"is_payed"`
	PaymentType          string   `protobuf:"bytes,3,opt,name=payment_type,json=paymentType,proto3" json:"payment_type"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UpdateCashboxReq) Reset()         { *m = UpdateCashboxReq{} }
func (m *UpdateCashboxReq) String() string { return proto.CompactTextString(m) }
func (*UpdateCashboxReq) ProtoMessage()    {}
func (*UpdateCashboxReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_ae32a8d1a528f6da, []int{6}
}
func (m *UpdateCashboxReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateCashboxReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateCashboxReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateCashboxReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateCashboxReq.Merge(m, src)
}
func (m *UpdateCashboxReq) XXX_Size() int {
	return m.Size()
}
func (m *UpdateCashboxReq) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateCashboxReq.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateCashboxReq proto.InternalMessageInfo

func (m *UpdateCashboxReq) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *UpdateCashboxReq) GetIsPayed() bool {
	if m != nil {
		return m.IsPayed
	}
	return false
}

func (m *UpdateCashboxReq) GetPaymentType() string {
	if m != nil {
		return m.PaymentType
	}
	return ""
}

type FindCashboxReq struct {
	ClientId             int64    `protobuf:"varint,1,opt,name=client_id,json=clientId,proto3" json:"client_id"`
	Search               string   `protobuf:"bytes,2,opt,name=search,proto3" json:"search"`
	Page                 int64    `protobuf:"varint,3,opt,name=page,proto3" json:"page"`
	Limit                int64    `protobuf:"varint,4,opt,name=limit,proto3" json:"limit"`
	FromDate             string   `protobuf:"bytes,5,opt,name=from_date,json=fromDate,proto3" json:"from_date"`
	ToDate               string   `protobuf:"bytes,6,opt,name=to_date,json=toDate,proto3" json:"to_date"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *FindCashboxReq) Reset()         { *m = FindCashboxReq{} }
func (m *FindCashboxReq) String() string { return proto.CompactTextString(m) }
func (*FindCashboxReq) ProtoMessage()    {}
func (*FindCashboxReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_ae32a8d1a528f6da, []int{7}
}
func (m *FindCashboxReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FindCashboxReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FindCashboxReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FindCashboxReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FindCashboxReq.Merge(m, src)
}
func (m *FindCashboxReq) XXX_Size() int {
	return m.Size()
}
func (m *FindCashboxReq) XXX_DiscardUnknown() {
	xxx_messageInfo_FindCashboxReq.DiscardUnknown(m)
}

var xxx_messageInfo_FindCashboxReq proto.InternalMessageInfo

func (m *FindCashboxReq) GetClientId() int64 {
	if m != nil {
		return m.ClientId
	}
	return 0
}

func (m *FindCashboxReq) GetSearch() string {
	if m != nil {
		return m.Search
	}
	return ""
}

func (m *FindCashboxReq) GetPage() int64 {
	if m != nil {
		return m.Page
	}
	return 0
}

func (m *FindCashboxReq) GetLimit() int64 {
	if m != nil {
		return m.Limit
	}
	return 0
}

func (m *FindCashboxReq) GetFromDate() string {
	if m != nil {
		return m.FromDate
	}
	return ""
}

func (m *FindCashboxReq) GetToDate() string {
	if m != nil {
		return m.ToDate
	}
	return ""
}

type FindCashboxResp struct {
	Cashboxes            []*CashboxResp `protobuf:"bytes,1,rep,name=cashboxes,proto3" json:"cashboxes"`
	Count                int64          `protobuf:"varint,2,opt,name=count,proto3" json:"count"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *FindCashboxResp) Reset()         { *m = FindCashboxResp{} }
func (m *FindCashboxResp) String() string { return proto.CompactTextString(m) }
func (*FindCashboxResp) ProtoMessage()    {}
func (*FindCashboxResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_ae32a8d1a528f6da, []int{8}
}
func (m *FindCashboxResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FindCashboxResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FindCashboxResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FindCashboxResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FindCashboxResp.Merge(m, src)
}
func (m *FindCashboxResp) XXX_Size() int {
	return m.Size()
}
func (m *FindCashboxResp) XXX_DiscardUnknown() {
	xxx_messageInfo_FindCashboxResp.DiscardUnknown(m)
}

var xxx_messageInfo_FindCashboxResp proto.InternalMessageInfo

func (m *FindCashboxResp) GetCashboxes() []*CashboxResp {
	if m != nil {
		return m.Cashboxes
	}
	return nil
}

func (m *FindCashboxResp) GetCount() int64 {
	if m != nil {
		return m.Count
	}
	return 0
}

type QueueFilter struct {
	ServiceId            string   `protobuf:"bytes,1,opt,name=service_id,json=serviceId,proto3" json:"service_id"`
	ServiceType          string   `protobuf:"bytes,2,opt,name=service_type,json=serviceType,proto3" json:"service_type"`
	ClientId             int64    `protobuf:"varint,3,opt,name=client_id,json=clientId,proto3" json:"client_id"`
	Page                 int64    `protobuf:"varint,4,opt,name=page,proto3" json:"page"`
	Limit                int64    `protobuf:"varint,5,opt,name=limit,proto3" json:"limit"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *QueueFilter) Reset()         { *m = QueueFilter{} }
func (m *QueueFilter) String() string { return proto.CompactTextString(m) }
func (*QueueFilter) ProtoMessage()    {}
func (*QueueFilter) Descriptor() ([]byte, []int) {
	return fileDescriptor_ae32a8d1a528f6da, []int{9}
}
func (m *QueueFilter) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueueFilter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueueFilter.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueueFilter) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueueFilter.Merge(m, src)
}
func (m *QueueFilter) XXX_Size() int {
	return m.Size()
}
func (m *QueueFilter) XXX_DiscardUnknown() {
	xxx_messageInfo_QueueFilter.DiscardUnknown(m)
}

var xxx_messageInfo_QueueFilter proto.InternalMessageInfo

func (m *QueueFilter) GetServiceId() string {
	if m != nil {
		return m.ServiceId
	}
	return ""
}

func (m *QueueFilter) GetServiceType() string {
	if m != nil {
		return m.ServiceType
	}
	return ""
}

func (m *QueueFilter) GetClientId() int64 {
	if m != nil {
		return m.ClientId
	}
	return 0
}

func (m *QueueFilter) GetPage() int64 {
	if m != nil {
		return m.Page
	}
	return 0
}

func (m *QueueFilter) GetLimit() int64 {
	if m != nil {
		return m.Limit
	}
	return 0
}

type QueuesResp struct {
	Queues               []*PatientQueueResp `protobuf:"bytes,1,rep,name=queues,proto3" json:"queues"`
	Count                int64               `protobuf:"varint,2,opt,name=count,proto3" json:"count"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *QueuesResp) Reset()         { *m = QueuesResp{} }
func (m *QueuesResp) String() string { return proto.CompactTextString(m) }
func (*QueuesResp) ProtoMessage()    {}
func (*QueuesResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_ae32a8d1a528f6da, []int{10}
}
func (m *QueuesResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueuesResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueuesResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueuesResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueuesResp.Merge(m, src)
}
func (m *QueuesResp) XXX_Size() int {
	return m.Size()
}
func (m *QueuesResp) XXX_DiscardUnknown() {
	xxx_messageInfo_QueuesResp.DiscardUnknown(m)
}

var xxx_messageInfo_QueuesResp proto.InternalMessageInfo

func (m *QueuesResp) GetQueues() []*PatientQueueResp {
	if m != nil {
		return m.Queues
	}
	return nil
}

func (m *QueuesResp) GetCount() int64 {
	if m != nil {
		return m.Count
	}
	return 0
}

type CreateCashboxReq struct {
	Id                   string   `protobuf:"bytes,1,opt,name=id,proto3" json:"id"`
	ClientId             int64    `protobuf:"varint,2,opt,name=client_id,json=clientId,proto3" json:"client_id"`
	IsPayed              bool     `protobuf:"varint,3,opt,name=is_payed,json=isPayed,proto3" json:"is_payed"`
	CashCount            int64    `protobuf:"varint,4,opt,name=cash_count,json=cashCount,proto3" json:"cash_count"`
	PaymentType          string   `protobuf:"bytes,5,opt,name=payment_type,json=paymentType,proto3" json:"payment_type"`
	DoctorsIds           []string `protobuf:"bytes,6,rep,name=doctors_ids,json=doctorsIds,proto3" json:"doctors_ids"`
	LabsIds              []string `protobuf:"bytes,7,rep,name=labs_ids,json=labsIds,proto3" json:"labs_ids"`
	AparatsIds           []string `protobuf:"bytes,8,rep,name=aparats_ids,json=aparatsIds,proto3" json:"aparats_ids"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CreateCashboxReq) Reset()         { *m = CreateCashboxReq{} }
func (m *CreateCashboxReq) String() string { return proto.CompactTextString(m) }
func (*CreateCashboxReq) ProtoMessage()    {}
func (*CreateCashboxReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_ae32a8d1a528f6da, []int{11}
}
func (m *CreateCashboxReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateCashboxReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CreateCashboxReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CreateCashboxReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateCashboxReq.Merge(m, src)
}
func (m *CreateCashboxReq) XXX_Size() int {
	return m.Size()
}
func (m *CreateCashboxReq) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateCashboxReq.DiscardUnknown(m)
}

var xxx_messageInfo_CreateCashboxReq proto.InternalMessageInfo

func (m *CreateCashboxReq) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *CreateCashboxReq) GetClientId() int64 {
	if m != nil {
		return m.ClientId
	}
	return 0
}

func (m *CreateCashboxReq) GetIsPayed() bool {
	if m != nil {
		return m.IsPayed
	}
	return false
}

func (m *CreateCashboxReq) GetCashCount() int64 {
	if m != nil {
		return m.CashCount
	}
	return 0
}

func (m *CreateCashboxReq) GetPaymentType() string {
	if m != nil {
		return m.PaymentType
	}
	return ""
}

func (m *CreateCashboxReq) GetDoctorsIds() []string {
	if m != nil {
		return m.DoctorsIds
	}
	return nil
}

func (m *CreateCashboxReq) GetLabsIds() []string {
	if m != nil {
		return m.LabsIds
	}
	return nil
}

func (m *CreateCashboxReq) GetAparatsIds() []string {
	if m != nil {
		return m.AparatsIds
	}
	return nil
}

type CashboxResp struct {
	Id                   string   `protobuf:"bytes,1,opt,name=id,proto3" json:"id"`
	ClientId             int64    `protobuf:"varint,2,opt,name=client_id,json=clientId,proto3" json:"client_id"`
	Summa                int64    `protobuf:"varint,3,opt,name=summa,proto3" json:"summa"`
	IsPayed              bool     `protobuf:"varint,4,opt,name=is_payed,json=isPayed,proto3" json:"is_payed"`
	CashCount            int64    `protobuf:"varint,5,opt,name=cash_count,json=cashCount,proto3" json:"cash_count"`
	PaymentType          string   `protobuf:"bytes,6,opt,name=payment_type,json=paymentType,proto3" json:"payment_type"`
	DoctorsIds           []string `protobuf:"bytes,7,rep,name=doctors_ids,json=doctorsIds,proto3" json:"doctors_ids"`
	LabsIds              []string `protobuf:"bytes,8,rep,name=labs_ids,json=labsIds,proto3" json:"labs_ids"`
	AparatsIds           []string `protobuf:"bytes,9,rep,name=aparats_ids,json=aparatsIds,proto3" json:"aparats_ids"`
	CreatedAt            string   `protobuf:"bytes,10,opt,name=created_at,json=createdAt,proto3" json:"created_at"`
	UpdatedAt            string   `protobuf:"bytes,11,opt,name=updated_at,json=updatedAt,proto3" json:"updated_at"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CashboxResp) Reset()         { *m = CashboxResp{} }
func (m *CashboxResp) String() string { return proto.CompactTextString(m) }
func (*CashboxResp) ProtoMessage()    {}
func (*CashboxResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_ae32a8d1a528f6da, []int{12}
}
func (m *CashboxResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CashboxResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CashboxResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CashboxResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CashboxResp.Merge(m, src)
}
func (m *CashboxResp) XXX_Size() int {
	return m.Size()
}
func (m *CashboxResp) XXX_DiscardUnknown() {
	xxx_messageInfo_CashboxResp.DiscardUnknown(m)
}

var xxx_messageInfo_CashboxResp proto.InternalMessageInfo

func (m *CashboxResp) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *CashboxResp) GetClientId() int64 {
	if m != nil {
		return m.ClientId
	}
	return 0
}

func (m *CashboxResp) GetSumma() int64 {
	if m != nil {
		return m.Summa
	}
	return 0
}

func (m *CashboxResp) GetIsPayed() bool {
	if m != nil {
		return m.IsPayed
	}
	return false
}

func (m *CashboxResp) GetCashCount() int64 {
	if m != nil {
		return m.CashCount
	}
	return 0
}

func (m *CashboxResp) GetPaymentType() string {
	if m != nil {
		return m.PaymentType
	}
	return ""
}

func (m *CashboxResp) GetDoctorsIds() []string {
	if m != nil {
		return m.DoctorsIds
	}
	return nil
}

func (m *CashboxResp) GetLabsIds() []string {
	if m != nil {
		return m.LabsIds
	}
	return nil
}

func (m *CashboxResp) GetAparatsIds() []string {
	if m != nil {
		return m.AparatsIds
	}
	return nil
}

func (m *CashboxResp) GetCreatedAt() string {
	if m != nil {
		return m.CreatedAt
	}
	return ""
}

func (m *CashboxResp) GetUpdatedAt() string {
	if m != nil {
		return m.UpdatedAt
	}
	return ""
}

type UpdateQueueReq struct {
	ClientId             int64    `protobuf:"varint,1,opt,name=client_id,json=clientId,proto3" json:"client_id"`
	ServiceId            string   `protobuf:"bytes,2,opt,name=service_id,json=serviceId,proto3" json:"service_id"`
	ServiceType          string   `protobuf:"bytes,3,opt,name=service_type,json=serviceType,proto3" json:"service_type"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UpdateQueueReq) Reset()         { *m = UpdateQueueReq{} }
func (m *UpdateQueueReq) String() string { return proto.CompactTextString(m) }
func (*UpdateQueueReq) ProtoMessage()    {}
func (*UpdateQueueReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_ae32a8d1a528f6da, []int{13}
}
func (m *UpdateQueueReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateQueueReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateQueueReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateQueueReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateQueueReq.Merge(m, src)
}
func (m *UpdateQueueReq) XXX_Size() int {
	return m.Size()
}
func (m *UpdateQueueReq) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateQueueReq.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateQueueReq proto.InternalMessageInfo

func (m *UpdateQueueReq) GetClientId() int64 {
	if m != nil {
		return m.ClientId
	}
	return 0
}

func (m *UpdateQueueReq) GetServiceId() string {
	if m != nil {
		return m.ServiceId
	}
	return ""
}

func (m *UpdateQueueReq) GetServiceType() string {
	if m != nil {
		return m.ServiceType
	}
	return ""
}

type CreatePatientQueueReq struct {
	Id                   string   `protobuf:"bytes,1,opt,name=id,proto3" json:"id"`
	ClientId             int64    `protobuf:"varint,2,opt,name=client_id,json=clientId,proto3" json:"client_id"`
	QueueNumber          int64    `protobuf:"varint,3,opt,name=queue_number,json=queueNumber,proto3" json:"queue_number"`
	ServiceId            string   `protobuf:"bytes,4,opt,name=service_id,json=serviceId,proto3" json:"service_id"`
	ServiceType          string   `protobuf:"bytes,5,opt,name=service_type,json=serviceType,proto3" json:"service_type"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CreatePatientQueueReq) Reset()         { *m = CreatePatientQueueReq{} }
func (m *CreatePatientQueueReq) String() string { return proto.CompactTextString(m) }
func (*CreatePatientQueueReq) ProtoMessage()    {}
func (*CreatePatientQueueReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_ae32a8d1a528f6da, []int{14}
}
func (m *CreatePatientQueueReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreatePatientQueueReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CreatePatientQueueReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CreatePatientQueueReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreatePatientQueueReq.Merge(m, src)
}
func (m *CreatePatientQueueReq) XXX_Size() int {
	return m.Size()
}
func (m *CreatePatientQueueReq) XXX_DiscardUnknown() {
	xxx_messageInfo_CreatePatientQueueReq.DiscardUnknown(m)
}

var xxx_messageInfo_CreatePatientQueueReq proto.InternalMessageInfo

func (m *CreatePatientQueueReq) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *CreatePatientQueueReq) GetClientId() int64 {
	if m != nil {
		return m.ClientId
	}
	return 0
}

func (m *CreatePatientQueueReq) GetQueueNumber() int64 {
	if m != nil {
		return m.QueueNumber
	}
	return 0
}

func (m *CreatePatientQueueReq) GetServiceId() string {
	if m != nil {
		return m.ServiceId
	}
	return ""
}

func (m *CreatePatientQueueReq) GetServiceType() string {
	if m != nil {
		return m.ServiceType
	}
	return ""
}

type QueueNumber struct {
	QueueNumber          int64    `protobuf:"varint,1,opt,name=queue_number,json=queueNumber,proto3" json:"queue_number"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *QueueNumber) Reset()         { *m = QueueNumber{} }
func (m *QueueNumber) String() string { return proto.CompactTextString(m) }
func (*QueueNumber) ProtoMessage()    {}
func (*QueueNumber) Descriptor() ([]byte, []int) {
	return fileDescriptor_ae32a8d1a528f6da, []int{15}
}
func (m *QueueNumber) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueueNumber) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueueNumber.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueueNumber) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueueNumber.Merge(m, src)
}
func (m *QueueNumber) XXX_Size() int {
	return m.Size()
}
func (m *QueueNumber) XXX_DiscardUnknown() {
	xxx_messageInfo_QueueNumber.DiscardUnknown(m)
}

var xxx_messageInfo_QueueNumber proto.InternalMessageInfo

func (m *QueueNumber) GetQueueNumber() int64 {
	if m != nil {
		return m.QueueNumber
	}
	return 0
}

type CheckQueueReq struct {
	ServiceId            string   `protobuf:"bytes,1,opt,name=service_id,json=serviceId,proto3" json:"service_id"`
	ServiceType          string   `protobuf:"bytes,2,opt,name=service_type,json=serviceType,proto3" json:"service_type"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CheckQueueReq) Reset()         { *m = CheckQueueReq{} }
func (m *CheckQueueReq) String() string { return proto.CompactTextString(m) }
func (*CheckQueueReq) ProtoMessage()    {}
func (*CheckQueueReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_ae32a8d1a528f6da, []int{16}
}
func (m *CheckQueueReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CheckQueueReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CheckQueueReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CheckQueueReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CheckQueueReq.Merge(m, src)
}
func (m *CheckQueueReq) XXX_Size() int {
	return m.Size()
}
func (m *CheckQueueReq) XXX_DiscardUnknown() {
	xxx_messageInfo_CheckQueueReq.DiscardUnknown(m)
}

var xxx_messageInfo_CheckQueueReq proto.InternalMessageInfo

func (m *CheckQueueReq) GetServiceId() string {
	if m != nil {
		return m.ServiceId
	}
	return ""
}

func (m *CheckQueueReq) GetServiceType() string {
	if m != nil {
		return m.ServiceType
	}
	return ""
}

type PatientQueueResp struct {
	Id                   string   `protobuf:"bytes,1,opt,name=id,proto3" json:"id"`
	ClientId             int64    `protobuf:"varint,2,opt,name=client_id,json=clientId,proto3" json:"client_id"`
	QueueNumber          int64    `protobuf:"varint,3,opt,name=queue_number,json=queueNumber,proto3" json:"queue_number"`
	ServiceId            string   `protobuf:"bytes,4,opt,name=service_id,json=serviceId,proto3" json:"service_id"`
	ServiceType          string   `protobuf:"bytes,5,opt,name=service_type,json=serviceType,proto3" json:"service_type"`
	TurnPassed           bool     `protobuf:"varint,6,opt,name=turn_passed,json=turnPassed,proto3" json:"turn_passed"`
	CreatedAt            string   `protobuf:"bytes,7,opt,name=created_at,json=createdAt,proto3" json:"created_at"`
	UpdatedAt            string   `protobuf:"bytes,8,opt,name=updated_at,json=updatedAt,proto3" json:"updated_at"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PatientQueueResp) Reset()         { *m = PatientQueueResp{} }
func (m *PatientQueueResp) String() string { return proto.CompactTextString(m) }
func (*PatientQueueResp) ProtoMessage()    {}
func (*PatientQueueResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_ae32a8d1a528f6da, []int{17}
}
func (m *PatientQueueResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PatientQueueResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PatientQueueResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PatientQueueResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PatientQueueResp.Merge(m, src)
}
func (m *PatientQueueResp) XXX_Size() int {
	return m.Size()
}
func (m *PatientQueueResp) XXX_DiscardUnknown() {
	xxx_messageInfo_PatientQueueResp.DiscardUnknown(m)
}

var xxx_messageInfo_PatientQueueResp proto.InternalMessageInfo

func (m *PatientQueueResp) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *PatientQueueResp) GetClientId() int64 {
	if m != nil {
		return m.ClientId
	}
	return 0
}

func (m *PatientQueueResp) GetQueueNumber() int64 {
	if m != nil {
		return m.QueueNumber
	}
	return 0
}

func (m *PatientQueueResp) GetServiceId() string {
	if m != nil {
		return m.ServiceId
	}
	return ""
}

func (m *PatientQueueResp) GetServiceType() string {
	if m != nil {
		return m.ServiceType
	}
	return ""
}

func (m *PatientQueueResp) GetTurnPassed() bool {
	if m != nil {
		return m.TurnPassed
	}
	return false
}

func (m *PatientQueueResp) GetCreatedAt() string {
	if m != nil {
		return m.CreatedAt
	}
	return ""
}

func (m *PatientQueueResp) GetUpdatedAt() string {
	if m != nil {
		return m.UpdatedAt
	}
	return ""
}

type FindCashBoxReq struct {
	Limit                int32    `protobuf:"varint,1,opt,name=limit,proto3" json:"limit"`
	Page                 int32    `protobuf:"varint,2,opt,name=page,proto3" json:"page"`
	Search               string   `protobuf:"bytes,3,opt,name=search,proto3" json:"search"`
	FromDate             string   `protobuf:"bytes,4,opt,name=from_date,json=fromDate,proto3" json:"from_date"`
	ToDate               string   `protobuf:"bytes,5,opt,name=to_date,json=toDate,proto3" json:"to_date"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *FindCashBoxReq) Reset()         { *m = FindCashBoxReq{} }
func (m *FindCashBoxReq) String() string { return proto.CompactTextString(m) }
func (*FindCashBoxReq) ProtoMessage()    {}
func (*FindCashBoxReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_ae32a8d1a528f6da, []int{18}
}
func (m *FindCashBoxReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FindCashBoxReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FindCashBoxReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FindCashBoxReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FindCashBoxReq.Merge(m, src)
}
func (m *FindCashBoxReq) XXX_Size() int {
	return m.Size()
}
func (m *FindCashBoxReq) XXX_DiscardUnknown() {
	xxx_messageInfo_FindCashBoxReq.DiscardUnknown(m)
}

var xxx_messageInfo_FindCashBoxReq proto.InternalMessageInfo

func (m *FindCashBoxReq) GetLimit() int32 {
	if m != nil {
		return m.Limit
	}
	return 0
}

func (m *FindCashBoxReq) GetPage() int32 {
	if m != nil {
		return m.Page
	}
	return 0
}

func (m *FindCashBoxReq) GetSearch() string {
	if m != nil {
		return m.Search
	}
	return ""
}

func (m *FindCashBoxReq) GetFromDate() string {
	if m != nil {
		return m.FromDate
	}
	return ""
}

func (m *FindCashBoxReq) GetToDate() string {
	if m != nil {
		return m.ToDate
	}
	return ""
}

type PatientsGetKassaResponse struct {
	ClientId             string   `protobuf:"bytes,1,opt,name=client_id,json=clientId,proto3" json:"client_id"`
	FirstName            string   `protobuf:"bytes,2,opt,name=first_name,json=firstName,proto3" json:"first_name"`
	LastName             string   `protobuf:"bytes,3,opt,name=last_name,json=lastName,proto3" json:"last_name"`
	Summa                float64  `protobuf:"fixed64,4,opt,name=summa,proto3" json:"summa"`
	PaymentType          string   `protobuf:"bytes,5,opt,name=payment_type,json=paymentType,proto3" json:"payment_type"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PatientsGetKassaResponse) Reset()         { *m = PatientsGetKassaResponse{} }
func (m *PatientsGetKassaResponse) String() string { return proto.CompactTextString(m) }
func (*PatientsGetKassaResponse) ProtoMessage()    {}
func (*PatientsGetKassaResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_ae32a8d1a528f6da, []int{19}
}
func (m *PatientsGetKassaResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PatientsGetKassaResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PatientsGetKassaResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PatientsGetKassaResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PatientsGetKassaResponse.Merge(m, src)
}
func (m *PatientsGetKassaResponse) XXX_Size() int {
	return m.Size()
}
func (m *PatientsGetKassaResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_PatientsGetKassaResponse.DiscardUnknown(m)
}

var xxx_messageInfo_PatientsGetKassaResponse proto.InternalMessageInfo

func (m *PatientsGetKassaResponse) GetClientId() string {
	if m != nil {
		return m.ClientId
	}
	return ""
}

func (m *PatientsGetKassaResponse) GetFirstName() string {
	if m != nil {
		return m.FirstName
	}
	return ""
}

func (m *PatientsGetKassaResponse) GetLastName() string {
	if m != nil {
		return m.LastName
	}
	return ""
}

func (m *PatientsGetKassaResponse) GetSumma() float64 {
	if m != nil {
		return m.Summa
	}
	return 0
}

func (m *PatientsGetKassaResponse) GetPaymentType() string {
	if m != nil {
		return m.PaymentType
	}
	return ""
}

type PatientsGetKassaReq struct {
	Limit                int64    `protobuf:"varint,1,opt,name=limit,proto3" json:"limit"`
	Page                 int64    `protobuf:"varint,2,opt,name=page,proto3" json:"page"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PatientsGetKassaReq) Reset()         { *m = PatientsGetKassaReq{} }
func (m *PatientsGetKassaReq) String() string { return proto.CompactTextString(m) }
func (*PatientsGetKassaReq) ProtoMessage()    {}
func (*PatientsGetKassaReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_ae32a8d1a528f6da, []int{20}
}
func (m *PatientsGetKassaReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PatientsGetKassaReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PatientsGetKassaReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PatientsGetKassaReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PatientsGetKassaReq.Merge(m, src)
}
func (m *PatientsGetKassaReq) XXX_Size() int {
	return m.Size()
}
func (m *PatientsGetKassaReq) XXX_DiscardUnknown() {
	xxx_messageInfo_PatientsGetKassaReq.DiscardUnknown(m)
}

var xxx_messageInfo_PatientsGetKassaReq proto.InternalMessageInfo

func (m *PatientsGetKassaReq) GetLimit() int64 {
	if m != nil {
		return m.Limit
	}
	return 0
}

func (m *PatientsGetKassaReq) GetPage() int64 {
	if m != nil {
		return m.Page
	}
	return 0
}

type PatientsFilter struct {
	ClientId             int64    `protobuf:"varint,1,opt,name=client_id,json=clientId,proto3" json:"client_id"`
	Fullname             string   `protobuf:"bytes,2,opt,name=fullname,proto3" json:"fullname"`
	FromDate             string   `protobuf:"bytes,3,opt,name=from_date,json=fromDate,proto3" json:"from_date"`
	ToDate               string   `protobuf:"bytes,4,opt,name=to_date,json=toDate,proto3" json:"to_date"`
	Page                 int32    `protobuf:"varint,5,opt,name=page,proto3" json:"page"`
	Limit                int32    `protobuf:"varint,6,opt,name=limit,proto3" json:"limit"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PatientsFilter) Reset()         { *m = PatientsFilter{} }
func (m *PatientsFilter) String() string { return proto.CompactTextString(m) }
func (*PatientsFilter) ProtoMessage()    {}
func (*PatientsFilter) Descriptor() ([]byte, []int) {
	return fileDescriptor_ae32a8d1a528f6da, []int{21}
}
func (m *PatientsFilter) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PatientsFilter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PatientsFilter.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PatientsFilter) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PatientsFilter.Merge(m, src)
}
func (m *PatientsFilter) XXX_Size() int {
	return m.Size()
}
func (m *PatientsFilter) XXX_DiscardUnknown() {
	xxx_messageInfo_PatientsFilter.DiscardUnknown(m)
}

var xxx_messageInfo_PatientsFilter proto.InternalMessageInfo

func (m *PatientsFilter) GetClientId() int64 {
	if m != nil {
		return m.ClientId
	}
	return 0
}

func (m *PatientsFilter) GetFullname() string {
	if m != nil {
		return m.Fullname
	}
	return ""
}

func (m *PatientsFilter) GetFromDate() string {
	if m != nil {
		return m.FromDate
	}
	return ""
}

func (m *PatientsFilter) GetToDate() string {
	if m != nil {
		return m.ToDate
	}
	return ""
}

func (m *PatientsFilter) GetPage() int32 {
	if m != nil {
		return m.Page
	}
	return 0
}

func (m *PatientsFilter) GetLimit() int32 {
	if m != nil {
		return m.Limit
	}
	return 0
}

type AddServiceReq struct {
	DoctorIds            []string `protobuf:"bytes,1,rep,name=doctor_ids,json=doctorIds,proto3" json:"doctor_ids"`
	LabIds               []string `protobuf:"bytes,2,rep,name=lab_ids,json=labIds,proto3" json:"lab_ids"`
	AparatIds            []string `protobuf:"bytes,3,rep,name=aparat_ids,json=aparatIds,proto3" json:"aparat_ids"`
	ClientId             int64    `protobuf:"varint,4,opt,name=client_id,json=clientId,proto3" json:"client_id"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AddServiceReq) Reset()         { *m = AddServiceReq{} }
func (m *AddServiceReq) String() string { return proto.CompactTextString(m) }
func (*AddServiceReq) ProtoMessage()    {}
func (*AddServiceReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_ae32a8d1a528f6da, []int{22}
}
func (m *AddServiceReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AddServiceReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AddServiceReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AddServiceReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AddServiceReq.Merge(m, src)
}
func (m *AddServiceReq) XXX_Size() int {
	return m.Size()
}
func (m *AddServiceReq) XXX_DiscardUnknown() {
	xxx_messageInfo_AddServiceReq.DiscardUnknown(m)
}

var xxx_messageInfo_AddServiceReq proto.InternalMessageInfo

func (m *AddServiceReq) GetDoctorIds() []string {
	if m != nil {
		return m.DoctorIds
	}
	return nil
}

func (m *AddServiceReq) GetLabIds() []string {
	if m != nil {
		return m.LabIds
	}
	return nil
}

func (m *AddServiceReq) GetAparatIds() []string {
	if m != nil {
		return m.AparatIds
	}
	return nil
}

func (m *AddServiceReq) GetClientId() int64 {
	if m != nil {
		return m.ClientId
	}
	return 0
}

type CashStorage struct {
	Id                   string   `protobuf:"bytes,1,opt,name=id,proto3" json:"id"`
	ClientId             int64    `protobuf:"varint,2,opt,name=client_id,json=clientId,proto3" json:"client_id"`
	Summa                float64  `protobuf:"fixed64,3,opt,name=summa,proto3" json:"summa"`
	IsPayed              bool     `protobuf:"varint,4,opt,name=is_payed,json=isPayed,proto3" json:"is_payed"`
	CashCount            int64    `protobuf:"varint,5,opt,name=cash_count,json=cashCount,proto3" json:"cash_count"`
	PaymentType          string   `protobuf:"bytes,6,opt,name=payment_type,json=paymentType,proto3" json:"payment_type"`
	DoctorIds            []string `protobuf:"bytes,7,rep,name=doctor_ids,json=doctorIds,proto3" json:"doctor_ids"`
	LabIds               []string `protobuf:"bytes,8,rep,name=lab_ids,json=labIds,proto3" json:"lab_ids"`
	AparatIds            []string `protobuf:"bytes,9,rep,name=aparat_ids,json=aparatIds,proto3" json:"aparat_ids"`
	CreatedAt            string   `protobuf:"bytes,10,opt,name=created_at,json=createdAt,proto3" json:"created_at"`
	UpdatedAt            string   `protobuf:"bytes,11,opt,name=updated_at,json=updatedAt,proto3" json:"updated_at"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CashStorage) Reset()         { *m = CashStorage{} }
func (m *CashStorage) String() string { return proto.CompactTextString(m) }
func (*CashStorage) ProtoMessage()    {}
func (*CashStorage) Descriptor() ([]byte, []int) {
	return fileDescriptor_ae32a8d1a528f6da, []int{23}
}
func (m *CashStorage) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CashStorage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CashStorage.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CashStorage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CashStorage.Merge(m, src)
}
func (m *CashStorage) XXX_Size() int {
	return m.Size()
}
func (m *CashStorage) XXX_DiscardUnknown() {
	xxx_messageInfo_CashStorage.DiscardUnknown(m)
}

var xxx_messageInfo_CashStorage proto.InternalMessageInfo

func (m *CashStorage) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *CashStorage) GetClientId() int64 {
	if m != nil {
		return m.ClientId
	}
	return 0
}

func (m *CashStorage) GetSumma() float64 {
	if m != nil {
		return m.Summa
	}
	return 0
}

func (m *CashStorage) GetIsPayed() bool {
	if m != nil {
		return m.IsPayed
	}
	return false
}

func (m *CashStorage) GetCashCount() int64 {
	if m != nil {
		return m.CashCount
	}
	return 0
}

func (m *CashStorage) GetPaymentType() string {
	if m != nil {
		return m.PaymentType
	}
	return ""
}

func (m *CashStorage) GetDoctorIds() []string {
	if m != nil {
		return m.DoctorIds
	}
	return nil
}

func (m *CashStorage) GetLabIds() []string {
	if m != nil {
		return m.LabIds
	}
	return nil
}

func (m *CashStorage) GetAparatIds() []string {
	if m != nil {
		return m.AparatIds
	}
	return nil
}

func (m *CashStorage) GetCreatedAt() string {
	if m != nil {
		return m.CreatedAt
	}
	return ""
}

func (m *CashStorage) GetUpdatedAt() string {
	if m != nil {
		return m.UpdatedAt
	}
	return ""
}

type PatientDebtCreateReq struct {
	PatientId            string   `protobuf:"bytes,1,opt,name=patient_id,json=patientId,proto3" json:"patient_id"`
	Amount               float32  `protobuf:"fixed32,2,opt,name=amount,proto3" json:"amount"`
	TermDate             string   `protobuf:"bytes,3,opt,name=term_date,json=termDate,proto3" json:"term_date"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PatientDebtCreateReq) Reset()         { *m = PatientDebtCreateReq{} }
func (m *PatientDebtCreateReq) String() string { return proto.CompactTextString(m) }
func (*PatientDebtCreateReq) ProtoMessage()    {}
func (*PatientDebtCreateReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_ae32a8d1a528f6da, []int{24}
}
func (m *PatientDebtCreateReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PatientDebtCreateReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PatientDebtCreateReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PatientDebtCreateReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PatientDebtCreateReq.Merge(m, src)
}
func (m *PatientDebtCreateReq) XXX_Size() int {
	return m.Size()
}
func (m *PatientDebtCreateReq) XXX_DiscardUnknown() {
	xxx_messageInfo_PatientDebtCreateReq.DiscardUnknown(m)
}

var xxx_messageInfo_PatientDebtCreateReq proto.InternalMessageInfo

func (m *PatientDebtCreateReq) GetPatientId() string {
	if m != nil {
		return m.PatientId
	}
	return ""
}

func (m *PatientDebtCreateReq) GetAmount() float32 {
	if m != nil {
		return m.Amount
	}
	return 0
}

func (m *PatientDebtCreateReq) GetTermDate() string {
	if m != nil {
		return m.TermDate
	}
	return ""
}

type PatientDebt struct {
	Id                   string   `protobuf:"bytes,1,opt,name=id,proto3" json:"id"`
	PatientId            string   `protobuf:"bytes,2,opt,name=patient_id,json=patientId,proto3" json:"patient_id"`
	Amount               float32  `protobuf:"fixed32,3,opt,name=amount,proto3" json:"amount"`
	TermDate             string   `protobuf:"bytes,4,opt,name=term_date,json=termDate,proto3" json:"term_date"`
	CreatedAt            string   `protobuf:"bytes,5,opt,name=created_at,json=createdAt,proto3" json:"created_at"`
	UpdatedAt            string   `protobuf:"bytes,6,opt,name=updated_at,json=updatedAt,proto3" json:"updated_at"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PatientDebt) Reset()         { *m = PatientDebt{} }
func (m *PatientDebt) String() string { return proto.CompactTextString(m) }
func (*PatientDebt) ProtoMessage()    {}
func (*PatientDebt) Descriptor() ([]byte, []int) {
	return fileDescriptor_ae32a8d1a528f6da, []int{25}
}
func (m *PatientDebt) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PatientDebt) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PatientDebt.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PatientDebt) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PatientDebt.Merge(m, src)
}
func (m *PatientDebt) XXX_Size() int {
	return m.Size()
}
func (m *PatientDebt) XXX_DiscardUnknown() {
	xxx_messageInfo_PatientDebt.DiscardUnknown(m)
}

var xxx_messageInfo_PatientDebt proto.InternalMessageInfo

func (m *PatientDebt) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *PatientDebt) GetPatientId() string {
	if m != nil {
		return m.PatientId
	}
	return ""
}

func (m *PatientDebt) GetAmount() float32 {
	if m != nil {
		return m.Amount
	}
	return 0
}

func (m *PatientDebt) GetTermDate() string {
	if m != nil {
		return m.TermDate
	}
	return ""
}

func (m *PatientDebt) GetCreatedAt() string {
	if m != nil {
		return m.CreatedAt
	}
	return ""
}

func (m *PatientDebt) GetUpdatedAt() string {
	if m != nil {
		return m.UpdatedAt
	}
	return ""
}

type CreateAnalysisesReq struct {
	ClientPhoneNumber    string   `protobuf:"bytes,1,opt,name=client_phone_number,json=clientPhoneNumber,proto3" json:"client_phone_number"`
	AnalysisName         string   `protobuf:"bytes,2,opt,name=analysis_name,json=analysisName,proto3" json:"analysis_name"`
	AnalysisUrl          string   `protobuf:"bytes,3,opt,name=analysis_url,json=analysisUrl,proto3" json:"analysis_url"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CreateAnalysisesReq) Reset()         { *m = CreateAnalysisesReq{} }
func (m *CreateAnalysisesReq) String() string { return proto.CompactTextString(m) }
func (*CreateAnalysisesReq) ProtoMessage()    {}
func (*CreateAnalysisesReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_ae32a8d1a528f6da, []int{26}
}
func (m *CreateAnalysisesReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateAnalysisesReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CreateAnalysisesReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CreateAnalysisesReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateAnalysisesReq.Merge(m, src)
}
func (m *CreateAnalysisesReq) XXX_Size() int {
	return m.Size()
}
func (m *CreateAnalysisesReq) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateAnalysisesReq.DiscardUnknown(m)
}

var xxx_messageInfo_CreateAnalysisesReq proto.InternalMessageInfo

func (m *CreateAnalysisesReq) GetClientPhoneNumber() string {
	if m != nil {
		return m.ClientPhoneNumber
	}
	return ""
}

func (m *CreateAnalysisesReq) GetAnalysisName() string {
	if m != nil {
		return m.AnalysisName
	}
	return ""
}

func (m *CreateAnalysisesReq) GetAnalysisUrl() string {
	if m != nil {
		return m.AnalysisUrl
	}
	return ""
}

type CreateDoctorReportReq struct {
	DoctorId             string   `protobuf:"bytes,1,opt,name=doctor_id,json=doctorId,proto3" json:"doctor_id"`
	Text                 string   `protobuf:"bytes,2,opt,name=text,proto3" json:"text"`
	PatientId            string   `protobuf:"bytes,3,opt,name=patient_id,json=patientId,proto3" json:"patient_id"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CreateDoctorReportReq) Reset()         { *m = CreateDoctorReportReq{} }
func (m *CreateDoctorReportReq) String() string { return proto.CompactTextString(m) }
func (*CreateDoctorReportReq) ProtoMessage()    {}
func (*CreateDoctorReportReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_ae32a8d1a528f6da, []int{27}
}
func (m *CreateDoctorReportReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateDoctorReportReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CreateDoctorReportReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CreateDoctorReportReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateDoctorReportReq.Merge(m, src)
}
func (m *CreateDoctorReportReq) XXX_Size() int {
	return m.Size()
}
func (m *CreateDoctorReportReq) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateDoctorReportReq.DiscardUnknown(m)
}

var xxx_messageInfo_CreateDoctorReportReq proto.InternalMessageInfo

func (m *CreateDoctorReportReq) GetDoctorId() string {
	if m != nil {
		return m.DoctorId
	}
	return ""
}

func (m *CreateDoctorReportReq) GetText() string {
	if m != nil {
		return m.Text
	}
	return ""
}

func (m *CreateDoctorReportReq) GetPatientId() string {
	if m != nil {
		return m.PatientId
	}
	return ""
}

type AddServiceToCleintReq struct {
	PatientId            string   `protobuf:"bytes,1,opt,name=patient_id,json=patientId,proto3" json:"patient_id"`
	ServiceId            string   `protobuf:"bytes,2,opt,name=service_id,json=serviceId,proto3" json:"service_id"`
	ServiceType          string   `protobuf:"bytes,3,opt,name=service_type,json=serviceType,proto3" json:"service_type"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AddServiceToCleintReq) Reset()         { *m = AddServiceToCleintReq{} }
func (m *AddServiceToCleintReq) String() string { return proto.CompactTextString(m) }
func (*AddServiceToCleintReq) ProtoMessage()    {}
func (*AddServiceToCleintReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_ae32a8d1a528f6da, []int{28}
}
func (m *AddServiceToCleintReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AddServiceToCleintReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AddServiceToCleintReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AddServiceToCleintReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AddServiceToCleintReq.Merge(m, src)
}
func (m *AddServiceToCleintReq) XXX_Size() int {
	return m.Size()
}
func (m *AddServiceToCleintReq) XXX_DiscardUnknown() {
	xxx_messageInfo_AddServiceToCleintReq.DiscardUnknown(m)
}

var xxx_messageInfo_AddServiceToCleintReq proto.InternalMessageInfo

func (m *AddServiceToCleintReq) GetPatientId() string {
	if m != nil {
		return m.PatientId
	}
	return ""
}

func (m *AddServiceToCleintReq) GetServiceId() string {
	if m != nil {
		return m.ServiceId
	}
	return ""
}

func (m *AddServiceToCleintReq) GetServiceType() string {
	if m != nil {
		return m.ServiceType
	}
	return ""
}

type PatientsGetInfoFilter struct {
	ClientId             int64    `protobuf:"varint,1,opt,name=client_id,json=clientId,proto3" json:"client_id"`
	PhoneNumber          string   `protobuf:"bytes,2,opt,name=phone_number,json=phoneNumber,proto3" json:"phone_number"`
	Fullname             string   `protobuf:"bytes,3,opt,name=fullname,proto3" json:"fullname"`
	FromDate             string   `protobuf:"bytes,4,opt,name=from_date,json=fromDate,proto3" json:"from_date"`
	ToDate               string   `protobuf:"bytes,5,opt,name=to_date,json=toDate,proto3" json:"to_date"`
	Page                 int32    `protobuf:"varint,6,opt,name=page,proto3" json:"page"`
	Limit                int32    `protobuf:"varint,7,opt,name=limit,proto3" json:"limit"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PatientsGetInfoFilter) Reset()         { *m = PatientsGetInfoFilter{} }
func (m *PatientsGetInfoFilter) String() string { return proto.CompactTextString(m) }
func (*PatientsGetInfoFilter) ProtoMessage()    {}
func (*PatientsGetInfoFilter) Descriptor() ([]byte, []int) {
	return fileDescriptor_ae32a8d1a528f6da, []int{29}
}
func (m *PatientsGetInfoFilter) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PatientsGetInfoFilter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PatientsGetInfoFilter.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PatientsGetInfoFilter) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PatientsGetInfoFilter.Merge(m, src)
}
func (m *PatientsGetInfoFilter) XXX_Size() int {
	return m.Size()
}
func (m *PatientsGetInfoFilter) XXX_DiscardUnknown() {
	xxx_messageInfo_PatientsGetInfoFilter.DiscardUnknown(m)
}

var xxx_messageInfo_PatientsGetInfoFilter proto.InternalMessageInfo

func (m *PatientsGetInfoFilter) GetClientId() int64 {
	if m != nil {
		return m.ClientId
	}
	return 0
}

func (m *PatientsGetInfoFilter) GetPhoneNumber() string {
	if m != nil {
		return m.PhoneNumber
	}
	return ""
}

func (m *PatientsGetInfoFilter) GetFullname() string {
	if m != nil {
		return m.Fullname
	}
	return ""
}

func (m *PatientsGetInfoFilter) GetFromDate() string {
	if m != nil {
		return m.FromDate
	}
	return ""
}

func (m *PatientsGetInfoFilter) GetToDate() string {
	if m != nil {
		return m.ToDate
	}
	return ""
}

func (m *PatientsGetInfoFilter) GetPage() int32 {
	if m != nil {
		return m.Page
	}
	return 0
}

func (m *PatientsGetInfoFilter) GetLimit() int32 {
	if m != nil {
		return m.Limit
	}
	return 0
}

type PatientId struct {
	ClientId             int64    `protobuf:"varint,1,opt,name=client_id,json=clientId,proto3" json:"client_id"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PatientId) Reset()         { *m = PatientId{} }
func (m *PatientId) String() string { return proto.CompactTextString(m) }
func (*PatientId) ProtoMessage()    {}
func (*PatientId) Descriptor() ([]byte, []int) {
	return fileDescriptor_ae32a8d1a528f6da, []int{30}
}
func (m *PatientId) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PatientId) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PatientId.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PatientId) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PatientId.Merge(m, src)
}
func (m *PatientId) XXX_Size() int {
	return m.Size()
}
func (m *PatientId) XXX_DiscardUnknown() {
	xxx_messageInfo_PatientId.DiscardUnknown(m)
}

var xxx_messageInfo_PatientId proto.InternalMessageInfo

func (m *PatientId) GetClientId() int64 {
	if m != nil {
		return m.ClientId
	}
	return 0
}

type PatientPhoneNumber struct {
	PhoneNumber          string   `protobuf:"bytes,1,opt,name=phone_number,json=phoneNumber,proto3" json:"phone_number"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PatientPhoneNumber) Reset()         { *m = PatientPhoneNumber{} }
func (m *PatientPhoneNumber) String() string { return proto.CompactTextString(m) }
func (*PatientPhoneNumber) ProtoMessage()    {}
func (*PatientPhoneNumber) Descriptor() ([]byte, []int) {
	return fileDescriptor_ae32a8d1a528f6da, []int{31}
}
func (m *PatientPhoneNumber) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PatientPhoneNumber) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PatientPhoneNumber.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PatientPhoneNumber) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PatientPhoneNumber.Merge(m, src)
}
func (m *PatientPhoneNumber) XXX_Size() int {
	return m.Size()
}
func (m *PatientPhoneNumber) XXX_DiscardUnknown() {
	xxx_messageInfo_PatientPhoneNumber.DiscardUnknown(m)
}

var xxx_messageInfo_PatientPhoneNumber proto.InternalMessageInfo

func (m *PatientPhoneNumber) GetPhoneNumber() string {
	if m != nil {
		return m.PhoneNumber
	}
	return ""
}

type PatientDebtInfoResp struct {
	ClientId             string   `protobuf:"bytes,1,opt,name=client_id,json=clientId,proto3" json:"client_id"`
	Amount               float32  `protobuf:"fixed32,2,opt,name=amount,proto3" json:"amount"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PatientDebtInfoResp) Reset()         { *m = PatientDebtInfoResp{} }
func (m *PatientDebtInfoResp) String() string { return proto.CompactTextString(m) }
func (*PatientDebtInfoResp) ProtoMessage()    {}
func (*PatientDebtInfoResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_ae32a8d1a528f6da, []int{32}
}
func (m *PatientDebtInfoResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PatientDebtInfoResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PatientDebtInfoResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PatientDebtInfoResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PatientDebtInfoResp.Merge(m, src)
}
func (m *PatientDebtInfoResp) XXX_Size() int {
	return m.Size()
}
func (m *PatientDebtInfoResp) XXX_DiscardUnknown() {
	xxx_messageInfo_PatientDebtInfoResp.DiscardUnknown(m)
}

var xxx_messageInfo_PatientDebtInfoResp proto.InternalMessageInfo

func (m *PatientDebtInfoResp) GetClientId() string {
	if m != nil {
		return m.ClientId
	}
	return ""
}

func (m *PatientDebtInfoResp) GetAmount() float32 {
	if m != nil {
		return m.Amount
	}
	return 0
}

type PatientsMedicalBookGetReq struct {
	Id                   string   `protobuf:"bytes,1,opt,name=id,proto3" json:"id"`
	PhoneNumber          string   `protobuf:"bytes,2,opt,name=phone_number,json=phoneNumber,proto3" json:"phone_number"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PatientsMedicalBookGetReq) Reset()         { *m = PatientsMedicalBookGetReq{} }
func (m *PatientsMedicalBookGetReq) String() string { return proto.CompactTextString(m) }
func (*PatientsMedicalBookGetReq) ProtoMessage()    {}
func (*PatientsMedicalBookGetReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_ae32a8d1a528f6da, []int{33}
}
func (m *PatientsMedicalBookGetReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PatientsMedicalBookGetReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PatientsMedicalBookGetReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PatientsMedicalBookGetReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PatientsMedicalBookGetReq.Merge(m, src)
}
func (m *PatientsMedicalBookGetReq) XXX_Size() int {
	return m.Size()
}
func (m *PatientsMedicalBookGetReq) XXX_DiscardUnknown() {
	xxx_messageInfo_PatientsMedicalBookGetReq.DiscardUnknown(m)
}

var xxx_messageInfo_PatientsMedicalBookGetReq proto.InternalMessageInfo

func (m *PatientsMedicalBookGetReq) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *PatientsMedicalBookGetReq) GetPhoneNumber() string {
	if m != nil {
		return m.PhoneNumber
	}
	return ""
}

type PatientsMedicalBookGetResp struct {
	DoctorReports        []*DoctorReportInfo `protobuf:"bytes,1,rep,name=doctor_reports,json=doctorReports,proto3" json:"doctor_reports"`
	Analysises           []*AnalysisInfo     `protobuf:"bytes,2,rep,name=analysises,proto3" json:"analysises"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *PatientsMedicalBookGetResp) Reset()         { *m = PatientsMedicalBookGetResp{} }
func (m *PatientsMedicalBookGetResp) String() string { return proto.CompactTextString(m) }
func (*PatientsMedicalBookGetResp) ProtoMessage()    {}
func (*PatientsMedicalBookGetResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_ae32a8d1a528f6da, []int{34}
}
func (m *PatientsMedicalBookGetResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PatientsMedicalBookGetResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PatientsMedicalBookGetResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PatientsMedicalBookGetResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PatientsMedicalBookGetResp.Merge(m, src)
}
func (m *PatientsMedicalBookGetResp) XXX_Size() int {
	return m.Size()
}
func (m *PatientsMedicalBookGetResp) XXX_DiscardUnknown() {
	xxx_messageInfo_PatientsMedicalBookGetResp.DiscardUnknown(m)
}

var xxx_messageInfo_PatientsMedicalBookGetResp proto.InternalMessageInfo

func (m *PatientsMedicalBookGetResp) GetDoctorReports() []*DoctorReportInfo {
	if m != nil {
		return m.DoctorReports
	}
	return nil
}

func (m *PatientsMedicalBookGetResp) GetAnalysises() []*AnalysisInfo {
	if m != nil {
		return m.Analysises
	}
	return nil
}

type DoctorReportInfo struct {
	Id                   string   `protobuf:"bytes,1,opt,name=id,proto3" json:"id"`
	DoctorId             string   `protobuf:"bytes,2,opt,name=doctor_id,json=doctorId,proto3" json:"doctor_id"`
	Text                 string   `protobuf:"bytes,3,opt,name=text,proto3" json:"text"`
	ClientId             string   `protobuf:"bytes,4,opt,name=client_id,json=clientId,proto3" json:"client_id"`
	CreatedAt            string   `protobuf:"bytes,5,opt,name=created_at,json=createdAt,proto3" json:"created_at"`
	UpdatedAt            string   `protobuf:"bytes,6,opt,name=updated_at,json=updatedAt,proto3" json:"updated_at"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DoctorReportInfo) Reset()         { *m = DoctorReportInfo{} }
func (m *DoctorReportInfo) String() string { return proto.CompactTextString(m) }
func (*DoctorReportInfo) ProtoMessage()    {}
func (*DoctorReportInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_ae32a8d1a528f6da, []int{35}
}
func (m *DoctorReportInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DoctorReportInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DoctorReportInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DoctorReportInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DoctorReportInfo.Merge(m, src)
}
func (m *DoctorReportInfo) XXX_Size() int {
	return m.Size()
}
func (m *DoctorReportInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_DoctorReportInfo.DiscardUnknown(m)
}

var xxx_messageInfo_DoctorReportInfo proto.InternalMessageInfo

func (m *DoctorReportInfo) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *DoctorReportInfo) GetDoctorId() string {
	if m != nil {
		return m.DoctorId
	}
	return ""
}

func (m *DoctorReportInfo) GetText() string {
	if m != nil {
		return m.Text
	}
	return ""
}

func (m *DoctorReportInfo) GetClientId() string {
	if m != nil {
		return m.ClientId
	}
	return ""
}

func (m *DoctorReportInfo) GetCreatedAt() string {
	if m != nil {
		return m.CreatedAt
	}
	return ""
}

func (m *DoctorReportInfo) GetUpdatedAt() string {
	if m != nil {
		return m.UpdatedAt
	}
	return ""
}

type AnalysisInfo struct {
	Id                   string   `protobuf:"bytes,1,opt,name=id,proto3" json:"id"`
	ClientPhoneNumber    string   `protobuf:"bytes,2,opt,name=client_phone_number,json=clientPhoneNumber,proto3" json:"client_phone_number"`
	AnalysName           string   `protobuf:"bytes,3,opt,name=analys_name,json=analysName,proto3" json:"analys_name"`
	AnalysUrl            string   `protobuf:"bytes,4,opt,name=analys_url,json=analysUrl,proto3" json:"analys_url"`
	CreatedAt            string   `protobuf:"bytes,5,opt,name=created_at,json=createdAt,proto3" json:"created_at"`
	UpdatedAt            string   `protobuf:"bytes,6,opt,name=updated_at,json=updatedAt,proto3" json:"updated_at"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AnalysisInfo) Reset()         { *m = AnalysisInfo{} }
func (m *AnalysisInfo) String() string { return proto.CompactTextString(m) }
func (*AnalysisInfo) ProtoMessage()    {}
func (*AnalysisInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_ae32a8d1a528f6da, []int{36}
}
func (m *AnalysisInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AnalysisInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AnalysisInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AnalysisInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AnalysisInfo.Merge(m, src)
}
func (m *AnalysisInfo) XXX_Size() int {
	return m.Size()
}
func (m *AnalysisInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_AnalysisInfo.DiscardUnknown(m)
}

var xxx_messageInfo_AnalysisInfo proto.InternalMessageInfo

func (m *AnalysisInfo) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *AnalysisInfo) GetClientPhoneNumber() string {
	if m != nil {
		return m.ClientPhoneNumber
	}
	return ""
}

func (m *AnalysisInfo) GetAnalysName() string {
	if m != nil {
		return m.AnalysName
	}
	return ""
}

func (m *AnalysisInfo) GetAnalysUrl() string {
	if m != nil {
		return m.AnalysUrl
	}
	return ""
}

func (m *AnalysisInfo) GetCreatedAt() string {
	if m != nil {
		return m.CreatedAt
	}
	return ""
}

func (m *AnalysisInfo) GetUpdatedAt() string {
	if m != nil {
		return m.UpdatedAt
	}
	return ""
}

type GetPatientReq struct {
	Field                string   `protobuf:"bytes,1,opt,name=field,proto3" json:"field"`
	Value                string   `protobuf:"bytes,2,opt,name=value,proto3" json:"value"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetPatientReq) Reset()         { *m = GetPatientReq{} }
func (m *GetPatientReq) String() string { return proto.CompactTextString(m) }
func (*GetPatientReq) ProtoMessage()    {}
func (*GetPatientReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_ae32a8d1a528f6da, []int{37}
}
func (m *GetPatientReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetPatientReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetPatientReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetPatientReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetPatientReq.Merge(m, src)
}
func (m *GetPatientReq) XXX_Size() int {
	return m.Size()
}
func (m *GetPatientReq) XXX_DiscardUnknown() {
	xxx_messageInfo_GetPatientReq.DiscardUnknown(m)
}

var xxx_messageInfo_GetPatientReq proto.InternalMessageInfo

func (m *GetPatientReq) GetField() string {
	if m != nil {
		return m.Field
	}
	return ""
}

func (m *GetPatientReq) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

type PatientsFindReq struct {
	Limit                int64    `protobuf:"varint,1,opt,name=limit,proto3" json:"limit"`
	Page                 int64    `protobuf:"varint,2,opt,name=page,proto3" json:"page"`
	Search               string   `protobuf:"bytes,3,opt,name=search,proto3" json:"search"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PatientsFindReq) Reset()         { *m = PatientsFindReq{} }
func (m *PatientsFindReq) String() string { return proto.CompactTextString(m) }
func (*PatientsFindReq) ProtoMessage()    {}
func (*PatientsFindReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_ae32a8d1a528f6da, []int{38}
}
func (m *PatientsFindReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PatientsFindReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PatientsFindReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PatientsFindReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PatientsFindReq.Merge(m, src)
}
func (m *PatientsFindReq) XXX_Size() int {
	return m.Size()
}
func (m *PatientsFindReq) XXX_DiscardUnknown() {
	xxx_messageInfo_PatientsFindReq.DiscardUnknown(m)
}

var xxx_messageInfo_PatientsFindReq proto.InternalMessageInfo

func (m *PatientsFindReq) GetLimit() int64 {
	if m != nil {
		return m.Limit
	}
	return 0
}

func (m *PatientsFindReq) GetPage() int64 {
	if m != nil {
		return m.Page
	}
	return 0
}

func (m *PatientsFindReq) GetSearch() string {
	if m != nil {
		return m.Search
	}
	return ""
}

type PatientsResp struct {
	Patients             []*Patient `protobuf:"bytes,1,rep,name=patients,proto3" json:"patients"`
	Count                int64      `protobuf:"varint,2,opt,name=count,proto3" json:"count"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *PatientsResp) Reset()         { *m = PatientsResp{} }
func (m *PatientsResp) String() string { return proto.CompactTextString(m) }
func (*PatientsResp) ProtoMessage()    {}
func (*PatientsResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_ae32a8d1a528f6da, []int{39}
}
func (m *PatientsResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PatientsResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PatientsResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PatientsResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PatientsResp.Merge(m, src)
}
func (m *PatientsResp) XXX_Size() int {
	return m.Size()
}
func (m *PatientsResp) XXX_DiscardUnknown() {
	xxx_messageInfo_PatientsResp.DiscardUnknown(m)
}

var xxx_messageInfo_PatientsResp proto.InternalMessageInfo

func (m *PatientsResp) GetPatients() []*Patient {
	if m != nil {
		return m.Patients
	}
	return nil
}

func (m *PatientsResp) GetCount() int64 {
	if m != nil {
		return m.Count
	}
	return 0
}

type Patient struct {
	Id                   string   `protobuf:"bytes,1,opt,name=id,proto3" json:"id"`
	ClientId             int64    `protobuf:"varint,2,opt,name=client_id,json=clientId,proto3" json:"client_id"`
	FirstName            string   `protobuf:"bytes,3,opt,name=first_name,json=firstName,proto3" json:"first_name"`
	LastName             string   `protobuf:"bytes,4,opt,name=last_name,json=lastName,proto3" json:"last_name"`
	Patronymic           string   `protobuf:"bytes,5,opt,name=patronymic,proto3" json:"patronymic"`
	DateOfBirth          string   `protobuf:"bytes,6,opt,name=date_of_birth,json=dateOfBirth,proto3" json:"date_of_birth"`
	MainPhoneNumber      string   `protobuf:"bytes,7,opt,name=main_phone_number,json=mainPhoneNumber,proto3" json:"main_phone_number"`
	OtherPhoneNumber     string   `protobuf:"bytes,8,opt,name=other_phone_number,json=otherPhoneNumber,proto3" json:"other_phone_number"`
	AdvertisingChannel   string   `protobuf:"bytes,9,opt,name=advertising_channel,json=advertisingChannel,proto3" json:"advertising_channel"`
	Respublic            string   `protobuf:"bytes,10,opt,name=respublic,proto3" json:"respublic"`
	Region               string   `protobuf:"bytes,11,opt,name=region,proto3" json:"region"`
	District             string   `protobuf:"bytes,12,opt,name=district,proto3" json:"district"`
	PassportInfo         string   `protobuf:"bytes,13,opt,name=passport_info,json=passportInfo,proto3" json:"passport_info"`
	Discount             string   `protobuf:"bytes,14,opt,name=discount,proto3" json:"discount"`
	Condition            string   `protobuf:"bytes,15,opt,name=condition,proto3" json:"condition"`
	Gender               string   `protobuf:"bytes,16,opt,name=gender,proto3" json:"gender"`
	DoctorId             string   `protobuf:"bytes,17,opt,name=doctor_id,json=doctorId,proto3" json:"doctor_id"`
	CreatedAt            string   `protobuf:"bytes,18,opt,name=created_at,json=createdAt,proto3" json:"created_at"`
	UpdatedAt            string   `protobuf:"bytes,19,opt,name=updated_at,json=updatedAt,proto3" json:"updated_at"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Patient) Reset()         { *m = Patient{} }
func (m *Patient) String() string { return proto.CompactTextString(m) }
func (*Patient) ProtoMessage()    {}
func (*Patient) Descriptor() ([]byte, []int) {
	return fileDescriptor_ae32a8d1a528f6da, []int{40}
}
func (m *Patient) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Patient) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Patient.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Patient) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Patient.Merge(m, src)
}
func (m *Patient) XXX_Size() int {
	return m.Size()
}
func (m *Patient) XXX_DiscardUnknown() {
	xxx_messageInfo_Patient.DiscardUnknown(m)
}

var xxx_messageInfo_Patient proto.InternalMessageInfo

func (m *Patient) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Patient) GetClientId() int64 {
	if m != nil {
		return m.ClientId
	}
	return 0
}

func (m *Patient) GetFirstName() string {
	if m != nil {
		return m.FirstName
	}
	return ""
}

func (m *Patient) GetLastName() string {
	if m != nil {
		return m.LastName
	}
	return ""
}

func (m *Patient) GetPatronymic() string {
	if m != nil {
		return m.Patronymic
	}
	return ""
}

func (m *Patient) GetDateOfBirth() string {
	if m != nil {
		return m.DateOfBirth
	}
	return ""
}

func (m *Patient) GetMainPhoneNumber() string {
	if m != nil {
		return m.MainPhoneNumber
	}
	return ""
}

func (m *Patient) GetOtherPhoneNumber() string {
	if m != nil {
		return m.OtherPhoneNumber
	}
	return ""
}

func (m *Patient) GetAdvertisingChannel() string {
	if m != nil {
		return m.AdvertisingChannel
	}
	return ""
}

func (m *Patient) GetRespublic() string {
	if m != nil {
		return m.Respublic
	}
	return ""
}

func (m *Patient) GetRegion() string {
	if m != nil {
		return m.Region
	}
	return ""
}

func (m *Patient) GetDistrict() string {
	if m != nil {
		return m.District
	}
	return ""
}

func (m *Patient) GetPassportInfo() string {
	if m != nil {
		return m.PassportInfo
	}
	return ""
}

func (m *Patient) GetDiscount() string {
	if m != nil {
		return m.Discount
	}
	return ""
}

func (m *Patient) GetCondition() string {
	if m != nil {
		return m.Condition
	}
	return ""
}

func (m *Patient) GetGender() string {
	if m != nil {
		return m.Gender
	}
	return ""
}

func (m *Patient) GetDoctorId() string {
	if m != nil {
		return m.DoctorId
	}
	return ""
}

func (m *Patient) GetCreatedAt() string {
	if m != nil {
		return m.CreatedAt
	}
	return ""
}

func (m *Patient) GetUpdatedAt() string {
	if m != nil {
		return m.UpdatedAt
	}
	return ""
}

func init() {
	proto.RegisterType((*PaymentHistoryFilter)(nil), "genproto.PaymentHistoryFilter")
	proto.RegisterType((*PaymentHistoriesResp)(nil), "genproto.PaymentHistoriesResp")
	proto.RegisterType((*PaymentHistoryId)(nil), "genproto.PaymentHistoryId")
	proto.RegisterType((*CreatePaymentHistoryReq)(nil), "genproto.CreatePaymentHistoryReq")
	proto.RegisterType((*PaymentHistoryResp)(nil), "genproto.PaymentHistoryResp")
	proto.RegisterType((*GetCashboxReq)(nil), "genproto.GetCashboxReq")
	proto.RegisterType((*UpdateCashboxReq)(nil), "genproto.UpdateCashboxReq")
	proto.RegisterType((*FindCashboxReq)(nil), "genproto.FindCashboxReq")
	proto.RegisterType((*FindCashboxResp)(nil), "genproto.FindCashboxResp")
	proto.RegisterType((*QueueFilter)(nil), "genproto.QueueFilter")
	proto.RegisterType((*QueuesResp)(nil), "genproto.QueuesResp")
	proto.RegisterType((*CreateCashboxReq)(nil), "genproto.CreateCashboxReq")
	proto.RegisterType((*CashboxResp)(nil), "genproto.CashboxResp")
	proto.RegisterType((*UpdateQueueReq)(nil), "genproto.UpdateQueueReq")
	proto.RegisterType((*CreatePatientQueueReq)(nil), "genproto.CreatePatientQueueReq")
	proto.RegisterType((*QueueNumber)(nil), "genproto.QueueNumber")
	proto.RegisterType((*CheckQueueReq)(nil), "genproto.CheckQueueReq")
	proto.RegisterType((*PatientQueueResp)(nil), "genproto.PatientQueueResp")
	proto.RegisterType((*FindCashBoxReq)(nil), "genproto.FindCashBoxReq")
	proto.RegisterType((*PatientsGetKassaResponse)(nil), "genproto.PatientsGetKassaResponse")
	proto.RegisterType((*PatientsGetKassaReq)(nil), "genproto.PatientsGetKassaReq")
	proto.RegisterType((*PatientsFilter)(nil), "genproto.PatientsFilter")
	proto.RegisterType((*AddServiceReq)(nil), "genproto.AddServiceReq")
	proto.RegisterType((*CashStorage)(nil), "genproto.CashStorage")
	proto.RegisterType((*PatientDebtCreateReq)(nil), "genproto.PatientDebtCreateReq")
	proto.RegisterType((*PatientDebt)(nil), "genproto.PatientDebt")
	proto.RegisterType((*CreateAnalysisesReq)(nil), "genproto.CreateAnalysisesReq")
	proto.RegisterType((*CreateDoctorReportReq)(nil), "genproto.CreateDoctorReportReq")
	proto.RegisterType((*AddServiceToCleintReq)(nil), "genproto.AddServiceToCleintReq")
	proto.RegisterType((*PatientsGetInfoFilter)(nil), "genproto.PatientsGetInfoFilter")
	proto.RegisterType((*PatientId)(nil), "genproto.PatientId")
	proto.RegisterType((*PatientPhoneNumber)(nil), "genproto.PatientPhoneNumber")
	proto.RegisterType((*PatientDebtInfoResp)(nil), "genproto.PatientDebtInfoResp")
	proto.RegisterType((*PatientsMedicalBookGetReq)(nil), "genproto.PatientsMedicalBookGetReq")
	proto.RegisterType((*PatientsMedicalBookGetResp)(nil), "genproto.PatientsMedicalBookGetResp")
	proto.RegisterType((*DoctorReportInfo)(nil), "genproto.DoctorReportInfo")
	proto.RegisterType((*AnalysisInfo)(nil), "genproto.AnalysisInfo")
	proto.RegisterType((*GetPatientReq)(nil), "genproto.GetPatientReq")
	proto.RegisterType((*PatientsFindReq)(nil), "genproto.PatientsFindReq")
	proto.RegisterType((*PatientsResp)(nil), "genproto.PatientsResp")
	proto.RegisterType((*Patient)(nil), "genproto.Patient")
}

func init() { proto.RegisterFile("patient/patient.proto", fileDescriptor_ae32a8d1a528f6da) }

var fileDescriptor_ae32a8d1a528f6da = []byte{
	// 2182 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xcc, 0x59, 0xcd, 0x8f, 0x23, 0x47,
	0x15, 0x9f, 0xf6, 0xb7, 0x9f, 0xc7, 0xf3, 0x51, 0xf3, 0xb1, 0x1e, 0x67, 0x77, 0x76, 0xb7, 0xb9,
	0x8c, 0x10, 0xcc, 0xa2, 0x8d, 0x44, 0xa4, 0x20, 0x25, 0x9a, 0x8f, 0xdd, 0xc9, 0x90, 0xb0, 0x99,
	0x78, 0xb2, 0x91, 0x40, 0x48, 0xa6, 0xed, 0x2e, 0xcf, 0x34, 0x69, 0x77, 0xf7, 0x76, 0x97, 0x57,
	0xeb, 0x73, 0x2e, 0x5c, 0x38, 0x21, 0x01, 0x27, 0x6e, 0x1c, 0x90, 0x10, 0xfc, 0x0f, 0x9c, 0x82,
	0xc4, 0x01, 0x89, 0x03, 0x57, 0xb4, 0x88, 0x3f, 0x82, 0x1b, 0xaa, 0xaf, 0x76, 0x55, 0xf5, 0x87,
	0x67, 0x33, 0x28, 0xca, 0xc9, 0xae, 0xf7, 0xaa, 0x5f, 0xbd, 0xfa, 0xd5, 0x7b, 0xbf, 0x7a, 0x55,
	0x05, 0x3b, 0x91, 0x43, 0x3c, 0x1c, 0x90, 0x47, 0xe2, 0xf7, 0x30, 0x8a, 0x43, 0x12, 0xa2, 0xd6,
	0x15, 0x0e, 0xd8, 0xbf, 0xfe, 0x5b, 0x57, 0x61, 0x78, 0xe5, 0xe3, 0x47, 0xac, 0x35, 0x9a, 0x4d,
	0x1e, 0xe1, 0x69, 0x44, 0xe6, 0xbc, 0x9b, 0xfd, 0x2b, 0x0b, 0xb6, 0x2f, 0x9c, 0xf9, 0x14, 0x07,
	0xe4, 0x03, 0x2f, 0x21, 0x61, 0x3c, 0x7f, 0xea, 0xf9, 0x04, 0xc7, 0xe8, 0x2d, 0x68, 0x8f, 0x7d,
	0x6a, 0x6f, 0xe8, 0xb9, 0x3d, 0xeb, 0x81, 0x75, 0x50, 0x1d, 0xb4, 0xb8, 0xe0, 0xdc, 0x45, 0xdb,
	0x50, 0xf7, 0xbd, 0xa9, 0x47, 0x7a, 0x15, 0xa6, 0xe0, 0x0d, 0x84, 0xa0, 0x16, 0x39, 0x57, 0xb8,
	0x57, 0x65, 0x42, 0xf6, 0x9f, 0x9a, 0x99, 0xc4, 0xe1, 0x74, 0xe8, 0x3a, 0x04, 0xf7, 0x6a, 0x0f,
	0xac, 0x83, 0xf6, 0xa0, 0x45, 0x05, 0xa7, 0x0e, 0xc1, 0xe8, 0x0e, 0x34, 0x49, 0xc8, 0x55, 0x75,
	0xa6, 0x6a, 0x90, 0x90, 0x2a, 0xec, 0xc4, 0x70, 0xca, 0xc3, 0xc9, 0x00, 0x27, 0x11, 0x7a, 0x02,
	0xeb, 0x11, 0x97, 0x0f, 0xaf, 0xb9, 0xb7, 0x3d, 0xeb, 0x41, 0xf5, 0xa0, 0xf3, 0xf8, 0xee, 0xa1,
	0x9c, 0xee, 0xa1, 0x3e, 0x1b, 0xfa, 0xd9, 0x60, 0x2d, 0xd2, 0x64, 0xd4, 0xfd, 0x71, 0x38, 0x0b,
	0x52, 0xf7, 0x59, 0xc3, 0xb6, 0x61, 0x43, 0xff, 0xf6, 0xdc, 0x45, 0x6b, 0x50, 0x11, 0xd3, 0x6f,
	0x0f, 0x2a, 0x9e, 0x6b, 0xff, 0xce, 0x82, 0x3b, 0x27, 0x31, 0x76, 0x08, 0x36, 0x87, 0x79, 0x61,
	0xf6, 0xd5, 0x11, 0xac, 0x64, 0x11, 0x4c, 0x66, 0xd3, 0xa9, 0x23, 0xc0, 0xe2, 0x0d, 0xf4, 0x10,
	0x56, 0xe5, 0xfc, 0xc8, 0x3c, 0x92, 0x80, 0x75, 0x84, 0xec, 0xd3, 0x79, 0x84, 0xd1, 0x3d, 0x80,
	0xb1, 0x93, 0x5c, 0x8f, 0xc2, 0x57, 0xd4, 0x2c, 0x87, 0xad, 0x2d, 0x24, 0xe7, 0xae, 0xfd, 0x4f,
	0x0b, 0x50, 0x16, 0x81, 0x6f, 0x84, 0x6f, 0x4c, 0xcd, 0xb0, 0x73, 0x87, 0x0e, 0xe9, 0x35, 0x84,
	0x9a, 0x4b, 0x8e, 0x08, 0x55, 0xcf, 0x22, 0x57, 0xaa, 0x9b, 0x5c, 0x2d, 0x24, 0x47, 0xc4, 0x3e,
	0x84, 0xee, 0x19, 0x26, 0x27, 0xdc, 0x1a, 0xc5, 0x5b, 0x1f, 0xcd, 0x32, 0x91, 0xf8, 0x19, 0x6c,
	0x3c, 0x67, 0x1f, 0x2b, 0x9f, 0x98, 0x30, 0xec, 0x41, 0xcb, 0x4b, 0x86, 0x91, 0x33, 0xc7, 0x1c,
	0x85, 0xd6, 0xa0, 0xe9, 0x25, 0x17, 0xb4, 0x99, 0x99, 0x6e, 0x35, 0x33, 0x5d, 0xfb, 0xf7, 0x16,
	0xac, 0x3d, 0xf5, 0x02, 0x57, 0x19, 0xa0, 0x34, 0x6b, 0x76, 0xa1, 0x91, 0x60, 0x27, 0x1e, 0x5f,
	0xb3, 0xb1, 0xda, 0x03, 0xd1, 0xca, 0xcd, 0x9b, 0x34, 0xc3, 0x6a, 0x6a, 0x86, 0x69, 0xd9, 0x54,
	0x2f, 0xce, 0xa6, 0x86, 0x96, 0x4d, 0x3f, 0x85, 0x75, 0xcd, 0xcd, 0x24, 0x42, 0x6f, 0x83, 0x44,
	0x0a, 0x27, 0x22, 0x85, 0x76, 0x16, 0x29, 0xa4, 0xf4, 0x1c, 0x2c, 0xfa, 0x15, 0xa4, 0xcd, 0xaf,
	0x2d, 0xe8, 0x7c, 0x32, 0xc3, 0x33, 0x2c, 0x88, 0xe3, 0x1e, 0x40, 0x82, 0xe3, 0x97, 0xde, 0x18,
	0x2b, 0xcb, 0x22, 0x24, 0xe7, 0x0c, 0x57, 0xa9, 0x66, 0xb8, 0x72, 0x28, 0x3a, 0x42, 0xc6, 0xc2,
	0x48, 0x03, 0xb1, 0x6a, 0x80, 0x28, 0xc1, 0xaa, 0xe5, 0x81, 0x55, 0x57, 0xc0, 0xb2, 0x3f, 0x03,
	0x60, 0x7e, 0x71, 0xea, 0x78, 0x0c, 0x8d, 0x17, 0xac, 0x25, 0xa6, 0xdb, 0x57, 0x19, 0x83, 0x11,
	0x27, 0xeb, 0xcc, 0xe6, 0x2c, 0x7a, 0x16, 0x4c, 0xf8, 0xbf, 0x16, 0x6c, 0x70, 0x0e, 0x28, 0x89,
	0xac, 0xd2, 0x04, 0x53, 0xc3, 0xae, 0xaa, 0x87, 0x9d, 0x08, 0xea, 0x21, 0x1f, 0x97, 0x4f, 0x92,
	0x2d, 0xc1, 0x09, 0x15, 0x64, 0xa2, 0xb2, 0x9e, 0x4d, 0xc2, 0xfb, 0xd0, 0x71, 0xc3, 0x31, 0x09,
	0xe3, 0x64, 0xe8, 0xb9, 0x49, 0xaf, 0xf1, 0xa0, 0x7a, 0xd0, 0x1e, 0x80, 0x10, 0x9d, 0xbb, 0x09,
	0x1d, 0xdd, 0x77, 0x46, 0x5c, 0xdb, 0x64, 0xda, 0x26, 0x6d, 0x53, 0xd5, 0x7d, 0xe8, 0x38, 0x91,
	0x13, 0x3b, 0x84, 0x6b, 0x5b, 0xfc, 0x5b, 0x21, 0x3a, 0x77, 0x13, 0xfb, 0xcb, 0x0a, 0x74, 0xd4,
	0x38, 0xfa, 0x3f, 0xf0, 0x8a, 0x0a, 0x46, 0xad, 0x0c, 0x8c, 0xfa, 0x32, 0x30, 0x1a, 0x4b, 0xc1,
	0x68, 0x96, 0x82, 0xd1, 0x2a, 0x05, 0xa3, 0x6d, 0x82, 0x61, 0xf0, 0x19, 0x94, 0xf3, 0x59, 0xc7,
	0xe4, 0xb3, 0x10, 0xd6, 0x38, 0x3f, 0x89, 0xb8, 0x5b, 0x42, 0x1e, 0x7a, 0x5a, 0x55, 0x96, 0xa5,
	0x55, 0x35, 0x93, 0x56, 0xf6, 0x1f, 0x2c, 0xd8, 0x91, 0x7b, 0x97, 0x1a, 0xf0, 0x6f, 0x18, 0xbc,
	0x0f, 0x61, 0x95, 0xa5, 0xc7, 0x30, 0x98, 0x4d, 0x47, 0x38, 0x16, 0x8b, 0xd9, 0x61, 0xb2, 0x67,
	0x4c, 0x64, 0xf8, 0x5a, 0x5b, 0xe6, 0x6b, 0x3d, 0xeb, 0xeb, 0xf7, 0x04, 0xa7, 0x08, 0x83, 0xe6,
	0x98, 0x56, 0x66, 0x4c, 0xfb, 0x13, 0xe8, 0x9e, 0x5c, 0xe3, 0xf1, 0xe7, 0xe9, 0xa4, 0x6e, 0xcd,
	0x43, 0xf6, 0x17, 0x15, 0x5a, 0x11, 0xe8, 0xdc, 0xf0, 0xcd, 0xc3, 0x8a, 0xc6, 0x29, 0x99, 0xc5,
	0xc1, 0x30, 0x72, 0x92, 0x04, 0xbb, 0x2c, 0x0b, 0x5a, 0x03, 0xa0, 0xa2, 0x0b, 0x26, 0x31, 0xe2,
	0xb4, 0x59, 0x1e, 0xa7, 0x2d, 0x33, 0x4e, 0x7f, 0xa1, 0xec, 0x72, 0xc7, 0x9c, 0xec, 0x52, 0xbe,
	0xa5, 0x30, 0xd4, 0xcd, 0xf2, 0xaf, 0xc2, 0x84, 0x9c, 0x99, 0x17, 0x5b, 0x5e, 0x55, 0xdb, 0xf2,
	0xbe, 0x5a, 0x59, 0xf8, 0x47, 0x0b, 0x7a, 0x62, 0x41, 0x92, 0x33, 0x4c, 0x3e, 0x74, 0x92, 0xc4,
	0xa1, 0x8b, 0x12, 0x06, 0x09, 0xce, 0x66, 0x4f, 0x5b, 0xcf, 0x9e, 0x89, 0x17, 0x27, 0x64, 0x18,
	0x38, 0x53, 0xb9, 0xd6, 0x6d, 0x26, 0x79, 0xe6, 0x4c, 0xd9, 0xb7, 0xbe, 0x23, 0xb5, 0xdc, 0xd3,
	0x16, 0x15, 0x30, 0x65, 0x4a, 0x5b, 0xd4, 0x4f, 0xab, 0xa8, 0x1c, 0xca, 0x32, 0xb1, 0xfd, 0x3e,
	0x6c, 0x65, 0xbd, 0x35, 0xd0, 0xab, 0xe6, 0xa1, 0x27, 0xf6, 0x35, 0x9a, 0xb1, 0x6b, 0xd2, 0xc2,
	0x4d, 0xca, 0xf2, 0x3e, 0xb4, 0x26, 0x33, 0xdf, 0x57, 0xe6, 0x98, 0xb6, 0x75, 0xc4, 0xab, 0xc5,
	0x88, 0xd7, 0x54, 0xc4, 0x53, 0xaf, 0xea, 0xca, 0x9a, 0xa6, 0xfe, 0x37, 0x94, 0xd5, 0xb7, 0xbf,
	0xb0, 0xa0, 0x7b, 0xe4, 0xba, 0x97, 0x3c, 0x30, 0x45, 0x02, 0x72, 0xa2, 0x65, 0xf4, 0x69, 0x31,
	0xfa, 0x6c, 0x73, 0x09, 0x65, 0xcf, 0x3b, 0x40, 0x99, 0x96, 0xe9, 0x2a, 0x4c, 0xd7, 0xf0, 0x9d,
	0x91, 0xa0, 0x55, 0x4e, 0xb2, 0x4c, 0x57, 0xe5, 0xdf, 0x71, 0x09, 0x55, 0x6b, 0x08, 0xd4, 0x74,
	0x04, 0xec, 0xbf, 0x88, 0xfd, 0xe9, 0x92, 0x84, 0x31, 0xf5, 0xf5, 0xab, 0xef, 0x4f, 0xd6, 0xd7,
	0xb2, 0x3f, 0xe9, 0x18, 0x35, 0x4b, 0x30, 0x6a, 0x95, 0x60, 0xd4, 0x36, 0x31, 0xba, 0xdd, 0xce,
	0xf4, 0x73, 0x7a, 0xfa, 0x62, 0x51, 0x77, 0x8a, 0x47, 0x84, 0x6f, 0x19, 0x62, 0x41, 0xc5, 0x19,
	0x53, 0x61, 0x54, 0x21, 0xe1, 0xe5, 0xad, 0x33, 0x4d, 0xcb, 0xa5, 0xca, 0x40, 0xb4, 0x28, 0xe6,
	0x04, 0xc7, 0x7a, 0xe4, 0x51, 0x01, 0x4b, 0xe9, 0x3f, 0x5b, 0xd0, 0x51, 0x06, 0xcb, 0x2c, 0x98,
	0x3e, 0x66, 0xa5, 0x78, 0xcc, 0x6a, 0xf1, 0x98, 0x35, 0x7d, 0x4c, 0x03, 0x9d, 0x7a, 0x39, 0x3a,
	0x0d, 0x13, 0x9d, 0x5f, 0x5a, 0xb0, 0xc5, 0x31, 0x39, 0x0a, 0x1c, 0x7f, 0x9e, 0x78, 0x09, 0xad,
	0x30, 0x5f, 0xa0, 0x43, 0xd8, 0x12, 0xa1, 0x15, 0x5d, 0x87, 0x81, 0xb6, 0x55, 0xb5, 0x07, 0x9b,
	0x5c, 0x75, 0x41, 0x35, 0x82, 0xf8, 0xbf, 0x05, 0x5d, 0x47, 0x18, 0x50, 0x59, 0x69, 0x55, 0x0a,
	0x19, 0xf7, 0x3c, 0x84, 0xb4, 0x3d, 0x9c, 0xc5, 0xbe, 0xdc, 0xd6, 0xa5, 0xec, 0x79, 0xec, 0xdb,
	0x57, 0x72, 0x57, 0x3f, 0x65, 0x61, 0x33, 0xc0, 0x51, 0x18, 0x13, 0x51, 0x4e, 0xa4, 0xb1, 0x25,
	0x09, 0x51, 0x86, 0x16, 0x4d, 0x6c, 0x82, 0x5f, 0x11, 0x31, 0x28, 0xfb, 0x6f, 0x60, 0x5d, 0x35,
	0xb0, 0xb6, 0x5f, 0xc1, 0xce, 0x22, 0xc1, 0x3f, 0x0d, 0x4f, 0x7c, 0xec, 0x05, 0xe4, 0x06, 0x71,
	0x71, 0xfb, 0xca, 0xe5, 0x1f, 0x16, 0xec, 0x28, 0x4c, 0x7a, 0x1e, 0x4c, 0xc2, 0x9b, 0xd0, 0x21,
	0xcd, 0x3f, 0x75, 0x29, 0xc4, 0x16, 0x1f, 0x29, 0x8b, 0xa0, 0x32, 0x66, 0xb5, 0x8c, 0x31, 0x6f,
	0xba, 0x47, 0xa5, 0x8c, 0xd9, 0xc8, 0x63, 0xcc, 0xa6, 0xca, 0x98, 0x07, 0xd0, 0xbe, 0x48, 0x41,
	0x2a, 0x9b, 0x88, 0xfd, 0x0e, 0x3d, 0xd3, 0x13, 0x33, 0x80, 0xcc, 0xe9, 0x59, 0x99, 0xe9, 0xd9,
	0x3f, 0x4c, 0x77, 0x20, 0x9a, 0x5c, 0x14, 0x37, 0x56, 0xc3, 0x94, 0x6e, 0x95, 0x05, 0x69, 0x6c,
	0x3f, 0x83, 0x3d, 0xb9, 0x06, 0x3f, 0xc2, 0xae, 0x37, 0x76, 0xfc, 0xe3, 0x30, 0xfc, 0xfc, 0x0c,
	0x93, 0xbc, 0x0a, 0x72, 0x39, 0xf4, 0xf6, 0x6f, 0x2c, 0xe8, 0x17, 0x19, 0x4c, 0x22, 0x74, 0x04,
	0x6b, 0x22, 0x7a, 0x63, 0x16, 0xd1, 0x39, 0xe7, 0x36, 0x35, 0xe0, 0xd9, 0xdc, 0xba, 0xae, 0x22,
	0x49, 0xd0, 0xf7, 0x01, 0x9c, 0x34, 0x45, 0xd9, 0x26, 0xd3, 0x79, 0xbc, 0xbb, 0xf8, 0x5c, 0xa6,
	0x2f, 0xfb, 0x54, 0xe9, 0x69, 0xff, 0xc9, 0x82, 0x0d, 0xd3, 0x76, 0xde, 0x4e, 0xb2, 0xc8, 0xae,
	0x4a, 0x41, 0x76, 0x55, 0x95, 0xec, 0xca, 0xec, 0x5b, 0x46, 0x7d, 0x72, 0x0b, 0x4a, 0xfa, 0x9b,
	0x05, 0xab, 0xea, 0x6c, 0x32, 0xce, 0x16, 0x70, 0x53, 0xa5, 0x88, 0x9b, 0xe8, 0xd1, 0x87, 0xd9,
	0x53, 0x2b, 0x22, 0x01, 0x11, 0xe3, 0xa5, 0x7b, 0x12, 0x5a, 0xc6, 0x4a, 0xa2, 0x6a, 0xe5, 0x92,
	0xe7, 0xb1, 0x7f, 0xcb, 0xe9, 0xfc, 0x80, 0xdd, 0xf4, 0x88, 0xd8, 0x10, 0x15, 0xd3, 0xc4, 0xc3,
	0xbe, 0x9c, 0x11, 0x6f, 0x50, 0xe9, 0x4b, 0xc7, 0x9f, 0x49, 0xe2, 0xe4, 0x0d, 0xfb, 0x12, 0xd6,
	0x17, 0x25, 0x53, 0xe0, 0xbe, 0x51, 0xc1, 0x55, 0x54, 0xae, 0xda, 0x97, 0xb0, 0x2a, 0x8d, 0xb2,
	0xe0, 0xfc, 0x2e, 0xb4, 0x04, 0xbf, 0xc9, 0xb0, 0xdc, 0xcc, 0x5c, 0x27, 0x0c, 0xd2, 0x2e, 0x05,
	0xf7, 0x08, 0xff, 0xa9, 0x41, 0x53, 0xf4, 0x7d, 0xb3, 0x3a, 0x45, 0x2f, 0x66, 0xab, 0xa5, 0xc5,
	0x6c, 0xcd, 0x28, 0x66, 0xf7, 0x19, 0x57, 0xc7, 0x61, 0x30, 0x9f, 0x7a, 0x63, 0xb1, 0x32, 0x8a,
	0x04, 0xd9, 0xd0, 0xa5, 0xcb, 0x30, 0x0c, 0x27, 0xc3, 0x91, 0x17, 0x93, 0x6b, 0x59, 0xb4, 0x50,
	0xe1, 0xc7, 0x93, 0x63, 0x2a, 0x42, 0xdf, 0x86, 0xcd, 0xa9, 0xe3, 0x05, 0x7a, 0x2c, 0xf1, 0x63,
	0xc5, 0x3a, 0x55, 0xa8, 0x91, 0xf4, 0x1d, 0x40, 0x21, 0xb9, 0xc6, 0xb1, 0xde, 0x99, 0x1f, 0x32,
	0x36, 0x98, 0x46, 0xed, 0xfd, 0x08, 0xb6, 0x1c, 0xf7, 0x25, 0x8e, 0x89, 0x97, 0x78, 0xc1, 0xd5,
	0x70, 0x7c, 0xed, 0x04, 0x01, 0xf6, 0x7b, 0x6d, 0xd6, 0x1d, 0x29, 0xaa, 0x13, 0xae, 0x41, 0x77,
	0xa1, 0x1d, 0xe3, 0x24, 0x9a, 0x8d, 0x7c, 0x6f, 0x2c, 0xeb, 0x9c, 0x54, 0x40, 0x97, 0x33, 0xc6,
	0x57, 0x5e, 0x18, 0x88, 0x1a, 0x47, 0xb4, 0x28, 0xeb, 0xbb, 0x5e, 0x42, 0x62, 0x6f, 0x4c, 0x7a,
	0xab, 0x22, 0x75, 0x45, 0x9b, 0x6e, 0xcb, 0xf4, 0x20, 0x45, 0xf3, 0x7e, 0xe8, 0x05, 0x93, 0xb0,
	0xd7, 0xe5, 0xdb, 0xb2, 0x14, 0xb2, 0xfc, 0xe2, 0x06, 0xf8, 0x9a, 0xae, 0xa5, 0x06, 0x58, 0x9b,
	0xba, 0x34, 0x0e, 0x03, 0xd7, 0x23, 0x74, 0xdc, 0x75, 0x11, 0xfa, 0x52, 0x40, 0x5d, 0xba, 0xc2,
	0x81, 0x8b, 0xe3, 0xde, 0x06, 0x77, 0x89, 0xb7, 0x74, 0x3a, 0xd9, 0x34, 0xe8, 0x44, 0x4f, 0x27,
	0x54, 0x9e, 0x4e, 0x5b, 0x46, 0x3a, 0x3d, 0xfe, 0xeb, 0x46, 0x7a, 0x8a, 0x10, 0x9b, 0x37, 0x7a,
	0x07, 0xba, 0x42, 0xc2, 0x4b, 0x07, 0x94, 0x0d, 0xdf, 0x7e, 0x56, 0x64, 0xaf, 0xa0, 0x77, 0x01,
	0x44, 0xe3, 0x0c, 0x13, 0x74, 0x67, 0xd1, 0x45, 0x4b, 0xd8, 0xfc, 0x6f, 0x17, 0x83, 0xf2, 0x7b,
	0x8f, 0x1b, 0x0f, 0xfa, 0x5e, 0xfa, 0xe1, 0x29, 0xf6, 0x31, 0xc1, 0x68, 0x2b, 0xd3, 0xeb, 0xdc,
	0xed, 0xef, 0x1e, 0xf2, 0x77, 0x8e, 0x43, 0xf9, 0xce, 0x71, 0xf8, 0x64, 0x1a, 0x91, 0xb9, 0xbd,
	0x82, 0x4e, 0x16, 0xd9, 0x4b, 0x29, 0x01, 0xed, 0x65, 0x3e, 0x97, 0x54, 0xd1, 0xdf, 0xcd, 0xaa,
	0x68, 0xc2, 0xdb, 0x2b, 0xe8, 0xa3, 0x05, 0xaf, 0x88, 0x12, 0x04, 0xdd, 0xcf, 0x76, 0xd6, 0xaa,
	0x93, 0x12, 0x6b, 0xef, 0x43, 0x67, 0x51, 0x4b, 0x25, 0x2a, 0x90, 0xda, 0x19, 0xaa, 0x6f, 0x5c,
	0xca, 0x8a, 0x63, 0x0d, 0x73, 0x67, 0x57, 0x3f, 0x19, 0x3e, 0x0d, 0x63, 0x76, 0xc2, 0x44, 0xbd,
	0xbc, 0xd9, 0x2d, 0x71, 0xe7, 0xa3, 0xb4, 0xc0, 0x38, 0xc3, 0x24, 0xb5, 0x74, 0x2f, 0x77, 0x7e,
	0xf2, 0x1c, 0x5b, 0xec, 0xdb, 0x79, 0x5a, 0xad, 0xc9, 0x4d, 0x49, 0x44, 0x59, 0xc1, 0xe6, 0xdb,
	0x2f, 0x90, 0x6b, 0x8e, 0x49, 0x05, 0x8d, 0xbb, 0xbb, 0x19, 0xc7, 0x14, 0x12, 0x29, 0xb1, 0xf6,
	0x0c, 0x90, 0xba, 0xaf, 0x0b, 0xaf, 0x4a, 0x2a, 0x8a, 0x7e, 0x89, 0xce, 0x5e, 0x41, 0xa7, 0xb0,
	0xae, 0x4a, 0xa9, 0x6b, 0xb9, 0xa1, 0x59, 0x6e, 0xe5, 0x83, 0xf4, 0x96, 0x29, 0x91, 0x55, 0x5a,
	0xbe, 0x99, 0xec, 0x7a, 0xa8, 0x55, 0x1d, 0x43, 0x6b, 0x33, 0x73, 0x70, 0x43, 0xfb, 0xb9, 0x5f,
	0xa5, 0xa7, 0x3a, 0x75, 0x19, 0x15, 0xbd, 0xbd, 0x82, 0x2e, 0x01, 0x65, 0xaf, 0x0b, 0xd5, 0xa0,
	0xcf, 0xbd, 0x4c, 0xec, 0x97, 0x5c, 0xac, 0xdb, 0x2b, 0xe8, 0x43, 0x58, 0x5f, 0x50, 0x05, 0xb7,
	0xd8, 0x2f, 0x7a, 0xbb, 0xd3, 0x91, 0xcb, 0x31, 0xf6, 0x04, 0x36, 0xd9, 0x9d, 0x9f, 0x48, 0x18,
	0x6e, 0x4e, 0xc9, 0x25, 0xed, 0x42, 0x50, 0x9d, 0xa8, 0x72, 0xb7, 0xc8, 0xcc, 0x74, 0x94, 0x9b,
	0x58, 0x35, 0x81, 0xf4, 0x0b, 0xda, 0x25, 0xde, 0xbc, 0x0b, 0x6d, 0x4a, 0x23, 0xdc, 0x88, 0x39,
	0x98, 0x48, 0xc1, 0x6d, 0x43, 0x2c, 0x13, 0xf0, 0x14, 0xba, 0xda, 0x93, 0x82, 0x0a, 0x8a, 0xf9,
	0xd6, 0xd0, 0xcf, 0x7f, 0xa9, 0x61, 0x56, 0x3a, 0xca, 0x43, 0x8f, 0x3a, 0x11, 0xfd, 0x99, 0xaa,
	0xbf, 0x57, 0xa0, 0x61, 0x56, 0xde, 0x03, 0x58, 0x3c, 0xb4, 0x19, 0x1c, 0x7f, 0x33, 0x2f, 0xba,
	0xda, 0xc3, 0x9b, 0x3a, 0x17, 0xf3, 0x45, 0xae, 0xd8, 0xca, 0x31, 0x74, 0x39, 0xdb, 0x2f, 0x75,
	0xa4, 0x98, 0xf8, 0x7f, 0x0c, 0xdb, 0x79, 0x8f, 0xb5, 0xe8, 0x61, 0x36, 0x86, 0x8d, 0xc7, 0xdc,
	0x7e, 0xe9, 0x83, 0xb2, 0xbd, 0x82, 0x3e, 0x86, 0x4d, 0x16, 0xc7, 0x9a, 0xdd, 0xb2, 0x48, 0x5e,
	0x66, 0xf0, 0x33, 0x40, 0x74, 0x29, 0x0c, 0x8b, 0xfb, 0x45, 0x5f, 0x89, 0x78, 0x2a, 0xd2, 0x7b,
	0x78, 0x41, 0xed, 0xdb, 0x1c, 0xc7, 0x37, 0xf0, 0xb5, 0x10, 0xd1, 0xe3, 0xbd, 0x2f, 0x5f, 0xef,
	0x5b, 0x7f, 0x7f, 0xbd, 0x6f, 0xfd, 0xeb, 0xf5, 0xbe, 0xf5, 0xdb, 0x7f, 0xef, 0xaf, 0xfc, 0xa4,
	0x29, 0xaa, 0xdc, 0x51, 0x83, 0x75, 0x7e, 0xfb, 0x7f, 0x01, 0x00, 0x00, 0xff, 0xff, 0x92, 0xd9,
	0xd4, 0x9f, 0x90, 0x20, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// PatientServiceClient is the client API for PatientService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type PatientServiceClient interface {
	// Patient
	PatientCreate(ctx context.Context, in *Patient, opts ...grpc.CallOption) (*Patient, error)
	PatientGet(ctx context.Context, in *GetPatientReq, opts ...grpc.CallOption) (*Patient, error)
	PatientUpdate(ctx context.Context, in *Patient, opts ...grpc.CallOption) (*Patient, error)
	PatientDelete(ctx context.Context, in *PatientId, opts ...grpc.CallOption) (*empty.Empty, error)
	PatientsFind(ctx context.Context, in *PatientsFindReq, opts ...grpc.CallOption) (*PatientsResp, error)
	PatientsGetInfo(ctx context.Context, in *PatientsGetInfoFilter, opts ...grpc.CallOption) (*PatientsResp, error)
	// Uslug...
	AddServices(ctx context.Context, in *AddServiceReq, opts ...grpc.CallOption) (*CashStorage, error)
	// Filter kassa...
	PatientsFilterForKassa(ctx context.Context, in *PatientsFilter, opts ...grpc.CallOption) (*PatientsResp, error)
	PatientGetForKassa(ctx context.Context, in *PatientsGetKassaReq, opts ...grpc.CallOption) (*CashStorage, error)
	// Patient analysiss...
	PatientAnalysisCreate(ctx context.Context, in *AnalysisInfo, opts ...grpc.CallOption) (*AnalysisInfo, error)
	PatientAnalysisGet(ctx context.Context, in *PatientPhoneNumber, opts ...grpc.CallOption) (*AnalysisInfo, error)
	// Doctor reports...
	DoctorReportCreate(ctx context.Context, in *DoctorReportInfo, opts ...grpc.CallOption) (*DoctorReportInfo, error)
	DoctorReportGet(ctx context.Context, in *PatientId, opts ...grpc.CallOption) (*DoctorReportInfo, error)
	PatientsDebtInfo(ctx context.Context, in *PatientId, opts ...grpc.CallOption) (*PatientDebtInfoResp, error)
	PatientDebtCreate(ctx context.Context, in *PatientDebtCreateReq, opts ...grpc.CallOption) (*PatientDebt, error)
	CreatePatientQueue(ctx context.Context, in *CreatePatientQueueReq, opts ...grpc.CallOption) (*PatientQueueResp, error)
	GetPatientQueue(ctx context.Context, in *PaymentHistoryId, opts ...grpc.CallOption) (*PatientQueueResp, error)
	CheckServiceQueue(ctx context.Context, in *CheckQueueReq, opts ...grpc.CallOption) (*QueueNumber, error)
	UpdateQueue(ctx context.Context, in *UpdateQueueReq, opts ...grpc.CallOption) (*PatientQueueResp, error)
	FindQueue(ctx context.Context, in *QueueFilter, opts ...grpc.CallOption) (*QueuesResp, error)
	// CashBox
	CreateCashbox(ctx context.Context, in *CreateCashboxReq, opts ...grpc.CallOption) (*CashboxResp, error)
	FindCashbox(ctx context.Context, in *FindCashboxReq, opts ...grpc.CallOption) (*FindCashboxResp, error)
	GetCashbox(ctx context.Context, in *GetCashboxReq, opts ...grpc.CallOption) (*CashboxResp, error)
	UpdateCashbox(ctx context.Context, in *UpdateCashboxReq, opts ...grpc.CallOption) (*CashboxResp, error)
	DeleteCashbox(ctx context.Context, in *GetCashboxReq, opts ...grpc.CallOption) (*empty.Empty, error)
	// Payment History
	CreatePaymentHistory(ctx context.Context, in *CreatePaymentHistoryReq, opts ...grpc.CallOption) (*PaymentHistoryResp, error)
	GetPaymentHistory(ctx context.Context, in *PaymentHistoryId, opts ...grpc.CallOption) (*PaymentHistoryResp, error)
	FindPaymentHistory(ctx context.Context, in *PaymentHistoryFilter, opts ...grpc.CallOption) (*PaymentHistoriesResp, error)
	DeletePaymentHistory(ctx context.Context, in *PaymentHistoryId, opts ...grpc.CallOption) (*empty.Empty, error)
}

type patientServiceClient struct {
	cc *grpc.ClientConn
}

func NewPatientServiceClient(cc *grpc.ClientConn) PatientServiceClient {
	return &patientServiceClient{cc}
}

func (c *patientServiceClient) PatientCreate(ctx context.Context, in *Patient, opts ...grpc.CallOption) (*Patient, error) {
	out := new(Patient)
	err := c.cc.Invoke(ctx, "/genproto.PatientService/PatientCreate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *patientServiceClient) PatientGet(ctx context.Context, in *GetPatientReq, opts ...grpc.CallOption) (*Patient, error) {
	out := new(Patient)
	err := c.cc.Invoke(ctx, "/genproto.PatientService/PatientGet", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *patientServiceClient) PatientUpdate(ctx context.Context, in *Patient, opts ...grpc.CallOption) (*Patient, error) {
	out := new(Patient)
	err := c.cc.Invoke(ctx, "/genproto.PatientService/PatientUpdate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *patientServiceClient) PatientDelete(ctx context.Context, in *PatientId, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/genproto.PatientService/PatientDelete", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *patientServiceClient) PatientsFind(ctx context.Context, in *PatientsFindReq, opts ...grpc.CallOption) (*PatientsResp, error) {
	out := new(PatientsResp)
	err := c.cc.Invoke(ctx, "/genproto.PatientService/PatientsFind", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *patientServiceClient) PatientsGetInfo(ctx context.Context, in *PatientsGetInfoFilter, opts ...grpc.CallOption) (*PatientsResp, error) {
	out := new(PatientsResp)
	err := c.cc.Invoke(ctx, "/genproto.PatientService/PatientsGetInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *patientServiceClient) AddServices(ctx context.Context, in *AddServiceReq, opts ...grpc.CallOption) (*CashStorage, error) {
	out := new(CashStorage)
	err := c.cc.Invoke(ctx, "/genproto.PatientService/AddServices", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *patientServiceClient) PatientsFilterForKassa(ctx context.Context, in *PatientsFilter, opts ...grpc.CallOption) (*PatientsResp, error) {
	out := new(PatientsResp)
	err := c.cc.Invoke(ctx, "/genproto.PatientService/PatientsFilterForKassa", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *patientServiceClient) PatientGetForKassa(ctx context.Context, in *PatientsGetKassaReq, opts ...grpc.CallOption) (*CashStorage, error) {
	out := new(CashStorage)
	err := c.cc.Invoke(ctx, "/genproto.PatientService/PatientGetForKassa", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *patientServiceClient) PatientAnalysisCreate(ctx context.Context, in *AnalysisInfo, opts ...grpc.CallOption) (*AnalysisInfo, error) {
	out := new(AnalysisInfo)
	err := c.cc.Invoke(ctx, "/genproto.PatientService/PatientAnalysisCreate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *patientServiceClient) PatientAnalysisGet(ctx context.Context, in *PatientPhoneNumber, opts ...grpc.CallOption) (*AnalysisInfo, error) {
	out := new(AnalysisInfo)
	err := c.cc.Invoke(ctx, "/genproto.PatientService/PatientAnalysisGet", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *patientServiceClient) DoctorReportCreate(ctx context.Context, in *DoctorReportInfo, opts ...grpc.CallOption) (*DoctorReportInfo, error) {
	out := new(DoctorReportInfo)
	err := c.cc.Invoke(ctx, "/genproto.PatientService/DoctorReportCreate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *patientServiceClient) DoctorReportGet(ctx context.Context, in *PatientId, opts ...grpc.CallOption) (*DoctorReportInfo, error) {
	out := new(DoctorReportInfo)
	err := c.cc.Invoke(ctx, "/genproto.PatientService/DoctorReportGet", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *patientServiceClient) PatientsDebtInfo(ctx context.Context, in *PatientId, opts ...grpc.CallOption) (*PatientDebtInfoResp, error) {
	out := new(PatientDebtInfoResp)
	err := c.cc.Invoke(ctx, "/genproto.PatientService/PatientsDebtInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *patientServiceClient) PatientDebtCreate(ctx context.Context, in *PatientDebtCreateReq, opts ...grpc.CallOption) (*PatientDebt, error) {
	out := new(PatientDebt)
	err := c.cc.Invoke(ctx, "/genproto.PatientService/PatientDebtCreate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *patientServiceClient) CreatePatientQueue(ctx context.Context, in *CreatePatientQueueReq, opts ...grpc.CallOption) (*PatientQueueResp, error) {
	out := new(PatientQueueResp)
	err := c.cc.Invoke(ctx, "/genproto.PatientService/CreatePatientQueue", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *patientServiceClient) GetPatientQueue(ctx context.Context, in *PaymentHistoryId, opts ...grpc.CallOption) (*PatientQueueResp, error) {
	out := new(PatientQueueResp)
	err := c.cc.Invoke(ctx, "/genproto.PatientService/GetPatientQueue", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *patientServiceClient) CheckServiceQueue(ctx context.Context, in *CheckQueueReq, opts ...grpc.CallOption) (*QueueNumber, error) {
	out := new(QueueNumber)
	err := c.cc.Invoke(ctx, "/genproto.PatientService/CheckServiceQueue", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *patientServiceClient) UpdateQueue(ctx context.Context, in *UpdateQueueReq, opts ...grpc.CallOption) (*PatientQueueResp, error) {
	out := new(PatientQueueResp)
	err := c.cc.Invoke(ctx, "/genproto.PatientService/UpdateQueue", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *patientServiceClient) FindQueue(ctx context.Context, in *QueueFilter, opts ...grpc.CallOption) (*QueuesResp, error) {
	out := new(QueuesResp)
	err := c.cc.Invoke(ctx, "/genproto.PatientService/FindQueue", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *patientServiceClient) CreateCashbox(ctx context.Context, in *CreateCashboxReq, opts ...grpc.CallOption) (*CashboxResp, error) {
	out := new(CashboxResp)
	err := c.cc.Invoke(ctx, "/genproto.PatientService/CreateCashbox", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *patientServiceClient) FindCashbox(ctx context.Context, in *FindCashboxReq, opts ...grpc.CallOption) (*FindCashboxResp, error) {
	out := new(FindCashboxResp)
	err := c.cc.Invoke(ctx, "/genproto.PatientService/FindCashbox", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *patientServiceClient) GetCashbox(ctx context.Context, in *GetCashboxReq, opts ...grpc.CallOption) (*CashboxResp, error) {
	out := new(CashboxResp)
	err := c.cc.Invoke(ctx, "/genproto.PatientService/GetCashbox", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *patientServiceClient) UpdateCashbox(ctx context.Context, in *UpdateCashboxReq, opts ...grpc.CallOption) (*CashboxResp, error) {
	out := new(CashboxResp)
	err := c.cc.Invoke(ctx, "/genproto.PatientService/UpdateCashbox", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *patientServiceClient) DeleteCashbox(ctx context.Context, in *GetCashboxReq, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/genproto.PatientService/DeleteCashbox", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *patientServiceClient) CreatePaymentHistory(ctx context.Context, in *CreatePaymentHistoryReq, opts ...grpc.CallOption) (*PaymentHistoryResp, error) {
	out := new(PaymentHistoryResp)
	err := c.cc.Invoke(ctx, "/genproto.PatientService/CreatePaymentHistory", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *patientServiceClient) GetPaymentHistory(ctx context.Context, in *PaymentHistoryId, opts ...grpc.CallOption) (*PaymentHistoryResp, error) {
	out := new(PaymentHistoryResp)
	err := c.cc.Invoke(ctx, "/genproto.PatientService/GetPaymentHistory", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *patientServiceClient) FindPaymentHistory(ctx context.Context, in *PaymentHistoryFilter, opts ...grpc.CallOption) (*PaymentHistoriesResp, error) {
	out := new(PaymentHistoriesResp)
	err := c.cc.Invoke(ctx, "/genproto.PatientService/FindPaymentHistory", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *patientServiceClient) DeletePaymentHistory(ctx context.Context, in *PaymentHistoryId, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/genproto.PatientService/DeletePaymentHistory", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// PatientServiceServer is the server API for PatientService service.
type PatientServiceServer interface {
	// Patient
	PatientCreate(context.Context, *Patient) (*Patient, error)
	PatientGet(context.Context, *GetPatientReq) (*Patient, error)
	PatientUpdate(context.Context, *Patient) (*Patient, error)
	PatientDelete(context.Context, *PatientId) (*empty.Empty, error)
	PatientsFind(context.Context, *PatientsFindReq) (*PatientsResp, error)
	PatientsGetInfo(context.Context, *PatientsGetInfoFilter) (*PatientsResp, error)
	// Uslug...
	AddServices(context.Context, *AddServiceReq) (*CashStorage, error)
	// Filter kassa...
	PatientsFilterForKassa(context.Context, *PatientsFilter) (*PatientsResp, error)
	PatientGetForKassa(context.Context, *PatientsGetKassaReq) (*CashStorage, error)
	// Patient analysiss...
	PatientAnalysisCreate(context.Context, *AnalysisInfo) (*AnalysisInfo, error)
	PatientAnalysisGet(context.Context, *PatientPhoneNumber) (*AnalysisInfo, error)
	// Doctor reports...
	DoctorReportCreate(context.Context, *DoctorReportInfo) (*DoctorReportInfo, error)
	DoctorReportGet(context.Context, *PatientId) (*DoctorReportInfo, error)
	PatientsDebtInfo(context.Context, *PatientId) (*PatientDebtInfoResp, error)
	PatientDebtCreate(context.Context, *PatientDebtCreateReq) (*PatientDebt, error)
	CreatePatientQueue(context.Context, *CreatePatientQueueReq) (*PatientQueueResp, error)
	GetPatientQueue(context.Context, *PaymentHistoryId) (*PatientQueueResp, error)
	CheckServiceQueue(context.Context, *CheckQueueReq) (*QueueNumber, error)
	UpdateQueue(context.Context, *UpdateQueueReq) (*PatientQueueResp, error)
	FindQueue(context.Context, *QueueFilter) (*QueuesResp, error)
	// CashBox
	CreateCashbox(context.Context, *CreateCashboxReq) (*CashboxResp, error)
	FindCashbox(context.Context, *FindCashboxReq) (*FindCashboxResp, error)
	GetCashbox(context.Context, *GetCashboxReq) (*CashboxResp, error)
	UpdateCashbox(context.Context, *UpdateCashboxReq) (*CashboxResp, error)
	DeleteCashbox(context.Context, *GetCashboxReq) (*empty.Empty, error)
	// Payment History
	CreatePaymentHistory(context.Context, *CreatePaymentHistoryReq) (*PaymentHistoryResp, error)
	GetPaymentHistory(context.Context, *PaymentHistoryId) (*PaymentHistoryResp, error)
	FindPaymentHistory(context.Context, *PaymentHistoryFilter) (*PaymentHistoriesResp, error)
	DeletePaymentHistory(context.Context, *PaymentHistoryId) (*empty.Empty, error)
}

// UnimplementedPatientServiceServer can be embedded to have forward compatible implementations.
type UnimplementedPatientServiceServer struct {
}

func (*UnimplementedPatientServiceServer) PatientCreate(ctx context.Context, req *Patient) (*Patient, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PatientCreate not implemented")
}
func (*UnimplementedPatientServiceServer) PatientGet(ctx context.Context, req *GetPatientReq) (*Patient, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PatientGet not implemented")
}
func (*UnimplementedPatientServiceServer) PatientUpdate(ctx context.Context, req *Patient) (*Patient, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PatientUpdate not implemented")
}
func (*UnimplementedPatientServiceServer) PatientDelete(ctx context.Context, req *PatientId) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PatientDelete not implemented")
}
func (*UnimplementedPatientServiceServer) PatientsFind(ctx context.Context, req *PatientsFindReq) (*PatientsResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PatientsFind not implemented")
}
func (*UnimplementedPatientServiceServer) PatientsGetInfo(ctx context.Context, req *PatientsGetInfoFilter) (*PatientsResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PatientsGetInfo not implemented")
}
func (*UnimplementedPatientServiceServer) AddServices(ctx context.Context, req *AddServiceReq) (*CashStorage, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddServices not implemented")
}
func (*UnimplementedPatientServiceServer) PatientsFilterForKassa(ctx context.Context, req *PatientsFilter) (*PatientsResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PatientsFilterForKassa not implemented")
}
func (*UnimplementedPatientServiceServer) PatientGetForKassa(ctx context.Context, req *PatientsGetKassaReq) (*CashStorage, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PatientGetForKassa not implemented")
}
func (*UnimplementedPatientServiceServer) PatientAnalysisCreate(ctx context.Context, req *AnalysisInfo) (*AnalysisInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PatientAnalysisCreate not implemented")
}
func (*UnimplementedPatientServiceServer) PatientAnalysisGet(ctx context.Context, req *PatientPhoneNumber) (*AnalysisInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PatientAnalysisGet not implemented")
}
func (*UnimplementedPatientServiceServer) DoctorReportCreate(ctx context.Context, req *DoctorReportInfo) (*DoctorReportInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DoctorReportCreate not implemented")
}
func (*UnimplementedPatientServiceServer) DoctorReportGet(ctx context.Context, req *PatientId) (*DoctorReportInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DoctorReportGet not implemented")
}
func (*UnimplementedPatientServiceServer) PatientsDebtInfo(ctx context.Context, req *PatientId) (*PatientDebtInfoResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PatientsDebtInfo not implemented")
}
func (*UnimplementedPatientServiceServer) PatientDebtCreate(ctx context.Context, req *PatientDebtCreateReq) (*PatientDebt, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PatientDebtCreate not implemented")
}
func (*UnimplementedPatientServiceServer) CreatePatientQueue(ctx context.Context, req *CreatePatientQueueReq) (*PatientQueueResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreatePatientQueue not implemented")
}
func (*UnimplementedPatientServiceServer) GetPatientQueue(ctx context.Context, req *PaymentHistoryId) (*PatientQueueResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetPatientQueue not implemented")
}
func (*UnimplementedPatientServiceServer) CheckServiceQueue(ctx context.Context, req *CheckQueueReq) (*QueueNumber, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CheckServiceQueue not implemented")
}
func (*UnimplementedPatientServiceServer) UpdateQueue(ctx context.Context, req *UpdateQueueReq) (*PatientQueueResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateQueue not implemented")
}
func (*UnimplementedPatientServiceServer) FindQueue(ctx context.Context, req *QueueFilter) (*QueuesResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FindQueue not implemented")
}
func (*UnimplementedPatientServiceServer) CreateCashbox(ctx context.Context, req *CreateCashboxReq) (*CashboxResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateCashbox not implemented")
}
func (*UnimplementedPatientServiceServer) FindCashbox(ctx context.Context, req *FindCashboxReq) (*FindCashboxResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FindCashbox not implemented")
}
func (*UnimplementedPatientServiceServer) GetCashbox(ctx context.Context, req *GetCashboxReq) (*CashboxResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetCashbox not implemented")
}
func (*UnimplementedPatientServiceServer) UpdateCashbox(ctx context.Context, req *UpdateCashboxReq) (*CashboxResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateCashbox not implemented")
}
func (*UnimplementedPatientServiceServer) DeleteCashbox(ctx context.Context, req *GetCashboxReq) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteCashbox not implemented")
}
func (*UnimplementedPatientServiceServer) CreatePaymentHistory(ctx context.Context, req *CreatePaymentHistoryReq) (*PaymentHistoryResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreatePaymentHistory not implemented")
}
func (*UnimplementedPatientServiceServer) GetPaymentHistory(ctx context.Context, req *PaymentHistoryId) (*PaymentHistoryResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetPaymentHistory not implemented")
}
func (*UnimplementedPatientServiceServer) FindPaymentHistory(ctx context.Context, req *PaymentHistoryFilter) (*PaymentHistoriesResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FindPaymentHistory not implemented")
}
func (*UnimplementedPatientServiceServer) DeletePaymentHistory(ctx context.Context, req *PaymentHistoryId) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeletePaymentHistory not implemented")
}

func RegisterPatientServiceServer(s *grpc.Server, srv PatientServiceServer) {
	s.RegisterService(&_PatientService_serviceDesc, srv)
}

func _PatientService_PatientCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Patient)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PatientServiceServer).PatientCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/genproto.PatientService/PatientCreate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PatientServiceServer).PatientCreate(ctx, req.(*Patient))
	}
	return interceptor(ctx, in, info, handler)
}

func _PatientService_PatientGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetPatientReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PatientServiceServer).PatientGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/genproto.PatientService/PatientGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PatientServiceServer).PatientGet(ctx, req.(*GetPatientReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _PatientService_PatientUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Patient)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PatientServiceServer).PatientUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/genproto.PatientService/PatientUpdate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PatientServiceServer).PatientUpdate(ctx, req.(*Patient))
	}
	return interceptor(ctx, in, info, handler)
}

func _PatientService_PatientDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PatientId)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PatientServiceServer).PatientDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/genproto.PatientService/PatientDelete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PatientServiceServer).PatientDelete(ctx, req.(*PatientId))
	}
	return interceptor(ctx, in, info, handler)
}

func _PatientService_PatientsFind_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PatientsFindReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PatientServiceServer).PatientsFind(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/genproto.PatientService/PatientsFind",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PatientServiceServer).PatientsFind(ctx, req.(*PatientsFindReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _PatientService_PatientsGetInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PatientsGetInfoFilter)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PatientServiceServer).PatientsGetInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/genproto.PatientService/PatientsGetInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PatientServiceServer).PatientsGetInfo(ctx, req.(*PatientsGetInfoFilter))
	}
	return interceptor(ctx, in, info, handler)
}

func _PatientService_AddServices_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddServiceReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PatientServiceServer).AddServices(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/genproto.PatientService/AddServices",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PatientServiceServer).AddServices(ctx, req.(*AddServiceReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _PatientService_PatientsFilterForKassa_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PatientsFilter)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PatientServiceServer).PatientsFilterForKassa(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/genproto.PatientService/PatientsFilterForKassa",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PatientServiceServer).PatientsFilterForKassa(ctx, req.(*PatientsFilter))
	}
	return interceptor(ctx, in, info, handler)
}

func _PatientService_PatientGetForKassa_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PatientsGetKassaReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PatientServiceServer).PatientGetForKassa(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/genproto.PatientService/PatientGetForKassa",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PatientServiceServer).PatientGetForKassa(ctx, req.(*PatientsGetKassaReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _PatientService_PatientAnalysisCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AnalysisInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PatientServiceServer).PatientAnalysisCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/genproto.PatientService/PatientAnalysisCreate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PatientServiceServer).PatientAnalysisCreate(ctx, req.(*AnalysisInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _PatientService_PatientAnalysisGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PatientPhoneNumber)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PatientServiceServer).PatientAnalysisGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/genproto.PatientService/PatientAnalysisGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PatientServiceServer).PatientAnalysisGet(ctx, req.(*PatientPhoneNumber))
	}
	return interceptor(ctx, in, info, handler)
}

func _PatientService_DoctorReportCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DoctorReportInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PatientServiceServer).DoctorReportCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/genproto.PatientService/DoctorReportCreate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PatientServiceServer).DoctorReportCreate(ctx, req.(*DoctorReportInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _PatientService_DoctorReportGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PatientId)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PatientServiceServer).DoctorReportGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/genproto.PatientService/DoctorReportGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PatientServiceServer).DoctorReportGet(ctx, req.(*PatientId))
	}
	return interceptor(ctx, in, info, handler)
}

func _PatientService_PatientsDebtInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PatientId)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PatientServiceServer).PatientsDebtInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/genproto.PatientService/PatientsDebtInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PatientServiceServer).PatientsDebtInfo(ctx, req.(*PatientId))
	}
	return interceptor(ctx, in, info, handler)
}

func _PatientService_PatientDebtCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PatientDebtCreateReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PatientServiceServer).PatientDebtCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/genproto.PatientService/PatientDebtCreate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PatientServiceServer).PatientDebtCreate(ctx, req.(*PatientDebtCreateReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _PatientService_CreatePatientQueue_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreatePatientQueueReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PatientServiceServer).CreatePatientQueue(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/genproto.PatientService/CreatePatientQueue",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PatientServiceServer).CreatePatientQueue(ctx, req.(*CreatePatientQueueReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _PatientService_GetPatientQueue_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PaymentHistoryId)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PatientServiceServer).GetPatientQueue(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/genproto.PatientService/GetPatientQueue",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PatientServiceServer).GetPatientQueue(ctx, req.(*PaymentHistoryId))
	}
	return interceptor(ctx, in, info, handler)
}

func _PatientService_CheckServiceQueue_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CheckQueueReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PatientServiceServer).CheckServiceQueue(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/genproto.PatientService/CheckServiceQueue",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PatientServiceServer).CheckServiceQueue(ctx, req.(*CheckQueueReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _PatientService_UpdateQueue_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateQueueReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PatientServiceServer).UpdateQueue(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/genproto.PatientService/UpdateQueue",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PatientServiceServer).UpdateQueue(ctx, req.(*UpdateQueueReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _PatientService_FindQueue_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueueFilter)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PatientServiceServer).FindQueue(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/genproto.PatientService/FindQueue",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PatientServiceServer).FindQueue(ctx, req.(*QueueFilter))
	}
	return interceptor(ctx, in, info, handler)
}

func _PatientService_CreateCashbox_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateCashboxReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PatientServiceServer).CreateCashbox(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/genproto.PatientService/CreateCashbox",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PatientServiceServer).CreateCashbox(ctx, req.(*CreateCashboxReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _PatientService_FindCashbox_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FindCashboxReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PatientServiceServer).FindCashbox(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/genproto.PatientService/FindCashbox",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PatientServiceServer).FindCashbox(ctx, req.(*FindCashboxReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _PatientService_GetCashbox_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetCashboxReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PatientServiceServer).GetCashbox(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/genproto.PatientService/GetCashbox",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PatientServiceServer).GetCashbox(ctx, req.(*GetCashboxReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _PatientService_UpdateCashbox_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateCashboxReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PatientServiceServer).UpdateCashbox(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/genproto.PatientService/UpdateCashbox",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PatientServiceServer).UpdateCashbox(ctx, req.(*UpdateCashboxReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _PatientService_DeleteCashbox_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetCashboxReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PatientServiceServer).DeleteCashbox(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/genproto.PatientService/DeleteCashbox",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PatientServiceServer).DeleteCashbox(ctx, req.(*GetCashboxReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _PatientService_CreatePaymentHistory_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreatePaymentHistoryReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PatientServiceServer).CreatePaymentHistory(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/genproto.PatientService/CreatePaymentHistory",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PatientServiceServer).CreatePaymentHistory(ctx, req.(*CreatePaymentHistoryReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _PatientService_GetPaymentHistory_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PaymentHistoryId)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PatientServiceServer).GetPaymentHistory(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/genproto.PatientService/GetPaymentHistory",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PatientServiceServer).GetPaymentHistory(ctx, req.(*PaymentHistoryId))
	}
	return interceptor(ctx, in, info, handler)
}

func _PatientService_FindPaymentHistory_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PaymentHistoryFilter)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PatientServiceServer).FindPaymentHistory(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/genproto.PatientService/FindPaymentHistory",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PatientServiceServer).FindPaymentHistory(ctx, req.(*PaymentHistoryFilter))
	}
	return interceptor(ctx, in, info, handler)
}

func _PatientService_DeletePaymentHistory_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PaymentHistoryId)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PatientServiceServer).DeletePaymentHistory(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/genproto.PatientService/DeletePaymentHistory",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PatientServiceServer).DeletePaymentHistory(ctx, req.(*PaymentHistoryId))
	}
	return interceptor(ctx, in, info, handler)
}

var _PatientService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "genproto.PatientService",
	HandlerType: (*PatientServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "PatientCreate",
			Handler:    _PatientService_PatientCreate_Handler,
		},
		{
			MethodName: "PatientGet",
			Handler:    _PatientService_PatientGet_Handler,
		},
		{
			MethodName: "PatientUpdate",
			Handler:    _PatientService_PatientUpdate_Handler,
		},
		{
			MethodName: "PatientDelete",
			Handler:    _PatientService_PatientDelete_Handler,
		},
		{
			MethodName: "PatientsFind",
			Handler:    _PatientService_PatientsFind_Handler,
		},
		{
			MethodName: "PatientsGetInfo",
			Handler:    _PatientService_PatientsGetInfo_Handler,
		},
		{
			MethodName: "AddServices",
			Handler:    _PatientService_AddServices_Handler,
		},
		{
			MethodName: "PatientsFilterForKassa",
			Handler:    _PatientService_PatientsFilterForKassa_Handler,
		},
		{
			MethodName: "PatientGetForKassa",
			Handler:    _PatientService_PatientGetForKassa_Handler,
		},
		{
			MethodName: "PatientAnalysisCreate",
			Handler:    _PatientService_PatientAnalysisCreate_Handler,
		},
		{
			MethodName: "PatientAnalysisGet",
			Handler:    _PatientService_PatientAnalysisGet_Handler,
		},
		{
			MethodName: "DoctorReportCreate",
			Handler:    _PatientService_DoctorReportCreate_Handler,
		},
		{
			MethodName: "DoctorReportGet",
			Handler:    _PatientService_DoctorReportGet_Handler,
		},
		{
			MethodName: "PatientsDebtInfo",
			Handler:    _PatientService_PatientsDebtInfo_Handler,
		},
		{
			MethodName: "PatientDebtCreate",
			Handler:    _PatientService_PatientDebtCreate_Handler,
		},
		{
			MethodName: "CreatePatientQueue",
			Handler:    _PatientService_CreatePatientQueue_Handler,
		},
		{
			MethodName: "GetPatientQueue",
			Handler:    _PatientService_GetPatientQueue_Handler,
		},
		{
			MethodName: "CheckServiceQueue",
			Handler:    _PatientService_CheckServiceQueue_Handler,
		},
		{
			MethodName: "UpdateQueue",
			Handler:    _PatientService_UpdateQueue_Handler,
		},
		{
			MethodName: "FindQueue",
			Handler:    _PatientService_FindQueue_Handler,
		},
		{
			MethodName: "CreateCashbox",
			Handler:    _PatientService_CreateCashbox_Handler,
		},
		{
			MethodName: "FindCashbox",
			Handler:    _PatientService_FindCashbox_Handler,
		},
		{
			MethodName: "GetCashbox",
			Handler:    _PatientService_GetCashbox_Handler,
		},
		{
			MethodName: "UpdateCashbox",
			Handler:    _PatientService_UpdateCashbox_Handler,
		},
		{
			MethodName: "DeleteCashbox",
			Handler:    _PatientService_DeleteCashbox_Handler,
		},
		{
			MethodName: "CreatePaymentHistory",
			Handler:    _PatientService_CreatePaymentHistory_Handler,
		},
		{
			MethodName: "GetPaymentHistory",
			Handler:    _PatientService_GetPaymentHistory_Handler,
		},
		{
			MethodName: "FindPaymentHistory",
			Handler:    _PatientService_FindPaymentHistory_Handler,
		},
		{
			MethodName: "DeletePaymentHistory",
			Handler:    _PatientService_DeletePaymentHistory_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "patient/patient.proto",
}

func (m *PaymentHistoryFilter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PaymentHistoryFilter) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PaymentHistoryFilter) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ToDate) > 0 {
		i -= len(m.ToDate)
		copy(dAtA[i:], m.ToDate)
		i = encodeVarintPatient(dAtA, i, uint64(len(m.ToDate)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.FromDate) > 0 {
		i -= len(m.FromDate)
		copy(dAtA[i:], m.FromDate)
		i = encodeVarintPatient(dAtA, i, uint64(len(m.FromDate)))
		i--
		dAtA[i] = 0x22
	}
	if m.Page != 0 {
		i = encodeVarintPatient(dAtA, i, uint64(m.Page))
		i--
		dAtA[i] = 0x18
	}
	if m.Limit != 0 {
		i = encodeVarintPatient(dAtA, i, uint64(m.Limit))
		i--
		dAtA[i] = 0x10
	}
	if m.ClientId != 0 {
		i = encodeVarintPatient(dAtA, i, uint64(m.ClientId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PaymentHistoriesResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PaymentHistoriesResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PaymentHistoriesResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Count != 0 {
		i = encodeVarintPatient(dAtA, i, uint64(m.Count))
		i--
		dAtA[i] = 0x10
	}
	if len(m.PaymentHistory) > 0 {
		for iNdEx := len(m.PaymentHistory) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.PaymentHistory[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPatient(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *PaymentHistoryId) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PaymentHistoryId) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PaymentHistoryId) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintPatient(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CreatePaymentHistoryReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreatePaymentHistoryReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreatePaymentHistoryReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.CashboxId) > 0 {
		i -= len(m.CashboxId)
		copy(dAtA[i:], m.CashboxId)
		i = encodeVarintPatient(dAtA, i, uint64(len(m.CashboxId)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.PaymentType) > 0 {
		i -= len(m.PaymentType)
		copy(dAtA[i:], m.PaymentType)
		i = encodeVarintPatient(dAtA, i, uint64(len(m.PaymentType)))
		i--
		dAtA[i] = 0x22
	}
	if m.Summa != 0 {
		i = encodeVarintPatient(dAtA, i, uint64(m.Summa))
		i--
		dAtA[i] = 0x18
	}
	if m.ClientId != 0 {
		i = encodeVarintPatient(dAtA, i, uint64(m.ClientId))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintPatient(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PaymentHistoryResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PaymentHistoryResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PaymentHistoryResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.UpdatedAt) > 0 {
		i -= len(m.UpdatedAt)
		copy(dAtA[i:], m.UpdatedAt)
		i = encodeVarintPatient(dAtA, i, uint64(len(m.UpdatedAt)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.CreatedAt) > 0 {
		i -= len(m.CreatedAt)
		copy(dAtA[i:], m.CreatedAt)
		i = encodeVarintPatient(dAtA, i, uint64(len(m.CreatedAt)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.CashboxId) > 0 {
		i -= len(m.CashboxId)
		copy(dAtA[i:], m.CashboxId)
		i = encodeVarintPatient(dAtA, i, uint64(len(m.CashboxId)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.PaymentType) > 0 {
		i -= len(m.PaymentType)
		copy(dAtA[i:], m.PaymentType)
		i = encodeVarintPatient(dAtA, i, uint64(len(m.PaymentType)))
		i--
		dAtA[i] = 0x22
	}
	if m.Summa != 0 {
		i = encodeVarintPatient(dAtA, i, uint64(m.Summa))
		i--
		dAtA[i] = 0x18
	}
	if m.ClientId != 0 {
		i = encodeVarintPatient(dAtA, i, uint64(m.ClientId))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintPatient(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetCashboxReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetCashboxReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetCashboxReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.CashboxId) > 0 {
		i -= len(m.CashboxId)
		copy(dAtA[i:], m.CashboxId)
		i = encodeVarintPatient(dAtA, i, uint64(len(m.CashboxId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UpdateCashboxReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateCashboxReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateCashboxReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.PaymentType) > 0 {
		i -= len(m.PaymentType)
		copy(dAtA[i:], m.PaymentType)
		i = encodeVarintPatient(dAtA, i, uint64(len(m.PaymentType)))
		i--
		dAtA[i] = 0x1a
	}
	if m.IsPayed {
		i--
		if m.IsPayed {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintPatient(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *FindCashboxReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FindCashboxReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FindCashboxReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ToDate) > 0 {
		i -= len(m.ToDate)
		copy(dAtA[i:], m.ToDate)
		i = encodeVarintPatient(dAtA, i, uint64(len(m.ToDate)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.FromDate) > 0 {
		i -= len(m.FromDate)
		copy(dAtA[i:], m.FromDate)
		i = encodeVarintPatient(dAtA, i, uint64(len(m.FromDate)))
		i--
		dAtA[i] = 0x2a
	}
	if m.Limit != 0 {
		i = encodeVarintPatient(dAtA, i, uint64(m.Limit))
		i--
		dAtA[i] = 0x20
	}
	if m.Page != 0 {
		i = encodeVarintPatient(dAtA, i, uint64(m.Page))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Search) > 0 {
		i -= len(m.Search)
		copy(dAtA[i:], m.Search)
		i = encodeVarintPatient(dAtA, i, uint64(len(m.Search)))
		i--
		dAtA[i] = 0x12
	}
	if m.ClientId != 0 {
		i = encodeVarintPatient(dAtA, i, uint64(m.ClientId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *FindCashboxResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FindCashboxResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FindCashboxResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Count != 0 {
		i = encodeVarintPatient(dAtA, i, uint64(m.Count))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Cashboxes) > 0 {
		for iNdEx := len(m.Cashboxes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Cashboxes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPatient(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *QueueFilter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueueFilter) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueueFilter) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Limit != 0 {
		i = encodeVarintPatient(dAtA, i, uint64(m.Limit))
		i--
		dAtA[i] = 0x28
	}
	if m.Page != 0 {
		i = encodeVarintPatient(dAtA, i, uint64(m.Page))
		i--
		dAtA[i] = 0x20
	}
	if m.ClientId != 0 {
		i = encodeVarintPatient(dAtA, i, uint64(m.ClientId))
		i--
		dAtA[i] = 0x18
	}
	if len(m.ServiceType) > 0 {
		i -= len(m.ServiceType)
		copy(dAtA[i:], m.ServiceType)
		i = encodeVarintPatient(dAtA, i, uint64(len(m.ServiceType)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ServiceId) > 0 {
		i -= len(m.ServiceId)
		copy(dAtA[i:], m.ServiceId)
		i = encodeVarintPatient(dAtA, i, uint64(len(m.ServiceId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QueuesResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueuesResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueuesResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Count != 0 {
		i = encodeVarintPatient(dAtA, i, uint64(m.Count))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Queues) > 0 {
		for iNdEx := len(m.Queues) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Queues[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPatient(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *CreateCashboxReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateCashboxReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateCashboxReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.AparatsIds) > 0 {
		for iNdEx := len(m.AparatsIds) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.AparatsIds[iNdEx])
			copy(dAtA[i:], m.AparatsIds[iNdEx])
			i = encodeVarintPatient(dAtA, i, uint64(len(m.AparatsIds[iNdEx])))
			i--
			dAtA[i] = 0x42
		}
	}
	if len(m.LabsIds) > 0 {
		for iNdEx := len(m.LabsIds) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.LabsIds[iNdEx])
			copy(dAtA[i:], m.LabsIds[iNdEx])
			i = encodeVarintPatient(dAtA, i, uint64(len(m.LabsIds[iNdEx])))
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.DoctorsIds) > 0 {
		for iNdEx := len(m.DoctorsIds) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.DoctorsIds[iNdEx])
			copy(dAtA[i:], m.DoctorsIds[iNdEx])
			i = encodeVarintPatient(dAtA, i, uint64(len(m.DoctorsIds[iNdEx])))
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.PaymentType) > 0 {
		i -= len(m.PaymentType)
		copy(dAtA[i:], m.PaymentType)
		i = encodeVarintPatient(dAtA, i, uint64(len(m.PaymentType)))
		i--
		dAtA[i] = 0x2a
	}
	if m.CashCount != 0 {
		i = encodeVarintPatient(dAtA, i, uint64(m.CashCount))
		i--
		dAtA[i] = 0x20
	}
	if m.IsPayed {
		i--
		if m.IsPayed {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.ClientId != 0 {
		i = encodeVarintPatient(dAtA, i, uint64(m.ClientId))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintPatient(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CashboxResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CashboxResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CashboxResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.UpdatedAt) > 0 {
		i -= len(m.UpdatedAt)
		copy(dAtA[i:], m.UpdatedAt)
		i = encodeVarintPatient(dAtA, i, uint64(len(m.UpdatedAt)))
		i--
		dAtA[i] = 0x5a
	}
	if len(m.CreatedAt) > 0 {
		i -= len(m.CreatedAt)
		copy(dAtA[i:], m.CreatedAt)
		i = encodeVarintPatient(dAtA, i, uint64(len(m.CreatedAt)))
		i--
		dAtA[i] = 0x52
	}
	if len(m.AparatsIds) > 0 {
		for iNdEx := len(m.AparatsIds) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.AparatsIds[iNdEx])
			copy(dAtA[i:], m.AparatsIds[iNdEx])
			i = encodeVarintPatient(dAtA, i, uint64(len(m.AparatsIds[iNdEx])))
			i--
			dAtA[i] = 0x4a
		}
	}
	if len(m.LabsIds) > 0 {
		for iNdEx := len(m.LabsIds) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.LabsIds[iNdEx])
			copy(dAtA[i:], m.LabsIds[iNdEx])
			i = encodeVarintPatient(dAtA, i, uint64(len(m.LabsIds[iNdEx])))
			i--
			dAtA[i] = 0x42
		}
	}
	if len(m.DoctorsIds) > 0 {
		for iNdEx := len(m.DoctorsIds) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.DoctorsIds[iNdEx])
			copy(dAtA[i:], m.DoctorsIds[iNdEx])
			i = encodeVarintPatient(dAtA, i, uint64(len(m.DoctorsIds[iNdEx])))
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.PaymentType) > 0 {
		i -= len(m.PaymentType)
		copy(dAtA[i:], m.PaymentType)
		i = encodeVarintPatient(dAtA, i, uint64(len(m.PaymentType)))
		i--
		dAtA[i] = 0x32
	}
	if m.CashCount != 0 {
		i = encodeVarintPatient(dAtA, i, uint64(m.CashCount))
		i--
		dAtA[i] = 0x28
	}
	if m.IsPayed {
		i--
		if m.IsPayed {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.Summa != 0 {
		i = encodeVarintPatient(dAtA, i, uint64(m.Summa))
		i--
		dAtA[i] = 0x18
	}
	if m.ClientId != 0 {
		i = encodeVarintPatient(dAtA, i, uint64(m.ClientId))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintPatient(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UpdateQueueReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateQueueReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateQueueReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ServiceType) > 0 {
		i -= len(m.ServiceType)
		copy(dAtA[i:], m.ServiceType)
		i = encodeVarintPatient(dAtA, i, uint64(len(m.ServiceType)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ServiceId) > 0 {
		i -= len(m.ServiceId)
		copy(dAtA[i:], m.ServiceId)
		i = encodeVarintPatient(dAtA, i, uint64(len(m.ServiceId)))
		i--
		dAtA[i] = 0x12
	}
	if m.ClientId != 0 {
		i = encodeVarintPatient(dAtA, i, uint64(m.ClientId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CreatePatientQueueReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreatePatientQueueReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreatePatientQueueReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ServiceType) > 0 {
		i -= len(m.ServiceType)
		copy(dAtA[i:], m.ServiceType)
		i = encodeVarintPatient(dAtA, i, uint64(len(m.ServiceType)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.ServiceId) > 0 {
		i -= len(m.ServiceId)
		copy(dAtA[i:], m.ServiceId)
		i = encodeVarintPatient(dAtA, i, uint64(len(m.ServiceId)))
		i--
		dAtA[i] = 0x22
	}
	if m.QueueNumber != 0 {
		i = encodeVarintPatient(dAtA, i, uint64(m.QueueNumber))
		i--
		dAtA[i] = 0x18
	}
	if m.ClientId != 0 {
		i = encodeVarintPatient(dAtA, i, uint64(m.ClientId))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintPatient(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QueueNumber) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueueNumber) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueueNumber) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.QueueNumber != 0 {
		i = encodeVarintPatient(dAtA, i, uint64(m.QueueNumber))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CheckQueueReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CheckQueueReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CheckQueueReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ServiceType) > 0 {
		i -= len(m.ServiceType)
		copy(dAtA[i:], m.ServiceType)
		i = encodeVarintPatient(dAtA, i, uint64(len(m.ServiceType)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ServiceId) > 0 {
		i -= len(m.ServiceId)
		copy(dAtA[i:], m.ServiceId)
		i = encodeVarintPatient(dAtA, i, uint64(len(m.ServiceId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PatientQueueResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PatientQueueResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PatientQueueResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.UpdatedAt) > 0 {
		i -= len(m.UpdatedAt)
		copy(dAtA[i:], m.UpdatedAt)
		i = encodeVarintPatient(dAtA, i, uint64(len(m.UpdatedAt)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.CreatedAt) > 0 {
		i -= len(m.CreatedAt)
		copy(dAtA[i:], m.CreatedAt)
		i = encodeVarintPatient(dAtA, i, uint64(len(m.CreatedAt)))
		i--
		dAtA[i] = 0x3a
	}
	if m.TurnPassed {
		i--
		if m.TurnPassed {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if len(m.ServiceType) > 0 {
		i -= len(m.ServiceType)
		copy(dAtA[i:], m.ServiceType)
		i = encodeVarintPatient(dAtA, i, uint64(len(m.ServiceType)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.ServiceId) > 0 {
		i -= len(m.ServiceId)
		copy(dAtA[i:], m.ServiceId)
		i = encodeVarintPatient(dAtA, i, uint64(len(m.ServiceId)))
		i--
		dAtA[i] = 0x22
	}
	if m.QueueNumber != 0 {
		i = encodeVarintPatient(dAtA, i, uint64(m.QueueNumber))
		i--
		dAtA[i] = 0x18
	}
	if m.ClientId != 0 {
		i = encodeVarintPatient(dAtA, i, uint64(m.ClientId))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintPatient(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *FindCashBoxReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FindCashBoxReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FindCashBoxReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ToDate) > 0 {
		i -= len(m.ToDate)
		copy(dAtA[i:], m.ToDate)
		i = encodeVarintPatient(dAtA, i, uint64(len(m.ToDate)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.FromDate) > 0 {
		i -= len(m.FromDate)
		copy(dAtA[i:], m.FromDate)
		i = encodeVarintPatient(dAtA, i, uint64(len(m.FromDate)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Search) > 0 {
		i -= len(m.Search)
		copy(dAtA[i:], m.Search)
		i = encodeVarintPatient(dAtA, i, uint64(len(m.Search)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Page != 0 {
		i = encodeVarintPatient(dAtA, i, uint64(m.Page))
		i--
		dAtA[i] = 0x10
	}
	if m.Limit != 0 {
		i = encodeVarintPatient(dAtA, i, uint64(m.Limit))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PatientsGetKassaResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PatientsGetKassaResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PatientsGetKassaResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.PaymentType) > 0 {
		i -= len(m.PaymentType)
		copy(dAtA[i:], m.PaymentType)
		i = encodeVarintPatient(dAtA, i, uint64(len(m.PaymentType)))
		i--
		dAtA[i] = 0x2a
	}
	if m.Summa != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Summa))))
		i--
		dAtA[i] = 0x21
	}
	if len(m.LastName) > 0 {
		i -= len(m.LastName)
		copy(dAtA[i:], m.LastName)
		i = encodeVarintPatient(dAtA, i, uint64(len(m.LastName)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.FirstName) > 0 {
		i -= len(m.FirstName)
		copy(dAtA[i:], m.FirstName)
		i = encodeVarintPatient(dAtA, i, uint64(len(m.FirstName)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ClientId) > 0 {
		i -= len(m.ClientId)
		copy(dAtA[i:], m.ClientId)
		i = encodeVarintPatient(dAtA, i, uint64(len(m.ClientId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PatientsGetKassaReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PatientsGetKassaReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PatientsGetKassaReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Page != 0 {
		i = encodeVarintPatient(dAtA, i, uint64(m.Page))
		i--
		dAtA[i] = 0x10
	}
	if m.Limit != 0 {
		i = encodeVarintPatient(dAtA, i, uint64(m.Limit))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PatientsFilter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PatientsFilter) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PatientsFilter) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Limit != 0 {
		i = encodeVarintPatient(dAtA, i, uint64(m.Limit))
		i--
		dAtA[i] = 0x30
	}
	if m.Page != 0 {
		i = encodeVarintPatient(dAtA, i, uint64(m.Page))
		i--
		dAtA[i] = 0x28
	}
	if len(m.ToDate) > 0 {
		i -= len(m.ToDate)
		copy(dAtA[i:], m.ToDate)
		i = encodeVarintPatient(dAtA, i, uint64(len(m.ToDate)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.FromDate) > 0 {
		i -= len(m.FromDate)
		copy(dAtA[i:], m.FromDate)
		i = encodeVarintPatient(dAtA, i, uint64(len(m.FromDate)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Fullname) > 0 {
		i -= len(m.Fullname)
		copy(dAtA[i:], m.Fullname)
		i = encodeVarintPatient(dAtA, i, uint64(len(m.Fullname)))
		i--
		dAtA[i] = 0x12
	}
	if m.ClientId != 0 {
		i = encodeVarintPatient(dAtA, i, uint64(m.ClientId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AddServiceReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AddServiceReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AddServiceReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ClientId != 0 {
		i = encodeVarintPatient(dAtA, i, uint64(m.ClientId))
		i--
		dAtA[i] = 0x20
	}
	if len(m.AparatIds) > 0 {
		for iNdEx := len(m.AparatIds) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.AparatIds[iNdEx])
			copy(dAtA[i:], m.AparatIds[iNdEx])
			i = encodeVarintPatient(dAtA, i, uint64(len(m.AparatIds[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.LabIds) > 0 {
		for iNdEx := len(m.LabIds) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.LabIds[iNdEx])
			copy(dAtA[i:], m.LabIds[iNdEx])
			i = encodeVarintPatient(dAtA, i, uint64(len(m.LabIds[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.DoctorIds) > 0 {
		for iNdEx := len(m.DoctorIds) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.DoctorIds[iNdEx])
			copy(dAtA[i:], m.DoctorIds[iNdEx])
			i = encodeVarintPatient(dAtA, i, uint64(len(m.DoctorIds[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *CashStorage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CashStorage) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CashStorage) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.UpdatedAt) > 0 {
		i -= len(m.UpdatedAt)
		copy(dAtA[i:], m.UpdatedAt)
		i = encodeVarintPatient(dAtA, i, uint64(len(m.UpdatedAt)))
		i--
		dAtA[i] = 0x5a
	}
	if len(m.CreatedAt) > 0 {
		i -= len(m.CreatedAt)
		copy(dAtA[i:], m.CreatedAt)
		i = encodeVarintPatient(dAtA, i, uint64(len(m.CreatedAt)))
		i--
		dAtA[i] = 0x52
	}
	if len(m.AparatIds) > 0 {
		for iNdEx := len(m.AparatIds) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.AparatIds[iNdEx])
			copy(dAtA[i:], m.AparatIds[iNdEx])
			i = encodeVarintPatient(dAtA, i, uint64(len(m.AparatIds[iNdEx])))
			i--
			dAtA[i] = 0x4a
		}
	}
	if len(m.LabIds) > 0 {
		for iNdEx := len(m.LabIds) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.LabIds[iNdEx])
			copy(dAtA[i:], m.LabIds[iNdEx])
			i = encodeVarintPatient(dAtA, i, uint64(len(m.LabIds[iNdEx])))
			i--
			dAtA[i] = 0x42
		}
	}
	if len(m.DoctorIds) > 0 {
		for iNdEx := len(m.DoctorIds) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.DoctorIds[iNdEx])
			copy(dAtA[i:], m.DoctorIds[iNdEx])
			i = encodeVarintPatient(dAtA, i, uint64(len(m.DoctorIds[iNdEx])))
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.PaymentType) > 0 {
		i -= len(m.PaymentType)
		copy(dAtA[i:], m.PaymentType)
		i = encodeVarintPatient(dAtA, i, uint64(len(m.PaymentType)))
		i--
		dAtA[i] = 0x32
	}
	if m.CashCount != 0 {
		i = encodeVarintPatient(dAtA, i, uint64(m.CashCount))
		i--
		dAtA[i] = 0x28
	}
	if m.IsPayed {
		i--
		if m.IsPayed {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.Summa != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Summa))))
		i--
		dAtA[i] = 0x19
	}
	if m.ClientId != 0 {
		i = encodeVarintPatient(dAtA, i, uint64(m.ClientId))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintPatient(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PatientDebtCreateReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PatientDebtCreateReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PatientDebtCreateReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.TermDate) > 0 {
		i -= len(m.TermDate)
		copy(dAtA[i:], m.TermDate)
		i = encodeVarintPatient(dAtA, i, uint64(len(m.TermDate)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Amount != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Amount))))
		i--
		dAtA[i] = 0x15
	}
	if len(m.PatientId) > 0 {
		i -= len(m.PatientId)
		copy(dAtA[i:], m.PatientId)
		i = encodeVarintPatient(dAtA, i, uint64(len(m.PatientId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PatientDebt) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PatientDebt) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PatientDebt) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.UpdatedAt) > 0 {
		i -= len(m.UpdatedAt)
		copy(dAtA[i:], m.UpdatedAt)
		i = encodeVarintPatient(dAtA, i, uint64(len(m.UpdatedAt)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.CreatedAt) > 0 {
		i -= len(m.CreatedAt)
		copy(dAtA[i:], m.CreatedAt)
		i = encodeVarintPatient(dAtA, i, uint64(len(m.CreatedAt)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.TermDate) > 0 {
		i -= len(m.TermDate)
		copy(dAtA[i:], m.TermDate)
		i = encodeVarintPatient(dAtA, i, uint64(len(m.TermDate)))
		i--
		dAtA[i] = 0x22
	}
	if m.Amount != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Amount))))
		i--
		dAtA[i] = 0x1d
	}
	if len(m.PatientId) > 0 {
		i -= len(m.PatientId)
		copy(dAtA[i:], m.PatientId)
		i = encodeVarintPatient(dAtA, i, uint64(len(m.PatientId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintPatient(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CreateAnalysisesReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateAnalysisesReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateAnalysisesReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.AnalysisUrl) > 0 {
		i -= len(m.AnalysisUrl)
		copy(dAtA[i:], m.AnalysisUrl)
		i = encodeVarintPatient(dAtA, i, uint64(len(m.AnalysisUrl)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.AnalysisName) > 0 {
		i -= len(m.AnalysisName)
		copy(dAtA[i:], m.AnalysisName)
		i = encodeVarintPatient(dAtA, i, uint64(len(m.AnalysisName)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ClientPhoneNumber) > 0 {
		i -= len(m.ClientPhoneNumber)
		copy(dAtA[i:], m.ClientPhoneNumber)
		i = encodeVarintPatient(dAtA, i, uint64(len(m.ClientPhoneNumber)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CreateDoctorReportReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateDoctorReportReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateDoctorReportReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.PatientId) > 0 {
		i -= len(m.PatientId)
		copy(dAtA[i:], m.PatientId)
		i = encodeVarintPatient(dAtA, i, uint64(len(m.PatientId)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Text) > 0 {
		i -= len(m.Text)
		copy(dAtA[i:], m.Text)
		i = encodeVarintPatient(dAtA, i, uint64(len(m.Text)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.DoctorId) > 0 {
		i -= len(m.DoctorId)
		copy(dAtA[i:], m.DoctorId)
		i = encodeVarintPatient(dAtA, i, uint64(len(m.DoctorId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AddServiceToCleintReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AddServiceToCleintReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AddServiceToCleintReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ServiceType) > 0 {
		i -= len(m.ServiceType)
		copy(dAtA[i:], m.ServiceType)
		i = encodeVarintPatient(dAtA, i, uint64(len(m.ServiceType)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ServiceId) > 0 {
		i -= len(m.ServiceId)
		copy(dAtA[i:], m.ServiceId)
		i = encodeVarintPatient(dAtA, i, uint64(len(m.ServiceId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.PatientId) > 0 {
		i -= len(m.PatientId)
		copy(dAtA[i:], m.PatientId)
		i = encodeVarintPatient(dAtA, i, uint64(len(m.PatientId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PatientsGetInfoFilter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PatientsGetInfoFilter) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PatientsGetInfoFilter) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Limit != 0 {
		i = encodeVarintPatient(dAtA, i, uint64(m.Limit))
		i--
		dAtA[i] = 0x38
	}
	if m.Page != 0 {
		i = encodeVarintPatient(dAtA, i, uint64(m.Page))
		i--
		dAtA[i] = 0x30
	}
	if len(m.ToDate) > 0 {
		i -= len(m.ToDate)
		copy(dAtA[i:], m.ToDate)
		i = encodeVarintPatient(dAtA, i, uint64(len(m.ToDate)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.FromDate) > 0 {
		i -= len(m.FromDate)
		copy(dAtA[i:], m.FromDate)
		i = encodeVarintPatient(dAtA, i, uint64(len(m.FromDate)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Fullname) > 0 {
		i -= len(m.Fullname)
		copy(dAtA[i:], m.Fullname)
		i = encodeVarintPatient(dAtA, i, uint64(len(m.Fullname)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.PhoneNumber) > 0 {
		i -= len(m.PhoneNumber)
		copy(dAtA[i:], m.PhoneNumber)
		i = encodeVarintPatient(dAtA, i, uint64(len(m.PhoneNumber)))
		i--
		dAtA[i] = 0x12
	}
	if m.ClientId != 0 {
		i = encodeVarintPatient(dAtA, i, uint64(m.ClientId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PatientId) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PatientId) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PatientId) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ClientId != 0 {
		i = encodeVarintPatient(dAtA, i, uint64(m.ClientId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PatientPhoneNumber) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PatientPhoneNumber) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PatientPhoneNumber) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.PhoneNumber) > 0 {
		i -= len(m.PhoneNumber)
		copy(dAtA[i:], m.PhoneNumber)
		i = encodeVarintPatient(dAtA, i, uint64(len(m.PhoneNumber)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PatientDebtInfoResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PatientDebtInfoResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PatientDebtInfoResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Amount != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Amount))))
		i--
		dAtA[i] = 0x15
	}
	if len(m.ClientId) > 0 {
		i -= len(m.ClientId)
		copy(dAtA[i:], m.ClientId)
		i = encodeVarintPatient(dAtA, i, uint64(len(m.ClientId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PatientsMedicalBookGetReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PatientsMedicalBookGetReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PatientsMedicalBookGetReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.PhoneNumber) > 0 {
		i -= len(m.PhoneNumber)
		copy(dAtA[i:], m.PhoneNumber)
		i = encodeVarintPatient(dAtA, i, uint64(len(m.PhoneNumber)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintPatient(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PatientsMedicalBookGetResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PatientsMedicalBookGetResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PatientsMedicalBookGetResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Analysises) > 0 {
		for iNdEx := len(m.Analysises) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Analysises[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPatient(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.DoctorReports) > 0 {
		for iNdEx := len(m.DoctorReports) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.DoctorReports[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPatient(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *DoctorReportInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DoctorReportInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DoctorReportInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.UpdatedAt) > 0 {
		i -= len(m.UpdatedAt)
		copy(dAtA[i:], m.UpdatedAt)
		i = encodeVarintPatient(dAtA, i, uint64(len(m.UpdatedAt)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.CreatedAt) > 0 {
		i -= len(m.CreatedAt)
		copy(dAtA[i:], m.CreatedAt)
		i = encodeVarintPatient(dAtA, i, uint64(len(m.CreatedAt)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.ClientId) > 0 {
		i -= len(m.ClientId)
		copy(dAtA[i:], m.ClientId)
		i = encodeVarintPatient(dAtA, i, uint64(len(m.ClientId)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Text) > 0 {
		i -= len(m.Text)
		copy(dAtA[i:], m.Text)
		i = encodeVarintPatient(dAtA, i, uint64(len(m.Text)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.DoctorId) > 0 {
		i -= len(m.DoctorId)
		copy(dAtA[i:], m.DoctorId)
		i = encodeVarintPatient(dAtA, i, uint64(len(m.DoctorId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintPatient(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AnalysisInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AnalysisInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AnalysisInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.UpdatedAt) > 0 {
		i -= len(m.UpdatedAt)
		copy(dAtA[i:], m.UpdatedAt)
		i = encodeVarintPatient(dAtA, i, uint64(len(m.UpdatedAt)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.CreatedAt) > 0 {
		i -= len(m.CreatedAt)
		copy(dAtA[i:], m.CreatedAt)
		i = encodeVarintPatient(dAtA, i, uint64(len(m.CreatedAt)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.AnalysUrl) > 0 {
		i -= len(m.AnalysUrl)
		copy(dAtA[i:], m.AnalysUrl)
		i = encodeVarintPatient(dAtA, i, uint64(len(m.AnalysUrl)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.AnalysName) > 0 {
		i -= len(m.AnalysName)
		copy(dAtA[i:], m.AnalysName)
		i = encodeVarintPatient(dAtA, i, uint64(len(m.AnalysName)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ClientPhoneNumber) > 0 {
		i -= len(m.ClientPhoneNumber)
		copy(dAtA[i:], m.ClientPhoneNumber)
		i = encodeVarintPatient(dAtA, i, uint64(len(m.ClientPhoneNumber)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintPatient(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetPatientReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetPatientReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetPatientReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Value) > 0 {
		i -= len(m.Value)
		copy(dAtA[i:], m.Value)
		i = encodeVarintPatient(dAtA, i, uint64(len(m.Value)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Field) > 0 {
		i -= len(m.Field)
		copy(dAtA[i:], m.Field)
		i = encodeVarintPatient(dAtA, i, uint64(len(m.Field)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PatientsFindReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PatientsFindReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PatientsFindReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Search) > 0 {
		i -= len(m.Search)
		copy(dAtA[i:], m.Search)
		i = encodeVarintPatient(dAtA, i, uint64(len(m.Search)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Page != 0 {
		i = encodeVarintPatient(dAtA, i, uint64(m.Page))
		i--
		dAtA[i] = 0x10
	}
	if m.Limit != 0 {
		i = encodeVarintPatient(dAtA, i, uint64(m.Limit))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PatientsResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PatientsResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PatientsResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Count != 0 {
		i = encodeVarintPatient(dAtA, i, uint64(m.Count))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Patients) > 0 {
		for iNdEx := len(m.Patients) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Patients[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPatient(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *Patient) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Patient) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Patient) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.UpdatedAt) > 0 {
		i -= len(m.UpdatedAt)
		copy(dAtA[i:], m.UpdatedAt)
		i = encodeVarintPatient(dAtA, i, uint64(len(m.UpdatedAt)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x9a
	}
	if len(m.CreatedAt) > 0 {
		i -= len(m.CreatedAt)
		copy(dAtA[i:], m.CreatedAt)
		i = encodeVarintPatient(dAtA, i, uint64(len(m.CreatedAt)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x92
	}
	if len(m.DoctorId) > 0 {
		i -= len(m.DoctorId)
		copy(dAtA[i:], m.DoctorId)
		i = encodeVarintPatient(dAtA, i, uint64(len(m.DoctorId)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x8a
	}
	if len(m.Gender) > 0 {
		i -= len(m.Gender)
		copy(dAtA[i:], m.Gender)
		i = encodeVarintPatient(dAtA, i, uint64(len(m.Gender)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	if len(m.Condition) > 0 {
		i -= len(m.Condition)
		copy(dAtA[i:], m.Condition)
		i = encodeVarintPatient(dAtA, i, uint64(len(m.Condition)))
		i--
		dAtA[i] = 0x7a
	}
	if len(m.Discount) > 0 {
		i -= len(m.Discount)
		copy(dAtA[i:], m.Discount)
		i = encodeVarintPatient(dAtA, i, uint64(len(m.Discount)))
		i--
		dAtA[i] = 0x72
	}
	if len(m.PassportInfo) > 0 {
		i -= len(m.PassportInfo)
		copy(dAtA[i:], m.PassportInfo)
		i = encodeVarintPatient(dAtA, i, uint64(len(m.PassportInfo)))
		i--
		dAtA[i] = 0x6a
	}
	if len(m.District) > 0 {
		i -= len(m.District)
		copy(dAtA[i:], m.District)
		i = encodeVarintPatient(dAtA, i, uint64(len(m.District)))
		i--
		dAtA[i] = 0x62
	}
	if len(m.Region) > 0 {
		i -= len(m.Region)
		copy(dAtA[i:], m.Region)
		i = encodeVarintPatient(dAtA, i, uint64(len(m.Region)))
		i--
		dAtA[i] = 0x5a
	}
	if len(m.Respublic) > 0 {
		i -= len(m.Respublic)
		copy(dAtA[i:], m.Respublic)
		i = encodeVarintPatient(dAtA, i, uint64(len(m.Respublic)))
		i--
		dAtA[i] = 0x52
	}
	if len(m.AdvertisingChannel) > 0 {
		i -= len(m.AdvertisingChannel)
		copy(dAtA[i:], m.AdvertisingChannel)
		i = encodeVarintPatient(dAtA, i, uint64(len(m.AdvertisingChannel)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.OtherPhoneNumber) > 0 {
		i -= len(m.OtherPhoneNumber)
		copy(dAtA[i:], m.OtherPhoneNumber)
		i = encodeVarintPatient(dAtA, i, uint64(len(m.OtherPhoneNumber)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.MainPhoneNumber) > 0 {
		i -= len(m.MainPhoneNumber)
		copy(dAtA[i:], m.MainPhoneNumber)
		i = encodeVarintPatient(dAtA, i, uint64(len(m.MainPhoneNumber)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.DateOfBirth) > 0 {
		i -= len(m.DateOfBirth)
		copy(dAtA[i:], m.DateOfBirth)
		i = encodeVarintPatient(dAtA, i, uint64(len(m.DateOfBirth)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Patronymic) > 0 {
		i -= len(m.Patronymic)
		copy(dAtA[i:], m.Patronymic)
		i = encodeVarintPatient(dAtA, i, uint64(len(m.Patronymic)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.LastName) > 0 {
		i -= len(m.LastName)
		copy(dAtA[i:], m.LastName)
		i = encodeVarintPatient(dAtA, i, uint64(len(m.LastName)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.FirstName) > 0 {
		i -= len(m.FirstName)
		copy(dAtA[i:], m.FirstName)
		i = encodeVarintPatient(dAtA, i, uint64(len(m.FirstName)))
		i--
		dAtA[i] = 0x1a
	}
	if m.ClientId != 0 {
		i = encodeVarintPatient(dAtA, i, uint64(m.ClientId))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintPatient(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintPatient(dAtA []byte, offset int, v uint64) int {
	offset -= sovPatient(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *PaymentHistoryFilter) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ClientId != 0 {
		n += 1 + sovPatient(uint64(m.ClientId))
	}
	if m.Limit != 0 {
		n += 1 + sovPatient(uint64(m.Limit))
	}
	if m.Page != 0 {
		n += 1 + sovPatient(uint64(m.Page))
	}
	l = len(m.FromDate)
	if l > 0 {
		n += 1 + l + sovPatient(uint64(l))
	}
	l = len(m.ToDate)
	if l > 0 {
		n += 1 + l + sovPatient(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PaymentHistoriesResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.PaymentHistory) > 0 {
		for _, e := range m.PaymentHistory {
			l = e.Size()
			n += 1 + l + sovPatient(uint64(l))
		}
	}
	if m.Count != 0 {
		n += 1 + sovPatient(uint64(m.Count))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PaymentHistoryId) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovPatient(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CreatePaymentHistoryReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovPatient(uint64(l))
	}
	if m.ClientId != 0 {
		n += 1 + sovPatient(uint64(m.ClientId))
	}
	if m.Summa != 0 {
		n += 1 + sovPatient(uint64(m.Summa))
	}
	l = len(m.PaymentType)
	if l > 0 {
		n += 1 + l + sovPatient(uint64(l))
	}
	l = len(m.CashboxId)
	if l > 0 {
		n += 1 + l + sovPatient(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PaymentHistoryResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovPatient(uint64(l))
	}
	if m.ClientId != 0 {
		n += 1 + sovPatient(uint64(m.ClientId))
	}
	if m.Summa != 0 {
		n += 1 + sovPatient(uint64(m.Summa))
	}
	l = len(m.PaymentType)
	if l > 0 {
		n += 1 + l + sovPatient(uint64(l))
	}
	l = len(m.CashboxId)
	if l > 0 {
		n += 1 + l + sovPatient(uint64(l))
	}
	l = len(m.CreatedAt)
	if l > 0 {
		n += 1 + l + sovPatient(uint64(l))
	}
	l = len(m.UpdatedAt)
	if l > 0 {
		n += 1 + l + sovPatient(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetCashboxReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.CashboxId)
	if l > 0 {
		n += 1 + l + sovPatient(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UpdateCashboxReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovPatient(uint64(l))
	}
	if m.IsPayed {
		n += 2
	}
	l = len(m.PaymentType)
	if l > 0 {
		n += 1 + l + sovPatient(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FindCashboxReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ClientId != 0 {
		n += 1 + sovPatient(uint64(m.ClientId))
	}
	l = len(m.Search)
	if l > 0 {
		n += 1 + l + sovPatient(uint64(l))
	}
	if m.Page != 0 {
		n += 1 + sovPatient(uint64(m.Page))
	}
	if m.Limit != 0 {
		n += 1 + sovPatient(uint64(m.Limit))
	}
	l = len(m.FromDate)
	if l > 0 {
		n += 1 + l + sovPatient(uint64(l))
	}
	l = len(m.ToDate)
	if l > 0 {
		n += 1 + l + sovPatient(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FindCashboxResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Cashboxes) > 0 {
		for _, e := range m.Cashboxes {
			l = e.Size()
			n += 1 + l + sovPatient(uint64(l))
		}
	}
	if m.Count != 0 {
		n += 1 + sovPatient(uint64(m.Count))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *QueueFilter) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ServiceId)
	if l > 0 {
		n += 1 + l + sovPatient(uint64(l))
	}
	l = len(m.ServiceType)
	if l > 0 {
		n += 1 + l + sovPatient(uint64(l))
	}
	if m.ClientId != 0 {
		n += 1 + sovPatient(uint64(m.ClientId))
	}
	if m.Page != 0 {
		n += 1 + sovPatient(uint64(m.Page))
	}
	if m.Limit != 0 {
		n += 1 + sovPatient(uint64(m.Limit))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *QueuesResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Queues) > 0 {
		for _, e := range m.Queues {
			l = e.Size()
			n += 1 + l + sovPatient(uint64(l))
		}
	}
	if m.Count != 0 {
		n += 1 + sovPatient(uint64(m.Count))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CreateCashboxReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovPatient(uint64(l))
	}
	if m.ClientId != 0 {
		n += 1 + sovPatient(uint64(m.ClientId))
	}
	if m.IsPayed {
		n += 2
	}
	if m.CashCount != 0 {
		n += 1 + sovPatient(uint64(m.CashCount))
	}
	l = len(m.PaymentType)
	if l > 0 {
		n += 1 + l + sovPatient(uint64(l))
	}
	if len(m.DoctorsIds) > 0 {
		for _, s := range m.DoctorsIds {
			l = len(s)
			n += 1 + l + sovPatient(uint64(l))
		}
	}
	if len(m.LabsIds) > 0 {
		for _, s := range m.LabsIds {
			l = len(s)
			n += 1 + l + sovPatient(uint64(l))
		}
	}
	if len(m.AparatsIds) > 0 {
		for _, s := range m.AparatsIds {
			l = len(s)
			n += 1 + l + sovPatient(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CashboxResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovPatient(uint64(l))
	}
	if m.ClientId != 0 {
		n += 1 + sovPatient(uint64(m.ClientId))
	}
	if m.Summa != 0 {
		n += 1 + sovPatient(uint64(m.Summa))
	}
	if m.IsPayed {
		n += 2
	}
	if m.CashCount != 0 {
		n += 1 + sovPatient(uint64(m.CashCount))
	}
	l = len(m.PaymentType)
	if l > 0 {
		n += 1 + l + sovPatient(uint64(l))
	}
	if len(m.DoctorsIds) > 0 {
		for _, s := range m.DoctorsIds {
			l = len(s)
			n += 1 + l + sovPatient(uint64(l))
		}
	}
	if len(m.LabsIds) > 0 {
		for _, s := range m.LabsIds {
			l = len(s)
			n += 1 + l + sovPatient(uint64(l))
		}
	}
	if len(m.AparatsIds) > 0 {
		for _, s := range m.AparatsIds {
			l = len(s)
			n += 1 + l + sovPatient(uint64(l))
		}
	}
	l = len(m.CreatedAt)
	if l > 0 {
		n += 1 + l + sovPatient(uint64(l))
	}
	l = len(m.UpdatedAt)
	if l > 0 {
		n += 1 + l + sovPatient(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UpdateQueueReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ClientId != 0 {
		n += 1 + sovPatient(uint64(m.ClientId))
	}
	l = len(m.ServiceId)
	if l > 0 {
		n += 1 + l + sovPatient(uint64(l))
	}
	l = len(m.ServiceType)
	if l > 0 {
		n += 1 + l + sovPatient(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CreatePatientQueueReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovPatient(uint64(l))
	}
	if m.ClientId != 0 {
		n += 1 + sovPatient(uint64(m.ClientId))
	}
	if m.QueueNumber != 0 {
		n += 1 + sovPatient(uint64(m.QueueNumber))
	}
	l = len(m.ServiceId)
	if l > 0 {
		n += 1 + l + sovPatient(uint64(l))
	}
	l = len(m.ServiceType)
	if l > 0 {
		n += 1 + l + sovPatient(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *QueueNumber) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.QueueNumber != 0 {
		n += 1 + sovPatient(uint64(m.QueueNumber))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CheckQueueReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ServiceId)
	if l > 0 {
		n += 1 + l + sovPatient(uint64(l))
	}
	l = len(m.ServiceType)
	if l > 0 {
		n += 1 + l + sovPatient(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PatientQueueResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovPatient(uint64(l))
	}
	if m.ClientId != 0 {
		n += 1 + sovPatient(uint64(m.ClientId))
	}
	if m.QueueNumber != 0 {
		n += 1 + sovPatient(uint64(m.QueueNumber))
	}
	l = len(m.ServiceId)
	if l > 0 {
		n += 1 + l + sovPatient(uint64(l))
	}
	l = len(m.ServiceType)
	if l > 0 {
		n += 1 + l + sovPatient(uint64(l))
	}
	if m.TurnPassed {
		n += 2
	}
	l = len(m.CreatedAt)
	if l > 0 {
		n += 1 + l + sovPatient(uint64(l))
	}
	l = len(m.UpdatedAt)
	if l > 0 {
		n += 1 + l + sovPatient(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FindCashBoxReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Limit != 0 {
		n += 1 + sovPatient(uint64(m.Limit))
	}
	if m.Page != 0 {
		n += 1 + sovPatient(uint64(m.Page))
	}
	l = len(m.Search)
	if l > 0 {
		n += 1 + l + sovPatient(uint64(l))
	}
	l = len(m.FromDate)
	if l > 0 {
		n += 1 + l + sovPatient(uint64(l))
	}
	l = len(m.ToDate)
	if l > 0 {
		n += 1 + l + sovPatient(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PatientsGetKassaResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ClientId)
	if l > 0 {
		n += 1 + l + sovPatient(uint64(l))
	}
	l = len(m.FirstName)
	if l > 0 {
		n += 1 + l + sovPatient(uint64(l))
	}
	l = len(m.LastName)
	if l > 0 {
		n += 1 + l + sovPatient(uint64(l))
	}
	if m.Summa != 0 {
		n += 9
	}
	l = len(m.PaymentType)
	if l > 0 {
		n += 1 + l + sovPatient(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PatientsGetKassaReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Limit != 0 {
		n += 1 + sovPatient(uint64(m.Limit))
	}
	if m.Page != 0 {
		n += 1 + sovPatient(uint64(m.Page))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PatientsFilter) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ClientId != 0 {
		n += 1 + sovPatient(uint64(m.ClientId))
	}
	l = len(m.Fullname)
	if l > 0 {
		n += 1 + l + sovPatient(uint64(l))
	}
	l = len(m.FromDate)
	if l > 0 {
		n += 1 + l + sovPatient(uint64(l))
	}
	l = len(m.ToDate)
	if l > 0 {
		n += 1 + l + sovPatient(uint64(l))
	}
	if m.Page != 0 {
		n += 1 + sovPatient(uint64(m.Page))
	}
	if m.Limit != 0 {
		n += 1 + sovPatient(uint64(m.Limit))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AddServiceReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.DoctorIds) > 0 {
		for _, s := range m.DoctorIds {
			l = len(s)
			n += 1 + l + sovPatient(uint64(l))
		}
	}
	if len(m.LabIds) > 0 {
		for _, s := range m.LabIds {
			l = len(s)
			n += 1 + l + sovPatient(uint64(l))
		}
	}
	if len(m.AparatIds) > 0 {
		for _, s := range m.AparatIds {
			l = len(s)
			n += 1 + l + sovPatient(uint64(l))
		}
	}
	if m.ClientId != 0 {
		n += 1 + sovPatient(uint64(m.ClientId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CashStorage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovPatient(uint64(l))
	}
	if m.ClientId != 0 {
		n += 1 + sovPatient(uint64(m.ClientId))
	}
	if m.Summa != 0 {
		n += 9
	}
	if m.IsPayed {
		n += 2
	}
	if m.CashCount != 0 {
		n += 1 + sovPatient(uint64(m.CashCount))
	}
	l = len(m.PaymentType)
	if l > 0 {
		n += 1 + l + sovPatient(uint64(l))
	}
	if len(m.DoctorIds) > 0 {
		for _, s := range m.DoctorIds {
			l = len(s)
			n += 1 + l + sovPatient(uint64(l))
		}
	}
	if len(m.LabIds) > 0 {
		for _, s := range m.LabIds {
			l = len(s)
			n += 1 + l + sovPatient(uint64(l))
		}
	}
	if len(m.AparatIds) > 0 {
		for _, s := range m.AparatIds {
			l = len(s)
			n += 1 + l + sovPatient(uint64(l))
		}
	}
	l = len(m.CreatedAt)
	if l > 0 {
		n += 1 + l + sovPatient(uint64(l))
	}
	l = len(m.UpdatedAt)
	if l > 0 {
		n += 1 + l + sovPatient(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PatientDebtCreateReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PatientId)
	if l > 0 {
		n += 1 + l + sovPatient(uint64(l))
	}
	if m.Amount != 0 {
		n += 5
	}
	l = len(m.TermDate)
	if l > 0 {
		n += 1 + l + sovPatient(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PatientDebt) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovPatient(uint64(l))
	}
	l = len(m.PatientId)
	if l > 0 {
		n += 1 + l + sovPatient(uint64(l))
	}
	if m.Amount != 0 {
		n += 5
	}
	l = len(m.TermDate)
	if l > 0 {
		n += 1 + l + sovPatient(uint64(l))
	}
	l = len(m.CreatedAt)
	if l > 0 {
		n += 1 + l + sovPatient(uint64(l))
	}
	l = len(m.UpdatedAt)
	if l > 0 {
		n += 1 + l + sovPatient(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CreateAnalysisesReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ClientPhoneNumber)
	if l > 0 {
		n += 1 + l + sovPatient(uint64(l))
	}
	l = len(m.AnalysisName)
	if l > 0 {
		n += 1 + l + sovPatient(uint64(l))
	}
	l = len(m.AnalysisUrl)
	if l > 0 {
		n += 1 + l + sovPatient(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CreateDoctorReportReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.DoctorId)
	if l > 0 {
		n += 1 + l + sovPatient(uint64(l))
	}
	l = len(m.Text)
	if l > 0 {
		n += 1 + l + sovPatient(uint64(l))
	}
	l = len(m.PatientId)
	if l > 0 {
		n += 1 + l + sovPatient(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AddServiceToCleintReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PatientId)
	if l > 0 {
		n += 1 + l + sovPatient(uint64(l))
	}
	l = len(m.ServiceId)
	if l > 0 {
		n += 1 + l + sovPatient(uint64(l))
	}
	l = len(m.ServiceType)
	if l > 0 {
		n += 1 + l + sovPatient(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PatientsGetInfoFilter) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ClientId != 0 {
		n += 1 + sovPatient(uint64(m.ClientId))
	}
	l = len(m.PhoneNumber)
	if l > 0 {
		n += 1 + l + sovPatient(uint64(l))
	}
	l = len(m.Fullname)
	if l > 0 {
		n += 1 + l + sovPatient(uint64(l))
	}
	l = len(m.FromDate)
	if l > 0 {
		n += 1 + l + sovPatient(uint64(l))
	}
	l = len(m.ToDate)
	if l > 0 {
		n += 1 + l + sovPatient(uint64(l))
	}
	if m.Page != 0 {
		n += 1 + sovPatient(uint64(m.Page))
	}
	if m.Limit != 0 {
		n += 1 + sovPatient(uint64(m.Limit))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PatientId) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ClientId != 0 {
		n += 1 + sovPatient(uint64(m.ClientId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PatientPhoneNumber) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PhoneNumber)
	if l > 0 {
		n += 1 + l + sovPatient(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PatientDebtInfoResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ClientId)
	if l > 0 {
		n += 1 + l + sovPatient(uint64(l))
	}
	if m.Amount != 0 {
		n += 5
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PatientsMedicalBookGetReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovPatient(uint64(l))
	}
	l = len(m.PhoneNumber)
	if l > 0 {
		n += 1 + l + sovPatient(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PatientsMedicalBookGetResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.DoctorReports) > 0 {
		for _, e := range m.DoctorReports {
			l = e.Size()
			n += 1 + l + sovPatient(uint64(l))
		}
	}
	if len(m.Analysises) > 0 {
		for _, e := range m.Analysises {
			l = e.Size()
			n += 1 + l + sovPatient(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DoctorReportInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovPatient(uint64(l))
	}
	l = len(m.DoctorId)
	if l > 0 {
		n += 1 + l + sovPatient(uint64(l))
	}
	l = len(m.Text)
	if l > 0 {
		n += 1 + l + sovPatient(uint64(l))
	}
	l = len(m.ClientId)
	if l > 0 {
		n += 1 + l + sovPatient(uint64(l))
	}
	l = len(m.CreatedAt)
	if l > 0 {
		n += 1 + l + sovPatient(uint64(l))
	}
	l = len(m.UpdatedAt)
	if l > 0 {
		n += 1 + l + sovPatient(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AnalysisInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovPatient(uint64(l))
	}
	l = len(m.ClientPhoneNumber)
	if l > 0 {
		n += 1 + l + sovPatient(uint64(l))
	}
	l = len(m.AnalysName)
	if l > 0 {
		n += 1 + l + sovPatient(uint64(l))
	}
	l = len(m.AnalysUrl)
	if l > 0 {
		n += 1 + l + sovPatient(uint64(l))
	}
	l = len(m.CreatedAt)
	if l > 0 {
		n += 1 + l + sovPatient(uint64(l))
	}
	l = len(m.UpdatedAt)
	if l > 0 {
		n += 1 + l + sovPatient(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetPatientReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Field)
	if l > 0 {
		n += 1 + l + sovPatient(uint64(l))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovPatient(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PatientsFindReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Limit != 0 {
		n += 1 + sovPatient(uint64(m.Limit))
	}
	if m.Page != 0 {
		n += 1 + sovPatient(uint64(m.Page))
	}
	l = len(m.Search)
	if l > 0 {
		n += 1 + l + sovPatient(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PatientsResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Patients) > 0 {
		for _, e := range m.Patients {
			l = e.Size()
			n += 1 + l + sovPatient(uint64(l))
		}
	}
	if m.Count != 0 {
		n += 1 + sovPatient(uint64(m.Count))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Patient) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovPatient(uint64(l))
	}
	if m.ClientId != 0 {
		n += 1 + sovPatient(uint64(m.ClientId))
	}
	l = len(m.FirstName)
	if l > 0 {
		n += 1 + l + sovPatient(uint64(l))
	}
	l = len(m.LastName)
	if l > 0 {
		n += 1 + l + sovPatient(uint64(l))
	}
	l = len(m.Patronymic)
	if l > 0 {
		n += 1 + l + sovPatient(uint64(l))
	}
	l = len(m.DateOfBirth)
	if l > 0 {
		n += 1 + l + sovPatient(uint64(l))
	}
	l = len(m.MainPhoneNumber)
	if l > 0 {
		n += 1 + l + sovPatient(uint64(l))
	}
	l = len(m.OtherPhoneNumber)
	if l > 0 {
		n += 1 + l + sovPatient(uint64(l))
	}
	l = len(m.AdvertisingChannel)
	if l > 0 {
		n += 1 + l + sovPatient(uint64(l))
	}
	l = len(m.Respublic)
	if l > 0 {
		n += 1 + l + sovPatient(uint64(l))
	}
	l = len(m.Region)
	if l > 0 {
		n += 1 + l + sovPatient(uint64(l))
	}
	l = len(m.District)
	if l > 0 {
		n += 1 + l + sovPatient(uint64(l))
	}
	l = len(m.PassportInfo)
	if l > 0 {
		n += 1 + l + sovPatient(uint64(l))
	}
	l = len(m.Discount)
	if l > 0 {
		n += 1 + l + sovPatient(uint64(l))
	}
	l = len(m.Condition)
	if l > 0 {
		n += 1 + l + sovPatient(uint64(l))
	}
	l = len(m.Gender)
	if l > 0 {
		n += 2 + l + sovPatient(uint64(l))
	}
	l = len(m.DoctorId)
	if l > 0 {
		n += 2 + l + sovPatient(uint64(l))
	}
	l = len(m.CreatedAt)
	if l > 0 {
		n += 2 + l + sovPatient(uint64(l))
	}
	l = len(m.UpdatedAt)
	if l > 0 {
		n += 2 + l + sovPatient(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovPatient(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozPatient(x uint64) (n int) {
	return sovPatient(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *PaymentHistoryFilter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPatient
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PaymentHistoryFilter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PaymentHistoryFilter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientId", wireType)
			}
			m.ClientId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPatient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClientId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			m.Limit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPatient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Limit |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Page", wireType)
			}
			m.Page = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPatient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Page |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromDate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPatient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPatient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPatient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FromDate = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ToDate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPatient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPatient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPatient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ToDate = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPatient(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPatient
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PaymentHistoriesResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPatient
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PaymentHistoriesResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PaymentHistoriesResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PaymentHistory", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPatient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPatient
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPatient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PaymentHistory = append(m.PaymentHistory, &PaymentHistoryResp{})
			if err := m.PaymentHistory[len(m.PaymentHistory)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPatient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Count |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPatient(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPatient
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PaymentHistoryId) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPatient
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PaymentHistoryId: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PaymentHistoryId: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPatient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPatient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPatient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPatient(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPatient
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreatePaymentHistoryReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPatient
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreatePaymentHistoryReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreatePaymentHistoryReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPatient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPatient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPatient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientId", wireType)
			}
			m.ClientId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPatient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClientId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Summa", wireType)
			}
			m.Summa = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPatient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Summa |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PaymentType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPatient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPatient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPatient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PaymentType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CashboxId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPatient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPatient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPatient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CashboxId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPatient(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPatient
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PaymentHistoryResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPatient
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PaymentHistoryResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PaymentHistoryResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPatient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPatient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPatient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientId", wireType)
			}
			m.ClientId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPatient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClientId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Summa", wireType)
			}
			m.Summa = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPatient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Summa |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PaymentType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPatient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPatient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPatient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PaymentType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CashboxId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPatient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPatient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPatient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CashboxId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedAt", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPatient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPatient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPatient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CreatedAt = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdatedAt", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPatient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPatient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPatient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UpdatedAt = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPatient(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPatient
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetCashboxReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPatient
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetCashboxReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetCashboxReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CashboxId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPatient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPatient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPatient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CashboxId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPatient(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPatient
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateCashboxReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPatient
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateCashboxReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateCashboxReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPatient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPatient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPatient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsPayed", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPatient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsPayed = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PaymentType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPatient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPatient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPatient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PaymentType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPatient(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPatient
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FindCashboxReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPatient
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FindCashboxReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FindCashboxReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientId", wireType)
			}
			m.ClientId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPatient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClientId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Search", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPatient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPatient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPatient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Search = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Page", wireType)
			}
			m.Page = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPatient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Page |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			m.Limit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPatient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Limit |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromDate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPatient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPatient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPatient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FromDate = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ToDate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPatient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPatient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPatient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ToDate = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPatient(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPatient
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FindCashboxResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPatient
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FindCashboxResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FindCashboxResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cashboxes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPatient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPatient
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPatient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cashboxes = append(m.Cashboxes, &CashboxResp{})
			if err := m.Cashboxes[len(m.Cashboxes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPatient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Count |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPatient(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPatient
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueueFilter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPatient
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueueFilter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueueFilter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPatient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPatient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPatient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServiceId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPatient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPatient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPatient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServiceType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientId", wireType)
			}
			m.ClientId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPatient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClientId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Page", wireType)
			}
			m.Page = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPatient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Page |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			m.Limit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPatient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Limit |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPatient(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPatient
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueuesResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPatient
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueuesResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueuesResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Queues", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPatient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPatient
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPatient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Queues = append(m.Queues, &PatientQueueResp{})
			if err := m.Queues[len(m.Queues)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPatient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Count |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPatient(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPatient
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateCashboxReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPatient
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateCashboxReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateCashboxReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPatient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPatient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPatient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientId", wireType)
			}
			m.ClientId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPatient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClientId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsPayed", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPatient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsPayed = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CashCount", wireType)
			}
			m.CashCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPatient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CashCount |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PaymentType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPatient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPatient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPatient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PaymentType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DoctorsIds", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPatient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPatient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPatient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DoctorsIds = append(m.DoctorsIds, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LabsIds", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPatient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPatient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPatient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LabsIds = append(m.LabsIds, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AparatsIds", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPatient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPatient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPatient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AparatsIds = append(m.AparatsIds, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPatient(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPatient
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CashboxResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPatient
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CashboxResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CashboxResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPatient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPatient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPatient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientId", wireType)
			}
			m.ClientId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPatient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClientId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Summa", wireType)
			}
			m.Summa = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPatient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Summa |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsPayed", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPatient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsPayed = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CashCount", wireType)
			}
			m.CashCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPatient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CashCount |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PaymentType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPatient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPatient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPatient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PaymentType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DoctorsIds", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPatient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPatient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPatient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DoctorsIds = append(m.DoctorsIds, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LabsIds", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPatient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPatient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPatient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LabsIds = append(m.LabsIds, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AparatsIds", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPatient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPatient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPatient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AparatsIds = append(m.AparatsIds, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedAt", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPatient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPatient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPatient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CreatedAt = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdatedAt", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPatient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPatient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPatient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UpdatedAt = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPatient(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPatient
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateQueueReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPatient
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateQueueReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateQueueReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientId", wireType)
			}
			m.ClientId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPatient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClientId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPatient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPatient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPatient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServiceId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPatient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPatient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPatient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServiceType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPatient(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPatient
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreatePatientQueueReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPatient
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreatePatientQueueReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreatePatientQueueReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPatient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPatient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPatient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientId", wireType)
			}
			m.ClientId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPatient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClientId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field QueueNumber", wireType)
			}
			m.QueueNumber = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPatient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.QueueNumber |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPatient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPatient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPatient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServiceId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPatient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPatient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPatient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServiceType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPatient(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPatient
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueueNumber) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPatient
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueueNumber: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueueNumber: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field QueueNumber", wireType)
			}
			m.QueueNumber = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPatient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.QueueNumber |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPatient(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPatient
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CheckQueueReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPatient
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CheckQueueReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CheckQueueReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPatient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPatient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPatient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServiceId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPatient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPatient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPatient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServiceType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPatient(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPatient
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PatientQueueResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPatient
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PatientQueueResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PatientQueueResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPatient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPatient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPatient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientId", wireType)
			}
			m.ClientId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPatient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClientId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field QueueNumber", wireType)
			}
			m.QueueNumber = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPatient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.QueueNumber |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPatient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPatient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPatient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServiceId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPatient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPatient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPatient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServiceType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TurnPassed", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPatient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TurnPassed = bool(v != 0)
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedAt", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPatient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPatient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPatient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CreatedAt = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdatedAt", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPatient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPatient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPatient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UpdatedAt = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPatient(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPatient
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FindCashBoxReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPatient
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FindCashBoxReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FindCashBoxReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			m.Limit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPatient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Limit |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Page", wireType)
			}
			m.Page = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPatient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Page |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Search", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPatient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPatient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPatient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Search = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromDate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPatient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPatient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPatient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FromDate = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ToDate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPatient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPatient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPatient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ToDate = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPatient(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPatient
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PatientsGetKassaResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPatient
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PatientsGetKassaResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PatientsGetKassaResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPatient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPatient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPatient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FirstName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPatient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPatient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPatient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FirstName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPatient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPatient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPatient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LastName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Summa", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Summa = float64(math.Float64frombits(v))
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PaymentType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPatient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPatient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPatient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PaymentType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPatient(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPatient
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PatientsGetKassaReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPatient
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PatientsGetKassaReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PatientsGetKassaReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			m.Limit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPatient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Limit |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Page", wireType)
			}
			m.Page = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPatient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Page |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPatient(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPatient
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PatientsFilter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPatient
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PatientsFilter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PatientsFilter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientId", wireType)
			}
			m.ClientId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPatient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClientId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fullname", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPatient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPatient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPatient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Fullname = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromDate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPatient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPatient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPatient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FromDate = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ToDate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPatient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPatient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPatient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ToDate = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Page", wireType)
			}
			m.Page = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPatient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Page |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			m.Limit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPatient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Limit |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPatient(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPatient
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AddServiceReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPatient
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AddServiceReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AddServiceReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DoctorIds", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPatient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPatient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPatient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DoctorIds = append(m.DoctorIds, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LabIds", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPatient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPatient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPatient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LabIds = append(m.LabIds, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AparatIds", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPatient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPatient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPatient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AparatIds = append(m.AparatIds, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientId", wireType)
			}
			m.ClientId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPatient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClientId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPatient(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPatient
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CashStorage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPatient
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CashStorage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CashStorage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPatient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPatient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPatient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientId", wireType)
			}
			m.ClientId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPatient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClientId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Summa", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Summa = float64(math.Float64frombits(v))
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsPayed", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPatient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsPayed = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CashCount", wireType)
			}
			m.CashCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPatient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CashCount |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PaymentType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPatient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPatient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPatient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PaymentType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DoctorIds", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPatient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPatient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPatient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DoctorIds = append(m.DoctorIds, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LabIds", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPatient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPatient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPatient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LabIds = append(m.LabIds, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AparatIds", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPatient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPatient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPatient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AparatIds = append(m.AparatIds, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedAt", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPatient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPatient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPatient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CreatedAt = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdatedAt", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPatient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPatient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPatient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UpdatedAt = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPatient(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPatient
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PatientDebtCreateReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPatient
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PatientDebtCreateReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PatientDebtCreateReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PatientId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPatient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPatient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPatient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PatientId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Amount = float32(math.Float32frombits(v))
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TermDate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPatient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPatient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPatient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TermDate = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPatient(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPatient
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PatientDebt) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPatient
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PatientDebt: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PatientDebt: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPatient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPatient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPatient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PatientId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPatient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPatient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPatient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PatientId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Amount = float32(math.Float32frombits(v))
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TermDate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPatient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPatient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPatient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TermDate = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedAt", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPatient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPatient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPatient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CreatedAt = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdatedAt", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPatient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPatient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPatient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UpdatedAt = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPatient(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPatient
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateAnalysisesReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPatient
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateAnalysisesReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateAnalysisesReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientPhoneNumber", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPatient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPatient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPatient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientPhoneNumber = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AnalysisName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPatient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPatient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPatient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AnalysisName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AnalysisUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPatient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPatient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPatient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AnalysisUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPatient(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPatient
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateDoctorReportReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPatient
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateDoctorReportReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateDoctorReportReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DoctorId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPatient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPatient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPatient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DoctorId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Text", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPatient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPatient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPatient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Text = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PatientId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPatient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPatient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPatient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PatientId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPatient(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPatient
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AddServiceToCleintReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPatient
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AddServiceToCleintReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AddServiceToCleintReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PatientId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPatient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPatient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPatient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PatientId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPatient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPatient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPatient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServiceId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPatient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPatient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPatient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServiceType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPatient(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPatient
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PatientsGetInfoFilter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPatient
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PatientsGetInfoFilter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PatientsGetInfoFilter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientId", wireType)
			}
			m.ClientId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPatient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClientId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PhoneNumber", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPatient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPatient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPatient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PhoneNumber = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fullname", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPatient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPatient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPatient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Fullname = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromDate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPatient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPatient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPatient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FromDate = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ToDate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPatient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPatient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPatient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ToDate = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Page", wireType)
			}
			m.Page = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPatient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Page |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			m.Limit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPatient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Limit |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPatient(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPatient
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PatientId) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPatient
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PatientId: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PatientId: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientId", wireType)
			}
			m.ClientId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPatient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClientId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPatient(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPatient
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PatientPhoneNumber) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPatient
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PatientPhoneNumber: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PatientPhoneNumber: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PhoneNumber", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPatient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPatient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPatient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PhoneNumber = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPatient(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPatient
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PatientDebtInfoResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPatient
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PatientDebtInfoResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PatientDebtInfoResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPatient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPatient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPatient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Amount = float32(math.Float32frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipPatient(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPatient
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PatientsMedicalBookGetReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPatient
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PatientsMedicalBookGetReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PatientsMedicalBookGetReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPatient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPatient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPatient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PhoneNumber", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPatient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPatient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPatient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PhoneNumber = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPatient(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPatient
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PatientsMedicalBookGetResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPatient
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PatientsMedicalBookGetResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PatientsMedicalBookGetResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DoctorReports", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPatient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPatient
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPatient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DoctorReports = append(m.DoctorReports, &DoctorReportInfo{})
			if err := m.DoctorReports[len(m.DoctorReports)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Analysises", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPatient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPatient
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPatient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Analysises = append(m.Analysises, &AnalysisInfo{})
			if err := m.Analysises[len(m.Analysises)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPatient(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPatient
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DoctorReportInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPatient
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DoctorReportInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DoctorReportInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPatient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPatient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPatient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DoctorId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPatient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPatient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPatient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DoctorId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Text", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPatient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPatient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPatient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Text = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPatient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPatient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPatient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedAt", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPatient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPatient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPatient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CreatedAt = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdatedAt", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPatient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPatient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPatient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UpdatedAt = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPatient(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPatient
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AnalysisInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPatient
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AnalysisInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AnalysisInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPatient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPatient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPatient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientPhoneNumber", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPatient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPatient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPatient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientPhoneNumber = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AnalysName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPatient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPatient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPatient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AnalysName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AnalysUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPatient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPatient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPatient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AnalysUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedAt", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPatient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPatient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPatient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CreatedAt = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdatedAt", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPatient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPatient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPatient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UpdatedAt = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPatient(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPatient
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetPatientReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPatient
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetPatientReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetPatientReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Field", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPatient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPatient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPatient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Field = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPatient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPatient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPatient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPatient(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPatient
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PatientsFindReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPatient
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PatientsFindReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PatientsFindReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			m.Limit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPatient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Limit |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Page", wireType)
			}
			m.Page = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPatient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Page |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Search", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPatient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPatient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPatient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Search = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPatient(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPatient
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PatientsResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPatient
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PatientsResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PatientsResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Patients", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPatient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPatient
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPatient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Patients = append(m.Patients, &Patient{})
			if err := m.Patients[len(m.Patients)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPatient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Count |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPatient(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPatient
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Patient) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPatient
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Patient: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Patient: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPatient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPatient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPatient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientId", wireType)
			}
			m.ClientId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPatient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClientId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FirstName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPatient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPatient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPatient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FirstName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPatient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPatient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPatient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LastName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Patronymic", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPatient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPatient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPatient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Patronymic = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DateOfBirth", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPatient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPatient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPatient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DateOfBirth = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MainPhoneNumber", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPatient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPatient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPatient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MainPhoneNumber = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OtherPhoneNumber", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPatient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPatient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPatient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OtherPhoneNumber = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdvertisingChannel", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPatient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPatient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPatient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AdvertisingChannel = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Respublic", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPatient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPatient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPatient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Respublic = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Region", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPatient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPatient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPatient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Region = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field District", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPatient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPatient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPatient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.District = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PassportInfo", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPatient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPatient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPatient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PassportInfo = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Discount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPatient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPatient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPatient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Discount = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Condition", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPatient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPatient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPatient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Condition = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPatient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPatient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPatient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Gender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DoctorId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPatient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPatient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPatient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DoctorId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedAt", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPatient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPatient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPatient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CreatedAt = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdatedAt", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPatient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPatient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPatient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UpdatedAt = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPatient(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPatient
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipPatient(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowPatient
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPatient
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPatient
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthPatient
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupPatient
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthPatient
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthPatient        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowPatient          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupPatient = fmt.Errorf("proto: unexpected end of group")
)
